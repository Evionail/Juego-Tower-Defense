<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense Progresivo</title>

    <!-- Meta tags for iOS Web App -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TD Progresivo">
    <link rel="apple-touch-icon" href="Assets/icon-png-tdp.png">
    
    <!-- PWA Manifest for Android -->
    <link rel="manifest" href="data:application/manifest+json,{
      &quot;name&quot;: &quot;Tower Defense Progresivo&quot;,
      &quot;short_name&quot;: &quot;TD Progresivo&quot;,
      &quot;start_url&quot;: &quot;.&quot;,
      &quot;display&quot;: &quot;standalone&quot;,
      &quot;orientation&quot;: &quot;landscape&quot;,
      &quot;background_color&quot;: &quot;#000000&quot;,
      &quot;theme_color&quot;: &quot;#000000&quot;,
      &quot;icons&quot;: [
        { &quot;src&quot;: &quot;Assets/icon-png-tdp.png&quot;, &quot;sizes&quot;: &quot;192x192&quot;, &quot;type&quot;: &quot;image/png&quot;, &quot;purpose&quot;: &quot;any maskable&quot; },
        { &quot;src&quot;: &quot;Assets/icon-png-tdp.png&quot;, &quot;sizes&quot;: &quot;512x512&quot;, &quot;type&quot;: &quot;image/png&quot;, &quot;purpose&quot;: &quot;any maskable&quot; }
      ]
    }">

    <!-- BIBLIOTECA DE SONIDO AÑADIDA -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        :root {
            --primary-bg: #0a192f;
            --secondary-bg: #172a45;
            --border-color: #00aaff;
            --highlight-color: #64ffda;
            --text-color: #ccd6f6;
            --text-light: #8892b0;
        }

        /* --- TEMAS DE MAPAS --- */
        body.theme-classic {
            --primary-bg: #1E3A2B;
            --secondary-bg: #2A4B3A;
            --border-color: #58A67D;
            --highlight-color: #A6FFD5;
            --text-color: #E0F2E9;
            --text-light: #A2B5A9;
        }
        body.theme-serpentine {
            --primary-bg: #4D2C1C;
            --secondary-bg: #6B3F2A;
            --border-color: #FF7B25;
            --highlight-color: #FFE8C5;
            --text-color: #FFDAB9;
            --text-light: #D2B48C;
        }
        body.theme-crossroads {
            --primary-bg: #1A1A1A;
            --secondary-bg: #2C2C2C;
            --border-color: #D32F2F;
            --highlight-color: #F5F5F5;
            --text-color: #E0E0E0;
            --text-light: #9E9E9E;
        }
        body.theme-direct { /* Default Theme */
            --primary-bg: #0a192f;
            --secondary-bg: #172a45;
            --border-color: #00aaff;
            --highlight-color: #64ffda;
            --text-color: #ccd6f6;
            --text-light: #8892b0;
        }


        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #000;
            color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        #menu-background-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            display: none;
        }

        .screen {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 40px;
            border-radius: 10px;
            position: relative;
            transform-origin: center center;
            z-index: 1;
        }

        #main-menu-screen {
            display: flex;
            background-color: transparent;
            border: none;
        }
        
        #main-menu-screen h1 {
            margin: 0 0 20px 0;
            font-size: 3.5em;
            color: #fff;
            text-shadow: 
                0 0 5px #fff,
                0 0 10px #fff,
                0 0 20px #00aaff,
                0 0 30px #00aaff;
        }
        
        #map-selection-screen {
             background-color: var(--secondary-bg);
             border: 2px solid var(--border-color);
             box-shadow: 0 0 20px var(--border-color);
        }
        
        #map-selection-screen h1 {
             color: var(--highlight-color);
             text-shadow: 0 0 8px var(--highlight-color);
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 300px;
        }

        .menu-button {
            padding: 15px 30px;
            font-size: 1.5em;
            font-weight: bold;
            background: linear-gradient(145deg, #003366, #0059b3);
            border: 2px solid #66b3ff;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px #0077ff, 0 0 20px #0077ff, inset 0 0 5px rgba(255,255,255,0.5);
            text-shadow: 0 0 5px #fff;
        }
        #difficulty-modal .menu-button {
            background: #333;
            border: 1px solid #555;
            box-shadow: none;
        }
        #difficulty-modal .menu-button:hover {
            background-color: #00ff87;
            color: #1a1a1a;
            transform: scale(1.05);
        }

        .menu-button:hover:not(:disabled) {
            background: linear-gradient(145deg, #0059b3, #0077ff);
            transform: scale(1.05) translateY(-2px);
            box-shadow: 0 0 15px #00aaff, 0 0 30px #00aaff, inset 0 0 8px rgba(255,255,255,0.6);
        }

        .menu-button:disabled {
            background: #222;
            color: #555;
            cursor: not-allowed;
            box-shadow: none;
            border-color: #444;
        }

        .map-selection-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        .map-button {
            padding: 20px 40px;
            font-size: 1.2em;
            font-weight: bold;
            background-color: var(--primary-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .map-button:hover {
            background-color: var(--border-color);
            color: var(--primary-bg);
            transform: scale(1.05);
        }
        
        #game-ui-container {
            display: none;
            flex-direction: column;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 0 20px var(--border-color);
            background-color: var(--primary-bg);
            transform-origin: center center;
        }
        #top-bar {
            display: flex;
            flex-direction: column;
            padding: 5px 15px;
            background-color: var(--secondary-bg);
            border-bottom: 2px solid var(--border-color);
        }
        .top-bar-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        .ui-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .stat {
            font-size: 1.1em;
            font-weight: bold;
            color: var(--text-color);
            transition: color 0.3s ease, text-shadow 0.3s ease;
        }
        .stat-icon {
            font-size: 1.3em;
        }
        #gold-stat.gold-rush-active {
            color: #FFD700;
            text-shadow: 0 0 8px #FFD700;
        }
        #base-health-bar-container {
            width: 150px;
            height: 18px;
            background-color: rgba(0,0,0,0.3);
            border: 1px solid var(--text-light);
            border-radius: 9px;
            overflow: hidden;
        }
        #base-health-bar {
            height: 100%;
            background: linear-gradient(90deg, #f44336, #d32f2f);
            transition: width 0.3s ease;
        }
        .control-button, #wave-button, .ability-button, .modal-button, .side-panel-button {
            padding: 8px 12px;
            color: var(--text-color);
            border: 1px solid var(--text-light);
            border-radius: 5px;
            cursor: pointer;
            background-color: var(--secondary-bg);
            transition: all 0.3s;
            position: relative;
            font-size: 0.9em;
        }
        .control-button:hover, #wave-button:hover:not(:disabled), .ability-button:hover:not(:disabled), .modal-button:hover, .side-panel-button:hover {
            background-color: var(--border-color);
            color: var(--primary-bg);
            border-color: var(--border-color);
        }
        .side-panel-button {
             width: 100%;
        }
        #wave-button {
            background-color: #d32f2f;
            border-color: #f44336;
            font-weight: bold;
        }
        #wave-button:hover:not(:disabled) { background-color: #f44336; }
        #wave-button:disabled { background-color: #555; color: #888; cursor: not-allowed; border-color: #555;}
        
        .control-button.active {
            background-color: var(--highlight-color);
            color: var(--primary-bg);
            font-weight: bold;
            border-color: var(--highlight-color);
        }

        #side-panel {
            width: 240px;
            padding: 15px;
            background-color: var(--secondary-bg);
            border-left: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 15px; /* Reducido para nuevo botón */
            position: relative;
        }
        #game-explanation-bar p {
            margin: 0;
            font-size: 0.85em;
            color: var(--text-light);
            line-height: 1.4;
        }
        #game-explanation-bar p strong {
            color: var(--highlight-color);
        }

        /* --- ESTILOS DE MODALES --- */
        .modal {
            display: none; position: fixed; z-index: 1000;
            left: 0; top: 0; width: 100%; height: 100%;
            background-color: rgba(10, 25, 47, 0.85);
            justify-content: center; align-items: center;
        }
        .modal-content {
            background-color: var(--secondary-bg); padding: 30px;
            border-radius: 10px;
            text-align: center; color: var(--text-color);
            position: relative;
            transform-origin: center center;
            max-height: 90vh;
            overflow-y: auto;
            border: 2px solid var(--border-color);
            box-shadow: 0 0 25px var(--border-color);
        }
        .modal-content h2 { 
            margin-top: 0;
            text-shadow: 0 0 8px currentColor;
        }
        .game-over-content { border-color: #f44336; box-shadow: 0 0 25px #f44336;}
        .victory-content { border-color: var(--highlight-color); box-shadow: 0 0 25px var(--highlight-color);}
        .game-over-content h2 { color: #f44336; }
        .victory-content h2 { color: var(--highlight-color); }
        
        #arsenal-modal .modal-content { border-color: #00ff87; box-shadow: 0 0 25px #00ff87; }
        #bestiary-modal .modal-content { border-color: #C2185B; box-shadow: 0 0 25px #C2185B; }
        #powers-modal .modal-content { border-color: #FFC107; box-shadow: 0 0 25px #FFC107; }
        #dev-tools-modal .modal-content { border-color: #ff00ff; box-shadow: 0 0 25px #ff00ff; }
        #arsenal-modal h2 { color: #00ff87; }
        #bestiary-modal h2 { color: #C2185B; }
        #powers-modal h2 { color: #FFC107; }
        #dev-tools-modal h2 { color: #ff00ff; }

        .modal-close-button {
            position: absolute; top: 10px; right: 15px;
            font-size: 1.5em; color: #fff;
            background: none; border: none; cursor: pointer;
        }
        
        .info-card {
            background-color: var(--primary-bg);
            border: 1px solid var(--text-light);
            border-radius: 8px;
            padding: 15px;
            text-align: left;
        }
        
        /* --- NUEVOS ESTILOS BOTÓN SUERTE Y MENSAJE --- */
        #lucky-button {
            background-color: #FFC107;
            border-color: #FFA000;
            color: #1a1a1a;
            font-weight: bold;
        }
        #lucky-button:hover {
            background-color: #FFA000;
            color: #000;
        }
        #error-message-bar, #interest-message-bar {
            position: absolute;
            bottom: 10px;
            left: 15px;
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            font-weight: bold;
            text-align: center;
            width: calc(100% - 30px);
        }
        #error-message-bar {
            background-color: rgba(211, 47, 47, 0.9);
            color: white;
            border: 1px solid #f44336;
        }
        #interest-message-bar {
            background-color: rgba(100, 255, 218, 0.9);
            color: var(--primary-bg);
            border: 1px solid var(--highlight-color);
        }
        #error-message-bar.visible, #interest-message-bar.visible {
            opacity: 1;
        }
        /* --- FIN NUEVOS ESTILOS --- */

        /* --- OTROS ESTILOS --- */
        canvas { display: block; cursor: default; user-select: none; }
        #game-wrapper { position: relative; }
        #screen-flash, #gold-rush-effect { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; z-index: 999; pointer-events: none; }
        #screen-flash { background-color: red; }
        #gold-rush-effect { box-shadow: inset 0 0 25px 10px gold; border-radius: 8px; transition: opacity 0.5s ease-in-out; }
        #gold-rush-effect.active { opacity: 0.7; }
        #rotate-screen { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: #1a1a1a; color: #fff; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 2000; font-size: 1.5em; }
        #main-content { display: flex; }
        #arsenal-cards-container, #bestiary-cards-container, #powers-cards-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-top: 20px; margin-bottom: 20px; }
        .info-card.locked { background-color: #222; text-align: center; display: flex; justify-content: center; align-items: center; font-size: 4em; color: #444; }
        .info-card-header { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
        .info-card-header .visual { width: 50px; height: 50px; background-color: #444; border-radius: 5px; }
        .info-card-header h4 { margin: 0; font-size: 1.1em; }
        .info-card p { font-size: 0.9em; color: var(--text-light); margin: 5px 0; }
        .info-card .costs { font-size: 0.8em; color: #aaa; }
        #meteor-unlock-modal .modal-content, #tower-unlock-modal .modal-content, #tower-evolution-modal .modal-content, #mastery-unlock-modal .modal-content { border-color: #FFC107; box-shadow: 0 0 25px #FFC107; }
        #meteor-unlock-modal h2, #tower-unlock-modal h2, #tower-evolution-modal h2, #mastery-unlock-modal h2 { color: #FFC107; }
        .dont-show-again { margin-top: 20px; font-size: 0.9em; display: flex; align-items: center; justify-content: center; gap: 8px; }
        .button-wrapper { position: relative; }
        .button-flash { display: none; position: absolute; top: -5px; left: -5px; right: -5px; bottom: -5px; border-radius: 8px; animation: flash 1s infinite; z-index: -1; }
        #meteor-button-flash { box-shadow: 0 0 15px 5px #FFC107; }
        #arsenal-button-flash { box-shadow: 0 0 15px 5px #00796B; }
        .button-flash.flashing { display: block; }
        @keyframes flash { 0%, 100% { opacity: 0; } 50% { opacity: 1; } }
        
        #fullscreen-button {
            background-color: var(--highlight-color);
            border-color: var(--highlight-color);
            color: var(--primary-bg);
            font-weight: bold;
            display: none; /* CORRECCIÓN: Oculto por defecto */
        }
        #fullscreen-button:hover {
            opacity: 0.9;
            background-color: var(--border-color);
            border-color: var(--border-color);
            color: var(--primary-bg);
        }
        body.is-touch #fullscreen-button {
            display: block; /* CORRECCIÓN: Se muestra solo en dispositivos táctiles */
        }

        #fullscreen-helper { display: none; font-size: 0.75em; color: #aaa; text-align: center; margin-top: -15px; }
        body.is-iphone #fullscreen-helper { display: block; }
        
        #tutorial-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1001; pointer-events: none; }
        #tutorial-highlight { position: absolute; border: 3px dashed #FFD700; border-radius: 8px; box-shadow: 0 0 20px #FFD700; transition: all 0.3s ease; pointer-events: none; }
        #tutorial-message-box { position: absolute; background-color: rgba(0,0,0,0.85); color: white; padding: 12px; border-radius: 8px; border: 2px solid #FFD700; max-width: 240px; font-size: 0.9em; line-height: 1.4; pointer-events: all; transition: top 0.4s ease, left 0.4s ease; }
        .clickable { pointer-events: all !important; }
        #version-display { position: absolute; top: 15px; left: 15px; font-size: 0.9em; color: #888; }
        #dev-tools-button { display: none; background-color: #ff00ff; }
        #dev-tools-button:hover { background-color: #c000c0; }
        .dev-options { display: flex; flex-direction: column; gap: 15px; align-items: center; }
        .dev-options .modal-button { width: 200px; }
        .dev-options .modal-button.active { background-color: var(--highlight-color); color: var(--primary-bg); }
        #volume-control-container, #menu-volume-control { display: flex; align-items: center; gap: 10px; }
        #menu-volume-control { position: absolute; top: 20px; right: 20px; z-index: 2;}
        #volume-slider, #menu-volume-slider { -webkit-appearance: none; appearance: none; width: 100px; height: 8px; background: #555; border-radius: 4px; outline: none; cursor: pointer; transition: opacity .2s; }
        #volume-slider::-webkit-slider-thumb, #menu-volume-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: var(--highlight-color); border-radius: 50%; border: 2px solid var(--secondary-bg); cursor: pointer; }
        #volume-slider::-moz-range-thumb, #menu-volume-slider::-moz-range-thumb { width: 18px; height: 18px; background: var(--highlight-color); border-radius: 50%; border: 2px solid var(--secondary-bg); cursor: pointer; }
        .hidden { display: none; }
        @media (orientation: portrait) { #game-ui-container, #map-selection-screen, #game-over-modal, #victory-modal, #main-menu-screen { display: none !important; } #rotate-screen { display: flex; } }
    </style>
</head>
<body>
    <canvas id="menu-background-canvas"></canvas>

    <div id="rotate-screen">
        <p>Por favor, rota tu dispositivo para jugar.</p>
        <p>Juego diseñado para modo horizontal.</p>
    </div>

    <div id="main-menu-screen" class="screen">
        <div id="version-display">v2.6.5</div>
        <div id="menu-volume-control">
            <button id="menu-volume-button" class="control-button">🔊</button>
            <input type="range" id="menu-volume-slider" min="0" max="1" step="0.01" value="0.25" class="hidden">
        </div>
        <h1>Tower Defense Progresivo</h1>
        <div class="menu-buttons">
            <button id="play-button" class="menu-button">Jugar</button>
            <button id="difficulty-button" class="menu-button">Dificultad</button>
            <button id="tutorial-button" class="menu-button">Tutorial</button>
            <button id="exit-button" class="menu-button">Salir</button>
        </div>
    </div>

    <div id="map-selection-screen" class="screen">
        <h1>Selecciona un Mapa</h1>
        <div class="map-selection-buttons">
            <button class="map-button" data-map="classic">El Sendero Clásico</button>
            <button class="map-button" data-map="serpentine">Cañón Serpenteante</button>
            <button class="map-button" data-map="crossroads">Encrucijada Mortal</button>
            <button class="map-button" data-map="direct">Asalto Directo</button>
        </div>
    </div>

    <div id="game-ui-container">
        <div id="top-bar">
            <div class="top-bar-row">
                <div class="ui-group">
                    <span class="stat stat-icon">❤️</span>
                    <div id="base-health-bar-container"><div id="base-health-bar"></div></div>
                    <span id="base-health-stat" class="stat">100/100</span>
                </div>
                <div class="ui-group">
                     <span id="tower-count-stat" class="stat">Torres: 0/25</span>
                </div>
            </div>
            <div class="top-bar-row">
                 <div class="ui-group">
                    <span id="gold-stat" class="stat">  200</span>
                    <span id="diamonds-stat" class="stat">💎 5</span>
                </div>
                <div class="ui-group">
                    <h3 style="margin:0;">Oleada <span id="wave-number">0</span></h3>
                    <button id="wave-button">Iniciar</button>
                </div>
                <div class="ui-group">
                    <div class="button-wrapper">
                        <button id="meteor-button" class="ability-button">Meteorito<span class="gem-cost"></span></button>
                        <div id="meteor-button-flash" class="button-flash"></div>
                    </div>
                    <button id="gold-rush-button" class="ability-button">Fiebre Oro<span class="gem-cost"></span></button>
                    <button id="pause-button" class="control-button">Pausa</button>
                    <button id="speed-1x-button" class="control-button active">1x</button>
                    <button id="speed-2x-button" class="control-button">2x</button>
                    <button id="speed-5x-button" class="control-button">5x</button>
                    <div id="volume-control-container">
                        <button id="volume-button" class="control-button">🔊</button>
                        <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.5" class="hidden">
                    </div>
                </div>
            </div>
        </div>

        <div id="main-content">
            <div id="game-wrapper">
                <div id="screen-flash"></div>
                <div id="gold-rush-effect"></div>
                <canvas id="gameCanvas" width="800" height="520"></canvas>
            </div>

            <div id="side-panel">
                 <div class="button-wrapper">
                    <button id="arsenal-button" class="side-panel-button">Arsenal</button>
                    <div id="arsenal-button-flash" class="button-flash"></div>
                </div>
                <button id="bestiary-button" class="side-panel-button">Bestiario</button>
                <button id="powers-button" class="side-panel-button">Poderes</button>
                <button id="lucky-button" class="side-panel-button">¡Voy a tener suerte!</button>
                <button id="fullscreen-button" class="side-panel-button">Pantalla Completa</button>
                <button id="dev-tools-button" class="side-panel-button">Dev Tools</button>
                <button id="exit-to-menu-button" class="side-panel-button" style="background-color: #d32f2f; border-color: #f44336;">Salir al Menú</button>
                <div id="fullscreen-helper">(En iPhone, usa Compartir > Añadir a pantalla de inicio)</div>
                <div id="game-explanation-bar">
                    <p><strong>Objetivo:</strong> ¡Sobrevive a las oleadas! Construye y mejora torres para defender tu base.</p>
                </div>
                <div id="error-message-bar"></div>
                <div id="interest-message-bar"></div>
            </div>
        </div>
    </div>

    <!-- MODALES -->
    <div id="play-options-modal" class="modal">
        <div class="modal-content">
            <h2>Jugar</h2>
            <div class="menu-buttons">
                <button id="continue-button" class="menu-button">Continuar</button>
                <button id="new-game-button" class="menu-button">Nueva Partida</button>
            </div>
            <button class="modal-close-button" style="top: 15px; right: 20px;">&times;</button>
        </div>
    </div>

    <div id="difficulty-modal" class="modal">
        <div class="modal-content">
            <h2>Selecciona la Dificultad</h2>
            <div class="menu-buttons">
                <button class="menu-button difficulty-select-button" data-difficulty="easy">Fácil</button>
                <p style="font-size: 0.8em; color: #ccc;">Enemigos más débiles y lentos. Torres más baratas y más oro.</p>
                <button class="menu-button difficulty-select-button" data-difficulty="normal">Normal</button>
                <p style="font-size: 0.8em; color: #ccc;">La experiencia de juego balanceada.</p>
                <button class="menu-button difficulty-select-button" data-difficulty="hard">Difícil</button>
                <p style="font-size: 0.8em; color: #ccc;">Enemigos más fuertes y rápidos. Torres más caras y menos oro.</p>
            </div>
        </div>
    </div>

    <div id="tutorial-prompt-modal" class="modal">
        <div class="modal-content">
            <h2>¡Bienvenido!</h2>
            <p>Parece que es tu primera vez. ¿Te gustaría ver el tutorial primero?</p>
            <div class="dont-show-again">
                <input type="checkbox" id="hide-tutorial-prompt-checkbox">
                <label for="hide-tutorial-prompt-checkbox">No volver a mostrar</label>
            </div>
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
                <button id="play-tutorial-button" class="modal-button">Jugar Tutorial</button>
                <button id="skip-tutorial-button" class="modal-button">Saltar</button>
            </div>
        </div>
    </div>

    <div id="game-over-modal" class="modal">
        <div class="modal-content game-over-content">
            <h2>Fin del Juego</h2>
            <p>Tu base ha sido destruida.</p>
            <p>Alcanzaste la oleada <span id="final-wave-stat"></span>.</p>
            <button id="play-again-button" class="modal-button">Jugar de Nuevo</button>
        </div>
    </div>

    <div id="victory-modal" class="modal">
        <div class="modal-content victory-content">
            <h2>¡VICTORIA!</h2>
            <p>¡Has superado el desafío principal al completar la oleada 35!</p>
            <p>¿Te atreves a continuar en el modo infinito?</p>
            <button id="continue-endless-button" class="modal-button">Continuar (Modo Infinito)</button>
        </div>
    </div>

    <div id="arsenal-modal" class="modal">
        <div class="modal-content">
            <button id="close-arsenal-x" class="modal-close-button">&times;</button>
            <h2>Arsenal de Torres</h2>
            <div id="arsenal-cards-container"></div>
            <button id="close-arsenal-button" class="modal-button">Cerrar</button>
        </div>
    </div>

    <div id="bestiary-modal" class="modal">
        <div class="modal-content">
            <button id="close-bestiary-x" class="modal-close-button">&times;</button>
            <h2>Bestiario</h2>
            <div id="bestiary-cards-container"></div>
            <button id="close-bestiary-button" class="modal-button">Cerrar</button>
        </div>
    </div>

    <div id="powers-modal" class="modal">
        <div class="modal-content">
            <button id="close-powers-x" class="modal-close-button">&times;</button>
            <h2>Poderes Especiales</h2>
            <div id="powers-cards-container"></div>
            <button id="close-powers-button" class="modal-button">Cerrar</button>
        </div>
    </div>

    <div id="meteor-unlock-modal" class="modal">
        <div class="modal-content">
            <h2>¡Habilidad Desbloqueada!</h2>
            <p>¡Has alcanzado la oleada 6 y desbloqueado el <strong>Meteorito</strong>!</p>
            <p>Úsalo para infligir daño masivo en un área. ¡Ideal contra jefes y grupos grandes!</p>
            <div class="dont-show-again">
                <input type="checkbox" id="hide-meteor-checkbox">
                <label for="hide-tutorial-prompt-checkbox">No volver a mostrar</label>
            </div>
            <button id="close-meteor-unlock-button" class="modal-button" style="margin-top: 20px;">Entendido</button>
        </div>
    </div>

    <div id="tower-unlock-modal" class="modal">
        <div class="modal-content">
            <h2>¡Torre Desbloqueada!</h2>
            <p style="font-size: 4em; margin: 10px 0;" class="tower-unlock-emoji"></p>
            <p>¡Desbloqueaste la torre: <strong class="tower-unlock-name"></strong>!</p>
            <p class="tower-unlock-desc"></p>
            <p>¡Revisa el <strong>Arsenal de Torres</strong> para más detalles!</p>
            <button id="close-tower-unlock-button" class="modal-button" style="margin-top: 20px;">Entendido</button>
        </div>
    </div>

    <div id="tower-evolution-modal" class="modal">
        <div class="modal-content">
            <h2>¡Evolución Disponible!</h2>
            <p>Tu torre ha alcanzado su máximo potencial. ¡Elige una especialización!</p>
            <div id="evolution-options-container" style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
                <!-- Opciones de evolución se insertarán aquí -->
            </div>
             <p style="font-size: 0.9em; color: #ccc; margin-top: 20px;">Puedes ver los detalles de cada evolución en el <strong>Arsenal de Torres</strong>.</p>
            <button id="close-evolution-button" class="modal-button" style="margin-top: 20px;">Decidiré luego</button>
        </div>
    </div>

    <div id="dev-tools-modal" class="modal">
        <div class="modal-content">
             <button id="close-dev-tools-x" class="modal-close-button">&times;</button>
            <h2>Dev Tools</h2>
            <div class="dev-options">
                <button id="dev-resources" class="modal-button">Recursos Ilimitados</button>
                <button id="dev-health" class="modal-button">Vida Ilimitada</button>
                <button id="dev-cooldowns" class="modal-button">Sin Enfriamientos</button>
                <button id="dev-exit" class="modal-button" style="background-color: #f44336;">Salir Modo Developer</button>
            </div>
        </div>
    </div>
    
    <!-- NUEVO MODAL DE MAESTRÍA -->
    <div id="mastery-unlock-modal" class="modal">
        <div class="modal-content">
            <h2>🏆 ¡Maestría de Mapa Desbloqueada! 🏆</h2>
            <p>¡Has superado la oleada 40 y demostrado tu dominio!</p>
            <p>Has desbloqueado una mejora permanente:</p>
            <p id="mastery-unlock-desc" style="font-weight: bold; color: #00ff87; margin: 15px 0;"></p>
            <p>Esta mejora se aplicará en todas tus futuras partidas.</p>
            <button id="close-mastery-unlock-button" class="modal-button" style="margin-top: 20px;">¡Genial!</button>
        </div>
    </div>
    
    <!-- NUEVO MODAL DE MODO DIFÍCIL -->
    <div id="hard-mode-info-modal" class="modal">
        <div class="modal-content">
            <h2>¡Modo Difícil Activado!</h2>
            <p>En este modo, los enemigos son más fuertes, pero la estrategia lo es todo.</p>
            <p>Recibirás <strong>intereses</strong> sobre tu oro no gastado al final de cada oleada. ¡Ahorrar puede ser la clave de la victoria!</p>
            <ul style="list-style: none; padding: 0; text-align: left; margin: 15px auto; max-width: 250px;">
                <li>Oleada 1: <strong>50%</strong> de interés</li>
                <li>Oleada 2: <strong>25%</strong> de interés</li>
                <li>Oleada 3: <strong>10%</strong> de interés</li>
                <li>Oleada 4+: <strong>5%</strong> de interés</li>
            </ul>
            <div class="dont-show-again">
                <input type="checkbox" id="hide-hard-mode-info-checkbox">
                <label for="hide-hard-mode-info-checkbox">No volver a mostrar</label>
            </div>
            <button id="close-hard-mode-info-button" class="modal-button" style="margin-top: 20px;">¡Entendido!</button>
        </div>
    </div>

    <!-- Elementos del Tutorial Interactivo -->
    <div id="tutorial-overlay">
        <div id="tutorial-highlight"></div>
        <div id="tutorial-message-box">
            <p id="tutorial-message-text"></p>
            <button id="tutorial-next-step-button" class="modal-button" style="margin-top: 10px; display: none;">Entendido</button>
        </div>
    </div>
    
    <audio id="bgm" loop src="Music/BGM/battleThemeA.mp3"></audio>
    <audio id="menu-bgm" loop src="Music/BGM/silent-shadows-376165.mp3"></audio>


    <script>
        // --- CONFIGURACIÓN DEL JUEGO ---
        const TILE_SIZE = 40;
        const cheats = {
            unlimitedResources: false,
            unlimitedHealth: false,
            noCooldowns: false,
        };
        const DIFFICULTY_MODIFIERS = {
            easy: { enemyHealth: 0.6, enemySpeed: 0.6, towerCost: 0.5, startingGold: 2.0 },
            normal: { enemyHealth: 1.0, enemySpeed: 1.0, towerCost: 1.0, startingGold: 1.0 },
            hard: { enemyHealth: 1.4, enemySpeed: 1.4, towerCost: 1.5, startingGold: 0.81 }
        };
        const MAPS = {
            'classic': [ { x: 0, y: 5 }, { x: 3, y: 5 }, { x: 3, y: 2 }, { x: 8, y: 2 }, { x: 8, y: 12 }, { x: 13, y: 12 }, { x: 13, y: 7 }, { x: 20, y: 7 } ],
            'serpentine': [ { x: 0, y: 2 }, { x: 17, y: 2 }, { x: 17, y: 5 }, { x: 2, y: 5 }, { x: 2, y: 8 }, { x: 17, y: 8 }, { x: 17, y: 11 }, { x: 0, y: 11 } ],
            'crossroads': [ { x: 0, y: 7 }, { x: 4, y: 7 }, { x: 4, y: 2 }, { x: 15, y: 2 }, { x: 15, y: 7 }, { x: 10, y: 7 }, { x: 10, y: 12 }, { x: 15, y: 12 }, { x: 15, y: 7 }, { x: 20, y: 7 } ],
            'direct': [ { x: 0, y: 7 }, { x: 10, y: 7 }, { x: 10, y: 2 }, { x: 20, y: 2 } ]
        };
        // --- NUEVOS TEMAS DE MAPA ---
        const MAP_THEMES = {
            'classic': { path: '#a58e71', background: '#3a5943' }, // Sendero de tierra, fondo de bosque
            'serpentine': { path: '#e0ac69', background: '#b06533' }, // Arena de cañón, fondo de roca
            'crossroads': { path: '#4a4a4a', background: '#292929' }, // Camino de piedra oscuro, fondo ominoso
            'direct': { path: '#8c92ac', background: '#465069' }  // Asfalto/metal, fondo industrial
        };
        const AIR_PATHS = {
            'classic': [ { x: 0, y: 5 }, { x: 8, y: 5 }, { x: 8, y: 7 }, { x: 20, y: 7 } ],
            'serpentine': [ { x: 0, y: 2 }, { x: 10, y: 6 }, { x: 0, y: 11 } ],
            'crossroads': [ { x: 0, y: 7 }, { x: 10, y: 2 }, { x: 10, y: 12 }, { x: 20, y: 7 } ],
            'direct': [ { x: 0, y: 7 }, { x: 20, y: 2 } ]
        };
        const TOWER_TYPES = {
            'arrow': { 
                name: 'Flechas', emoji: '🏹', desc: 'Rápida y barata. La única defensa inicial contra enemigos aéreos.', cost: 50, damage: 15, range: 100, fireRate: 60, projectileSpeed: 6.7, color: '#8BC34A', projectileColor: '#CDDC39', unlockWave: 1, upgrade: { damage: 8, range: 10, fireRate: 5 }, canHitFlying: true,
                evolutions: {
                    level: 8,
                    paths: {
                        pathA: { name: 'Metralleta', emoji: '🎯', desc: 'Dispara ráfagas increíblemente rápidas a corto alcance.', damage: 19, range: 135, fireRate: 5, special: 'gatling' },
                        pathB: { name: 'Francotirador', emoji: '🔭', desc: 'Inflige daño masivo a un enorme alcance, pero muy lentamente. Prioriza enemigos de élite y su daño aumenta con cada oleada.', damage: 1013, range: 280, fireRate: 222, special: 'sniper', projectileSpeed: 15 }
                    }
                }
            },
            'cannon': { 
                name: 'Cañón', emoji: '💣', desc: 'Lenta pero poderosa. Su daño en área es ideal contra grupos de enemigos terrestres.', cost: 120, damage: 40, range: 80, fireRate: 120, projectileSpeed: 5.3, color: '#607D8B', projectileColor: '#212121', unlockWave: 3, splashRadius: 65, upgrade: { damage: 25, range: 5, splashRadius: 8, fireRate: 10 }, canHitFlying: false,
                evolutions: {
                    level: 8,
                    paths: {
                        pathA: { name: 'Bomba Singular', emoji: '🌀', desc: 'No daña, pero atrae a los enemigos cercanos a un solo punto.', damage: 5, fireRate: 180, splashRadius: 120, special: 'pull', projectileColor: '#AB47BC' },
                        pathB: { name: 'Bomba Disforme', emoji: '🌌', desc: 'No daña, pero teletransporta a los enemigos hacia atrás en el camino. Tiene 18 disparos por oleada.', damage: 0, splashRadius: 80, special: 'teleport', shotsPerWave: 18, projectileColor: '#5C6BC0' }
                    }
                }
            },
            'laser': {
                name: 'Láser', emoji: '⚡', desc: 'Defensa aérea fundamental. Dispara un haz de energía instantáneo a enemigos voladores.', cost: 80, damage: 100, range: 120, fireRate: 70, projectileSpeed: 50, color: '#F44336', projectileColor: '#FFCDD2', unlockWave: 4, upgrade: { damage: 35, range: 10, fireRate: 6 }, canHitFlying: true, canHitGround: false, projectileType: 'beam',
                evolutions: {
                    level: 8,
                    paths: {
                        pathA: { name: 'Torre Tesla', emoji: '🌩️', desc: 'Lanza un arco eléctrico que salta entre múltiples enemigos, aéreos y terrestres.', damage: 500, range: 175, fireRate: 78, special: 'tesla', canHitGround: true, chain: { targets: 5 }, evolutionCostMultiplier: 2 },
                        pathB: { name: 'Cañón de Plasma', emoji: '🔥', desc: 'Canaliza un rayo de plasma continuo sobre un enemigo aéreo, aumentando su daño con el tiempo. Prioriza a los jefes.', damage: 100, range: 200, fireRate: 10, special: 'plasma', projectileType: 'beam', rampUp: { damage: 200, maxStacks: 50 } }
                    }
                }
            },
            'acid': { name: 'Ácido', emoji: '🧪', desc: 'Aplica un veneno que daña con el tiempo. El daño del veneno escala con el daño de la torre.', cost: 100, damage: 12, range: 110, fireRate: 108, projectileSpeed: 6.7, color: '#7FFF00', projectileColor: '#ADFF2F', unlockWave: 6, acid: { multiplier: 0.08, duration: 180 }, upgrade: { damage: 6, acidMultiplier: 0.04, range: 10, fireRate: 7 }, canHitFlying: false },
            'ice': { name: 'Hielo', emoji: '❄️', desc: 'Aplica una ralentización en un área que se vuelve más potente con el daño. Mejorar el rango aumenta el área de efecto.', cost: 150, damage: 5, range: 120, fireRate: 90, projectileSpeed: 8, color: '#03A9F4', projectileColor: '#B3E5FC', unlockWave: 9, slow: { baseMultiplier: 0.6, damageScale: 0.002, maxSlow: 0.35, duration: 120 }, slowRadius: 15, upgrade: { damage: 5, range: 10, slowRadius: 10, fireRate: 8 }, canHitFlying: false }
        };
        const ENEMY_TYPES = {
            'standard': { name: 'Esbirro', desc: 'Unidad básica terrestre. Débil pero numerosa.', health: 1, speed: 1, value: 1, color: '#E53935', size: 0.8, baseDamage: 10, isFlying: false },
            'fast': { name: 'Corredor', desc: 'Rápido y pequeño. Difícil de acertar para torres lentas.', health: 0.7, speed: 1.8, value: 1.2, color: '#FDD835', size: 0.6, baseDamage: 10, isFlying: false },
            'flying': { name: 'Espectro', desc: 'Ignora el camino y vuela directo a la base. Solo algunas torres pueden atacarlo.', health: 0.8, speed: 1.2, value: 1.5, color: '#E0E0E0', size: 0.7, baseDamage: 15, isFlying: true },
            'healer': { name: 'Sanador', desc: 'Cura a los aliados cercanos. Se vuelve invulnerable por 3 segundos cada 5 segundos. ¡Una prioridad alta!', health: 1.2, speed: 0.8, value: 3, color: '#FF80AB', size: 0.9, baseDamage: 5, isFlying: false, healAmount: 0.1, healRadius: 80, healRate: 240 },
            'disabler': { name: 'Disruptor', desc: 'Desactiva temporalmente las torres cercanas y avanza rápidamente cada 8 segundos.', health: 1.5, speed: 0.9, value: 4, color: '#D500F9', size: 0.9, baseDamage: 5, isFlying: false, disableRadius: 100, disableDuration: 180, disableRate: 300 },
            'boss': { name: 'Jefe', desc: 'Extremadamente resistente y peligroso. ¡Prepárate bien!', health: 15, speed: 0.6, value: 20, color: '#6A1B9A', size: 1.5, baseDamage: 0.55, isFlying: false }
        };
        const ABILITIES = {
            meteor: { cost: 4, cooldown: (60 * 30) * 3, damage: (300 * 3.5) * 2, radius: 160 },
            goldRush: { cost: 2, cooldown: 60 * 45, duration: 60 * 8, multiplier: 2.8 }
        };
        const MASTERY_BONUSES = {
            'classic': {
                description: "Torres de Flechas infligen un 15% más de daño.",
                apply: (game) => {
                    game.towerTypes.arrow.damage *= 1.15;
                }
            },
            'serpentine': {
                description: "Empiezas con 100 de oro adicional.",
                apply: (game) => {
                    game.gold += 100;
                }
            },
            'crossroads': {
                description: "La base tiene 25 de vida máxima adicional.",
                apply: (game) => {
                    game.maxBaseHealth += 25;
                    game.baseHealth += 25;
                }
            },
            'direct': {
                description: "Los Cañones tienen un 10% más de radio de explosión.",
                apply: (game) => {
                    game.towerTypes.cannon.splashRadius *= 1.10;
                }
            }
        };

        class Game {
            constructor(canvas, mapId, savedData = null, isTutorial = false, difficulty = 'normal') {
                this.canvas = canvas; this.ctx = canvas.getContext('2d');
                this.width = canvas.width; this.height = canvas.height;
                this.mapId = mapId;
                this.theme = MAP_THEMES[this.mapId]; // Cargar el tema del mapa
                this.isTutorial = isTutorial;
                this.tutorialManager = null;
                this.grid = []; 
                this.path = MAPS[mapId].map(p => ({ x: p.x * TILE_SIZE, y: p.y * TILE_SIZE }));
                this.airPath = AIR_PATHS[mapId].map(p => ({ x: p.x * TILE_SIZE, y: p.y * TILE_SIZE }));
                this.towers = []; this.enemies = []; this.projectiles = []; this.effects = []; 
                this.waveNumber = 0; 
                this.diamonds = 5;
                this.baseHealth = 100; this.maxBaseHealth = 100;
                this.waveInProgress = false;
                this.isPaused = false; this.gameSpeed = 1;
                this.speedBeforePause = 1;
                this.activeAbility = null;
                this.meteorCooldown = 0; this.goldRushCooldown = 0; this.goldRushTimer = 0;
                this.activeMenu = { isOpen: false, type: null, x: 0, y: 0, options: [], target: null };
                this.gameWon = false;
                this.selectedTower = null;
                this.frameCount = 0;
                this.discoveredEnemies = new Set();
                this.showPathArrows = true; // Para el indicador de camino
                this.MAX_TOWERS = 25;
                this.towerCounts = { arrow: 0, cannon: 0, acid: 0, ice: 0, laser: 0 };
                this.unlockedTowers = new Set(['arrow']);

                this.difficulty = difficulty;
                const modifiers = DIFFICULTY_MODIFIERS[this.difficulty];
                this.gold = savedData ? savedData.gold : 200 * modifiers.startingGold;

                this.towerTypes = JSON.parse(JSON.stringify(TOWER_TYPES));
                this.applyMasteryBonuses();

                this.camera = { x: 0, y: 0, scale: 1 };
                this.mousePos = { x: 0, y: 0 };
                this.scale = 1;

                this.createGridAndPath();

                if (savedData && savedData.towers) {
                    this.loadState(savedData);
                }

                if (this.isTutorial) {
                    this.tutorialManager = new TutorialManager(this);
                }

                this.init();
            }

            init() {
                this.updateUI(); 
                this.gameLoop();
            }
            
            gameLoop() {
                if (!this.isPaused) for (let i = 0; i < this.gameSpeed; i++) this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }

            update() {
                if (this.isTutorial && this.tutorialManager.isPaused) return;

                this.frameCount++;
                const cdMultiplier = this.waveNumber >= 35 ? 0.25 : 1;
                if(this.meteorCooldown > 0) this.meteorCooldown--;
                if(this.goldRushCooldown > 0) this.goldRushCooldown--;
                if(this.goldRushTimer > 0) {
                    this.goldRushTimer--;
                    if (this.goldRushTimer === 0) {
                        document.getElementById('gold-rush-effect').classList.remove('active');
                        document.getElementById('gold-stat').classList.remove('gold-rush-active');
                    }
                }
                this.updateAbilityButtons();

                if (!this.waveInProgress) return;

                this.enemies.forEach(e => e.update(this.enemies, this.towers)); 
                this.towers.forEach(t => t.update(this.enemies));
                this.projectiles.forEach(p => p.update()); this.effects.forEach(e => e.update());

                this.enemies = this.enemies.filter(e => e.active); this.projectiles = this.projectiles.filter(p => p.active); this.effects = this.effects.filter(e => e.active);

                if (this.waveInProgress && this.enemies.length === 0) {
                    this.waveInProgress = false;
                    this.diamonds += this.waveNumber >= 35 ? 3 : 1.2;
                    
                    if (this.difficulty === 'hard') {
                        this.applyInterest();
                    }

                    if (this.isTutorial) {
                        this.tutorialManager.checkCondition('wave_cleared');
                    } else if (this.waveNumber === 35 && !this.gameWon) {
                        this.gameWon = true;
                        this.showVictoryScreen();
                    } else if (this.waveNumber === 40) {
                        this.unlockMastery();
                    }
                    else {
                        document.getElementById('wave-button').disabled = false;
                        this.pauseGame();
                    }
                    if (!this.isTutorial) this.saveState();
                    this.updateUI();
                }
            }

            draw() {
                // Dibujar fondo temático
                this.ctx.fillStyle = this.theme.background;
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                this.drawPath(); 
                this.drawGrid();

                if (this.showPathArrows) {
                    this.drawPathArrows();
                }
                
                if (this.selectedTower) {
                    this.ctx.save();
                    this.ctx.beginPath();
                    this.ctx.arc(this.selectedTower.x, this.selectedTower.y, this.selectedTower.typeInfo.range, 0, Math.PI * 2);
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    this.ctx.fill();
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    this.ctx.stroke();
                    this.ctx.restore();
                }

                this.towers.forEach(t => t.draw(this.ctx, this.frameCount)); 
                this.enemies.forEach(e => e.draw(this.ctx, this.frameCount));
                this.projectiles.forEach(p => p.draw(this.ctx)); 
                this.effects.forEach(e => e.draw(this.ctx));
                
                if (this.activeMenu.isOpen) this.drawMenu();
                
                if (this.activeAbility === 'meteor' && this.mousePos) {
                    const rect = this.canvas.getBoundingClientRect();
                    const canvasX = (this.mousePos.x - rect.left) / this.scale;
                    const canvasY = (this.mousePos.y - rect.top) / this.scale;

                    this.ctx.save();
                    this.ctx.beginPath(); this.ctx.arc(canvasX, canvasY, ABILITIES.meteor.radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = 'rgba(255, 0, 100, 0.3)'; this.ctx.fill();
                    this.ctx.restore();
                }
            }

            startWave() {
                if (this.waveInProgress) return;

                if (this.isTutorial) {
                    if (!this.tutorialManager.checkCondition('wave_started')) {
                        return; 
                    }
                } else {
                    this.resumeGame();
                }
                
                this.waveNumber++;
                this.maxBaseHealth += 10;
                this.baseHealth = Math.min(this.maxBaseHealth, this.baseHealth + 10);

                this.towers.forEach(t => {
                    if (t.typeInfo.shotsPerWave) {
                        t.shotsLeft = t.typeInfo.shotsPerWave;
                    }
                });

                for (const type in this.towerTypes) {
                    const towerInfo = this.towerTypes[type];
                    if (this.waveNumber === towerInfo.unlockWave && !this.unlockedTowers.has(type)) {
                        this.unlockedTowers.add(type);
                        this.showTowerUnlockModal(type);
                    }
                }


                if (this.waveNumber === 1) {
                    this.showPathArrows = false;
                }
                
                if (!this.isTutorial && this.waveNumber === 6 && !localStorage.getItem('hideMeteorUnlock')) {
                    this.showMeteorUnlockModal();
                }

                this.waveInProgress = true; document.getElementById('wave-button').disabled = true; 
                
                const waveConfig = this.isTutorial ? this.tutorialManager.getWaveConfig() : this.getWaveConfig(this.waveNumber);

                const baseHealth = 50 + this.waveNumber * 15; const baseValue = 10 + this.waveNumber * 2;
                waveConfig.forEach((conf, i) => {
                    this.discoveredEnemies.add(conf.type);
                    const spawnDelay = (conf.type === 'boss' && this.waveNumber >= 35) ? 180 : 60;
                    this.enemies.push(new Enemy(this, -i * spawnDelay, this.path[0].y, baseHealth, baseValue, conf));
                });
                this.updateUI();
            }
            
            showMeteorUnlockModal() {
                this.pauseGame();
                document.getElementById('meteor-unlock-modal').style.display = 'flex';
                const flashEl = document.getElementById('meteor-button-flash');
                flashEl.classList.add('flashing');
                setTimeout(() => {
                    flashEl.classList.remove('flashing');
                }, 5000);
            }

            showTowerUnlockModal(type) {
                this.pauseGame();
                const towerInfo = this.towerTypes[type];
                const modal = document.getElementById('tower-unlock-modal');
                modal.querySelector('.tower-unlock-emoji').textContent = towerInfo.emoji;
                modal.querySelector('.tower-unlock-name').textContent = towerInfo.name;
                modal.querySelector('.tower-unlock-desc').textContent = towerInfo.desc;
                modal.style.display = 'flex';

                const flashEl = document.getElementById('arsenal-button-flash');
                flashEl.classList.add('flashing');
                setTimeout(() => flashEl.classList.remove('flashing'), 5000);

                const closeButton = modal.querySelector('#close-tower-unlock-button');
                closeButton.onclick = () => {
                    modal.style.display = 'none';
                    if (!this.isTutorial) this.resumeGame();
                };
            }

            showEvolutionModal(tower) {
                this.pauseGame();
                const modal = document.getElementById('tower-evolution-modal');
                const container = document.getElementById('evolution-options-container');
                container.innerHTML = '';

                const evoInfo = tower.typeInfo.evolutions.paths;

                Object.keys(evoInfo).forEach(pathKey => {
                    const path = evoInfo[pathKey];
                    const evolutionCost = tower.upgradeCost * (path.evolutionCostMultiplier || 1);
                    const option = document.createElement('div');
                    option.className = 'info-card';
                    option.innerHTML = `
                        <div class="info-card-header">
                            <h4>${path.emoji} ${path.name}</h4>
                        </div>
                        <p>${path.desc}</p>
                        <button class="modal-button evolve-button" data-path="${pathKey}">Evolucionar (💰${evolutionCost})</button>
                    `;
                    container.appendChild(option);
                });
                
                modal.querySelectorAll('.evolve-button').forEach(button => {
                    button.onclick = (e) => {
                        const path = e.target.dataset.path;
                        tower.evolve(path);
                        modal.style.display = 'none';
                        if (!this.isTutorial) this.resumeGame();
                    };
                });

                document.getElementById('close-evolution-button').onclick = () => {
                     modal.style.display = 'none';
                     if (!this.isTutorial) this.resumeGame();
                };

                modal.style.display = 'flex';
                const flashEl = document.getElementById('arsenal-button-flash');
                flashEl.classList.add('flashing');
                setTimeout(() => flashEl.classList.remove('flashing'), 5000);
            }

            getWaveConfig(waveNum) {
                if (waveNum > 35) {
                    let numBosses;
                    if (waveNum <= 37) numBosses = 1;
                    else numBosses = 2 + Math.floor((waveNum - 38) / 3);
                    return Array(numBosses).fill({ type: 'boss', isFlying: true });
                }
                
                let config = [];
                if (waveNum > 0 && waveNum % 5 === 0) {
                    const isFlyingBoss = waveNum >= 15;
                    config.push({ type: 'boss', isFlying: isFlyingBoss });
                }

                const enemyCount = 5 + waveNum * 2;
                for (let i = 0; i < enemyCount; i++) {
                    let type = 'standard';
                    const rand = Math.random();
                    
                    const hardModeEarlySpawn = this.difficulty === 'hard' && waveNum >= 10;

                    if (hardModeEarlySpawn && rand < 0.15) type = 'disabler';
                    else if (hardModeEarlySpawn && rand < 0.30) type = 'healer';
                    else if (waveNum >= 20 && rand < 0.15) type = 'disabler';
                    else if (waveNum >= 15 && rand < 0.25) type = 'healer';
                    else if (waveNum >= 10 && rand < 0.35) type = 'flying';
                    else if (waveNum >= 2 && rand < 0.45) type = 'fast';
                    
                    config.push({ type });
                }
                return config;
            }
            
            togglePause() { 
                if (this.isTutorial) return;
                if (this.isPaused) {
                    this.resumeGame();
                } else {
                    this.pauseGame();
                }
            }
            pauseGame() { 
                if (!this.isPaused) {
                    this.speedBeforePause = this.gameSpeed;
                }
                this.isPaused = true; 
                document.getElementById('pause-button').textContent = 'Reanudar'; 
            }
            resumeGame() { 
                this.isPaused = false; 
                document.getElementById('pause-button').textContent = 'Pausa'; 
                this.setSpeed(this.speedBeforePause);
            }
            
            setSpeed(speed) { 
                if (this.isTutorial) return;
                this.gameSpeed = speed; 
                this.speedBeforePause = speed;
                document.getElementById('speed-1x-button').classList.toggle('active', speed === 1); 
                document.getElementById('speed-2x-button').classList.toggle('active', speed === 2);
                document.getElementById('speed-5x-button').classList.toggle('active', speed === 5);
            }

            activateMeteor() {
                if (this.activeAbility === 'meteor') {
                    this.activeAbility = null;
                    this.canvas.style.cursor = 'default';
                    return;
                }
                const canAfford = this.diamonds >= ABILITIES.meteor.cost || cheats.unlimitedResources;
                const isReady = this.meteorCooldown <= 0 || cheats.noCooldowns;

                if (canAfford && isReady) {
                    this.activeAbility = 'meteor';
                    this.canvas.style.cursor = 'crosshair';
                    this.closeMenu();
                }
            }
            triggerMeteor(x, y) {
                const baseDamage = ABILITIES.meteor.damage;
                const finalDamage = baseDamage * (1 + (this.waveNumber - 1) * 0.25);

                if (!cheats.unlimitedResources) {
                    this.diamonds -= ABILITIES.meteor.cost; 
                }
                if (!cheats.noCooldowns) {
                    this.meteorCooldown = ABILITIES.meteor.cooldown * (this.waveNumber >= 35 ? 0.25 : 1); 
                }
                this.activeAbility = null;
                this.canvas.style.cursor = 'default';
                this.effects.push(new MeteorEffect(this, x, y, ABILITIES.meteor.radius, finalDamage)); 
                this.updateUI();
            }
            activateGoldRush() {
                const canAfford = this.diamonds >= ABILITIES.goldRush.cost || cheats.unlimitedResources;
                const isReady = this.goldRushCooldown <= 0 || cheats.noCooldowns;

                if (canAfford && isReady) {
                    if (!cheats.unlimitedResources) {
                        this.diamonds -= ABILITIES.goldRush.cost;
                    }
                    if (!cheats.noCooldowns) {
                        this.goldRushCooldown = ABILITIES.goldRush.cooldown * (this.waveNumber >= 35 ? 0.25 : 1);
                    }
                    this.goldRushTimer = ABILITIES.goldRush.duration;
                    document.getElementById('gold-rush-effect').classList.add('active');
                    document.getElementById('gold-stat').classList.add('gold-rush-active');
                    this.updateUI();
                }
            }
            
            createGridAndPath() {
                const cols = this.width / TILE_SIZE;
                const rows = this.height / TILE_SIZE;
                for (let y = 0; y < rows; y++) {
                    this.grid[y] = [];
                    for (let x = 0; x < cols; x++) {
                        this.grid[y][x] = { buildable: false, x: x, y: y };
                    }
                }
                const buildDistance = 2;
                for (let i = 0; i < this.path.length - 1; i++) {
                    let startNode = this.path[i];
                    let endNode = this.path[i + 1];
                    let startX = Math.floor(startNode.x / TILE_SIZE);
                    let startY = Math.floor(startNode.y / TILE_SIZE);
                    let endX = Math.floor(endNode.x / TILE_SIZE);
                    let endY = Math.floor(endNode.y / TILE_SIZE);
                    if (startY === endY) {
                        for (let x = Math.min(startX, endX); x <= Math.max(startX, endX); x++) {
                            for (let d = 1; d <= buildDistance; d++) {
                                if (this.grid[startY - d] && this.grid[startY - d][x]) this.grid[startY - d][x].buildable = true;
                                if (this.grid[startY + d] && this.grid[startY + d][x]) this.grid[startY + d][x].buildable = true;
                            }
                        }
                    } else if (startX === endX) {
                        for (let y = Math.min(startY, endY); y <= Math.max(startY, endY); y++) {
                            for (let d = 1; d <= buildDistance; d++) {
                                if (this.grid[y] && this.grid[y][startX - d]) this.grid[y][startX - d].buildable = true;
                                if (this.grid[y] && this.grid[y][startX + d]) this.grid[y][startX + d].buildable = true;
                            }
                        }
                    }
                }
                for (let i = 0; i < this.path.length - 1; i++) {
                    let s = this.path[i], e = this.path[i+1];
                    let sX = Math.floor(s.x / TILE_SIZE), sY = Math.floor(s.y / TILE_SIZE);
                    let eX = Math.floor(e.x / TILE_SIZE), eY = Math.floor(e.y / TILE_SIZE);
                    for (let x = Math.min(sX, eX); x <= Math.max(sX, eX); x++) {
                        for (let y = Math.min(sY, eY); y <= Math.max(sY, eY); y++) {
                            if (this.grid[y] && this.grid[y][x]) this.grid[y][x].buildable = false;
                        }
                    }
                }
            }

            drawGrid() {
                this.ctx.save();
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                 for (let y = 0; y < this.grid.length; y++) {
                    for (let x = 0; x < this.grid[y].length; x++) {
                        if (this.grid[y][x].buildable) {
                           this.ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        }
                    }
                }
                this.ctx.restore();
            }
            
            drawPath() {
                this.ctx.save();
                this.ctx.fillStyle = this.theme.path;
                for (let i = 0; i < this.path.length - 1; i++) {
                    let s = this.path[i], e = this.path[i+1];
                    let sX = Math.floor(s.x / TILE_SIZE), sY = Math.floor(s.y / TILE_SIZE);
                    let eX = Math.floor(e.x / TILE_SIZE), eY = Math.floor(e.y / TILE_SIZE);
                    for (let x = Math.min(sX, eX); x <= Math.max(sX, eX); x++) {
                        for (let y = Math.min(sY, eY); y <= Math.max(sY, eY); y++) {
                            this.ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        }
                    }
                }
                this.ctx.restore();
            }

            drawPathArrows() {
                this.ctx.save();
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                const arrowSize = 10;
                const arrowSpacing = 50;

                for (let i = 0; i < this.path.length - 1; i++) {
                    const start = this.path[i];
                    const end = this.path[i+1];
                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const segmentLength = Math.hypot(dx, dy);
                    const angle = Math.atan2(dy, dx);
                    for (let dist = arrowSpacing / 2; dist < segmentLength; dist += arrowSpacing) {
                        const x = start.x + (dx / segmentLength) * dist + TILE_SIZE / 2;
                        const y = start.y + (dy / segmentLength) * dist + TILE_SIZE / 2;
                        this.ctx.save();
                        this.ctx.translate(x, y);
                        this.ctx.rotate(angle);
                        this.ctx.beginPath();
                        this.ctx.moveTo(-arrowSize, -arrowSize / 2);
                        this.ctx.lineTo(0, 0);
                        this.ctx.lineTo(-arrowSize, arrowSize / 2);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.restore();
                    }
                }
                this.ctx.restore();
            }
            
            canBuildAt(gX, gY) { return this.grid[gY] && this.grid[gY][gX] && this.grid[gY][gX].buildable; }

            handleCanvasClick(x, y) {
                if (this.isTutorial && this.tutorialManager.handleInput('canvas_click', { x, y })) {
                    const gX = Math.floor(x / TILE_SIZE);
                    const gY = Math.floor(y / TILE_SIZE);
                    if (this.canBuildAt(gX, gY)) { this.openBuildMenu(gX, gY); }
                    return; 
                }
                
                if (this.activeAbility === 'meteor') { this.triggerMeteor(x, y); return; }
                if (this.activeMenu.isOpen) {
                    const clickedOnMenu = this.activeMenu.options.some(option => {
                        const dx = x - option.x; const dy = y - option.y;
                        if (dx * dx + dy * dy < option.radius * option.radius) {
                            option.action(); this.closeMenu(); return true;
                        }
                        return false;
                    });
                    if (clickedOnMenu) return;
                }
                
                const gX = Math.floor(x / TILE_SIZE);
                const gY = Math.floor(y / TILE_SIZE);
                const clickedTower = this.towers.find(t => t.gridX === gX && t.gridY === gY);

                if (clickedTower) {
                    if (this.selectedTower === clickedTower) { this.closeMenu(); } 
                    else { this.selectedTower = clickedTower; this.openUpgradeMenu(clickedTower); }
                } else if (this.canBuildAt(gX, gY)) {
                    if (this.activeMenu.isOpen && this.activeMenu.type === 'build' && this.activeMenu.target.gridX === gX && this.activeMenu.target.gridY === gY) {
                         this.closeMenu();
                    } else {
                        this.closeMenu();
                        this.openBuildMenu(gX, gY);
                    }
                } else {
                    this.closeMenu();
                }
            }
            
            enemyDefeated(enemy) {
                const goldGain = Math.floor(enemy.value * (this.goldRushTimer > 0 ? ABILITIES.goldRush.multiplier : 1) * 0.94);
                this.gold += goldGain;
                const isElite = ['boss', 'healer', 'disabler'].includes(enemy.type);
                this.baseHealth = Math.min(this.maxBaseHealth, this.baseHealth + (isElite ? 6 : 1));
                this.updateUI();
            }
            
            damageBase(amount) {
                if (cheats.unlimitedHealth) return;
                this.baseHealth -= amount; this.updateUI();
                if (this.baseHealth <= 0) this.gameOver();
            }

            gameOver() {
                if (this.isTutorial) { this.tutorialManager.end(); return; }
                this.isPaused = true; this.waveInProgress = false;
                document.getElementById('final-wave-stat').textContent = this.waveNumber; document.getElementById('game-over-modal').style.display = 'flex';
            }

            showVictoryScreen() {
                this.isPaused = true;
                document.getElementById('victory-modal').style.display = 'flex';
            }
            
            continueEndlessMode() {
                document.getElementById('victory-modal').style.display = 'none';
                document.getElementById('wave-button').disabled = false;
                this.pauseGame();
            }

            updateUI() {
                document.getElementById('gold-stat').textContent = `💰 ${Math.floor(this.gold)}`;
                document.getElementById('diamonds-stat').textContent = `💎 ${Math.floor(this.diamonds)}`;
                document.getElementById('base-health-stat').textContent = `${Math.max(0, Math.ceil(this.baseHealth))}/${this.maxBaseHealth}`;
                document.getElementById('base-health-bar').style.width = `${(this.baseHealth / this.maxBaseHealth) * 100}%`;
                document.getElementById('wave-number').textContent = this.waveNumber;
                document.getElementById('tower-count-stat').textContent = `Torres: ${this.towers.length}/${this.MAX_TOWERS}`;
            }

            updateAbilityButtons() {
                const meteorBtn = document.getElementById('meteor-button'); 
                const goldRushBtn = document.getElementById('gold-rush-button');
                meteorBtn.parentElement.style.display = this.waveNumber >= 6 || this.isTutorial ? 'block' : 'none';
                meteorBtn.querySelector('.gem-cost').textContent = `(💎 ${ABILITIES.meteor.cost})`;
                goldRushBtn.querySelector('.gem-cost').textContent = `(💎 ${ABILITIES.goldRush.cost})`;
                if (cheats.noCooldowns) { this.meteorCooldown = 0; this.goldRushCooldown = 0; }
                this.updateButtonCooldown(meteorBtn, this.meteorCooldown); 
                this.updateButtonCooldown(goldRushBtn, this.goldRushCooldown);
                meteorBtn.disabled = this.diamonds < ABILITIES.meteor.cost || this.meteorCooldown > 0;
                goldRushBtn.disabled = this.diamonds < ABILITIES.goldRush.cost || this.goldRushCooldown > 0;
            }

            updateButtonCooldown(button, currentCD) {
                let cdText = button.querySelector('.cooldown-text');
                if (currentCD > 0) {
                    if (!cdText) { cdText = document.createElement('span'); cdText.className = 'cooldown-text'; button.appendChild(cdText); }
                    cdText.textContent = Math.ceil(currentCD / 60);
                } else if (cdText) { button.removeChild(cdText); }
            }

            openBuildMenu(gridX, gridY) {
                this.selectedTower = null;
                let menuX = gridX * TILE_SIZE + TILE_SIZE / 2; 
                let menuY = gridY * TILE_SIZE + TILE_SIZE / 2;
                const menuRadius = 70;
                if (menuX - menuRadius < 0) menuX = menuRadius;
                if (menuX + menuRadius > this.width) menuX = this.width - menuRadius;
                if (menuY - menuRadius < 0) menuY = menuRadius;
                if (menuY + menuRadius > this.height) menuY = this.height - menuRadius;
                const options = [];
                let angle = -Math.PI / 2;
                const availableTowers = Object.keys(this.towerTypes).filter(type => this.unlockedTowers.has(type));
                const angleStep = (Math.PI * 2) / availableTowers.length;
                const modifiers = DIFFICULTY_MODIFIERS[this.difficulty];
                for (const type of availableTowers) {
                    const towerInfo = this.towerTypes[type];
                    const baseCost = towerInfo.cost * modifiers.towerCost;
                    const currentCost = Math.floor(baseCost * (1.15 ** this.towerCounts[type]));
                    options.push({
                        x: menuX + Math.cos(angle) * 50, y: menuY + Math.sin(angle) * 50, radius: 20,
                        label: towerInfo.name, cost: currentCost, color: towerInfo.color,
                        action: () => this.buildTower(gridX, gridY, type)
                    });
                    angle += angleStep;
                }
                this.activeMenu = { isOpen: true, type: 'build', x: menuX, y: menuY, options, target: {gridX, gridY} };
                if (this.isTutorial) this.tutorialManager.checkCondition('build_menu_opened');
            }

            openUpgradeMenu(tower) {
                let menuX = tower.x; let menuY = tower.y;
                const menuRadius = 70;
                if (menuY - menuRadius < 0) menuY = menuRadius;
                if (menuY + menuRadius > this.height) menuY = this.height - menuRadius;
                if (tower.upgradeCount >= tower.MAX_UPGRADES && !tower.isEvolved && tower.typeInfo.evolutions) {
                    this.showEvolutionModal(tower);
                    return;
                }
                const upgradeOption = {
                    x: menuX, y: menuY - 50, radius: 20, label: 'Mejorar',
                    cost: tower.upgradeCost,
                    color: tower.upgradeCount >= tower.MAX_UPGRADES ? '#555' : '#FFC107',
                    action: () => { if (tower.upgradeCount < tower.MAX_UPGRADES) { this.upgradeTower(tower); } }
                };
                const options = [ upgradeOption, { x: menuX, y: menuY + 50, radius: 20, label: 'Vender', cost: Math.floor(tower.totalInvestedGold * 0.7), color: '#4CAF50', action: () => this.sellTower(tower) }];
                this.activeMenu = { isOpen: true, type: 'upgrade', x: menuX, y: menuY, options, target: tower };
                if (this.isTutorial) this.tutorialManager.checkCondition('upgrade_menu_opened');
            }
            
            closeMenu() { 
                this.activeMenu.isOpen = false; this.activeMenu.type = null;
                this.activeMenu.target = null; this.selectedTower = null;
                this.canvas.style.cursor = 'default';
            }

            drawMenu() {
                this.ctx.save();
                this.ctx.font = 'bold 12px Segoe UI'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle';
                this.activeMenu.options.forEach(opt => {
                    this.ctx.beginPath(); this.ctx.arc(opt.x, opt.y, opt.radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = opt.color; this.ctx.globalAlpha = 0.8; this.ctx.fill(); this.ctx.globalAlpha = 1;
                    this.ctx.strokeStyle = 'white'; this.ctx.stroke();
                    this.ctx.fillStyle = 'white';
                    this.ctx.fillText(opt.label, opt.x, opt.y - 8);
                    if (opt.label === 'Mejorar' && this.activeMenu.target.upgradeCount >= this.activeMenu.target.MAX_UPGRADES) {
                        this.ctx.font = 'bold 14px Segoe UI';
                        this.ctx.fillText('MAX', opt.x, opt.y + 8);
                        this.ctx.font = 'bold 12px Segoe UI';
                    } else {
                        this.ctx.fillText(`💰 ${opt.cost}`, opt.x, opt.y + 8);
                    }
                });
                this.ctx.restore();
            }

            buildTower(gridX, gridY, type) {
                if (this.towers.length >= this.MAX_TOWERS) { return; }
                const modifiers = DIFFICULTY_MODIFIERS[this.difficulty];
                const towerInfo = this.towerTypes[type];
                const baseCost = towerInfo.cost * modifiers.towerCost;
                const currentCost = Math.floor(baseCost * (1.15 ** this.towerCounts[type]));
                if (this.gold >= currentCost || cheats.unlimitedResources) {
                    if (!cheats.unlimitedResources) { this.gold -= currentCost; }
                    this.towers.push(new Tower(this, gridX, gridY, type));
                    this.towerCounts[type]++;
                    this.grid[gridY][gridX].buildable = false; 
                    this.updateUI();
                    if (this.isTutorial) this.tutorialManager.checkCondition('tower_built', { type: type });
                }
            }

            upgradeTower(tower) {
                if ((this.gold >= tower.upgradeCost || cheats.unlimitedResources) && tower.upgradeCount < tower.MAX_UPGRADES) { 
                    if (!cheats.unlimitedResources) { this.gold -= tower.upgradeCost; } 
                    tower.upgrade(); 
                    this.updateUI(); 
                }
            }

            sellTower(tower) {
                this.gold += Math.floor(tower.totalInvestedGold * 0.7);
                this.grid[tower.gridY][tower.gridX].buildable = true;
                this.towerCounts[tower.typeKey]--;
                this.towers = this.towers.filter(t => t !== tower); 
                this.updateUI();
            }
            
            // --- NUEVA FUNCIÓN "VOY A TENER SUERTE" ---
            feelingLucky() {
                const upgradableTowers = this.towers.filter(t => 
                    (t.upgradeCount < t.MAX_UPGRADES || (!t.isEvolved && t.typeInfo.evolutions)) && this.gold >= t.upgradeCost
                );

                if (upgradableTowers.length === 0) {
                    this.showError(this.towers.length > 0 ? "No tienes suficiente oro para mejorar." : "No hay torres para mejorar.");
                    return;
                }

                let randomTower = upgradableTowers[Math.floor(Math.random() * upgradableTowers.length)];

                while (this.gold >= randomTower.upgradeCost) {
                    if (randomTower.upgradeCount < randomTower.MAX_UPGRADES) {
                        this.upgradeTower(randomTower);
                    } else if (!randomTower.isEvolved && randomTower.typeInfo.evolutions) {
                        const evoPaths = Object.keys(randomTower.typeInfo.evolutions.paths);
                        const randomPath = evoPaths[Math.floor(Math.random() * evoPaths.length)];
                        const evolutionCost = randomTower.upgradeCost * (randomTower.typeInfo.evolutions.paths[randomPath].evolutionCostMultiplier || 1);
                        
                        if (this.gold >= evolutionCost) {
                            randomTower.evolve(randomPath);
                        }
                        break; // Salir del bucle después de intentar evolucionar
                    } else {
                        break; // La torre está completamente mejorada
                    }
                }
            }

            showError(message) {
                const errorBar = document.getElementById('error-message-bar');
                errorBar.textContent = message;
                errorBar.classList.add('visible');
                setTimeout(() => {
                    errorBar.classList.remove('visible');
                }, 3000);
            }

            applyInterest() {
                if (this.gold <= 0) return;

                let interestRate = 0;
                if (this.waveNumber === 1) {
                    interestRate = 0.50;
                } else if (this.waveNumber === 2) {
                    interestRate = 0.25;
                } else if (this.waveNumber === 3) {
                    interestRate = 0.10;
                } else if (this.waveNumber >= 4) {
                    interestRate = 0.05;
                }

                if (interestRate > 0) {
                    const interestGained = Math.floor(this.gold * interestRate);
                    this.gold += interestGained;
                    this.showInterestMessage(interestGained);
                }
            }

            showInterestMessage(amount) {
                if (amount <= 0) return;
                const interestBar = document.getElementById('interest-message-bar');
                interestBar.textContent = `+${amount} de oro por intereses`;
                interestBar.classList.add('visible');
                setTimeout(() => {
                    interestBar.classList.remove('visible');
                }, 4000);
            }


            saveState() {
                const simplifiedTowers = this.towers.map(t => ({
                    gridX: t.gridX, gridY: t.gridY, typeKey: t.typeKey, upgradeCount: t.upgradeCount,
                    totalInvestedGold: t.totalInvestedGold, isEvolved: t.isEvolved,
                    typeInfo: t.typeInfo, upgradeCost: t.upgradeCost
                }));
                const state = {
                    mapId: this.mapId, waveNumber: this.waveNumber, gold: this.gold, diamonds: this.diamonds,
                    baseHealth: this.baseHealth, maxBaseHealth: this.maxBaseHealth,
                    discoveredEnemies: Array.from(this.discoveredEnemies), towerCounts: this.towerCounts,
                    unlockedTowers: Array.from(this.unlockedTowers), difficulty: this.difficulty,
                    towers: simplifiedTowers
                };
                localStorage.setItem('towerDefenseProgress', JSON.stringify(state));
            }

            loadState(savedData) {
                this.mapId = savedData.mapId;
                this.waveNumber = savedData.waveNumber;
                this.gold = savedData.gold;
                this.diamonds = savedData.diamonds;
                this.baseHealth = savedData.baseHealth;
                this.maxBaseHealth = savedData.maxBaseHealth;
                this.discoveredEnemies = new Set(savedData.discoveredEnemies);
                this.towerCounts = savedData.towerCounts || { arrow: 0, cannon: 0, acid: 0, ice: 0, laser: 0 };
                this.difficulty = savedData.difficulty || 'normal';
                if (savedData.unlockedTowers) {
                    this.unlockedTowers = new Set(savedData.unlockedTowers);
                } else {
                    this.unlockedTowers = new Set(['arrow']);
                    for (const type in this.towerTypes) {
                        if (this.waveNumber >= this.towerTypes[type].unlockWave) {
                            this.unlockedTowers.add(type);
                        }
                    }
                }
                this.towers = savedData.towers.map(tData => {
                    const tower = new Tower(this, tData.gridX, tData.gridY, tData.typeKey);
                    tower.upgradeCount = tData.upgradeCount;
                    tower.totalInvestedGold = tData.totalInvestedGold;
                    if (tData.isEvolved) {
                        tower.isEvolved = tData.isEvolved;
                        tower.typeInfo = tData.typeInfo;
                        tower.upgradeCost = tData.upgradeCost;
                    } else {
                        for(let i = 0; i < tower.upgradeCount; i++) {
                            tower.applyUpgradeStats();
                            tower.upgradeCost = Math.floor(tower.upgradeCost * 1.7);
                        }
                    }
                    this.grid[tData.gridY][tData.gridX].buildable = false;
                    return tower;
                });
            }

            applyMasteryBonuses() {
                const unlocked = JSON.parse(localStorage.getItem('unlockedMasteries')) || [];
                unlocked.forEach(mapId => {
                    if (MASTERY_BONUSES[mapId] && MASTERY_BONUSES[mapId].apply) {
                        MASTERY_BONUSES[mapId].apply(this);
                    }
                });
            }

            unlockMastery() {
                const unlocked = JSON.parse(localStorage.getItem('unlockedMasteries')) || [];
                if (unlocked.includes(this.mapId)) { return; }
                const mastery = MASTERY_BONUSES[this.mapId];
                if (mastery) {
                    this.showMasteryUnlockModal(mastery);
                    this.saveMastery(this.mapId);
                }
            }

            showMasteryUnlockModal(mastery) {
                this.pauseGame();
                document.getElementById('mastery-unlock-desc').textContent = mastery.description;
                document.getElementById('mastery-unlock-modal').style.display = 'flex';
            }

            saveMastery(mapId) {
                const unlocked = JSON.parse(localStorage.getItem('unlockedMasteries')) || [];
                if (!unlocked.includes(mapId)) {
                    unlocked.push(mapId);
                    localStorage.setItem('unlockedMasteries', JSON.stringify(unlocked));
                }
            }
        }

        class Enemy {
            constructor(game, x, y, baseHealth, baseValue, config) {
                this.game = game; this.x = x; this.y = y;
                this.type = config.type;
                const typeData = ENEMY_TYPES[this.type];
                const baseModifiers = DIFFICULTY_MODIFIERS[game.difficulty];

                let finalHealthMod = baseModifiers.enemyHealth;
                let finalSpeedMod = baseModifiers.enemySpeed;

                // Lógica de dificultad progresiva
                if (game.difficulty === 'hard') {
                    if (game.waveNumber === 1) { finalHealthMod = 1.1; finalSpeedMod = 1.1; }
                    else if (game.waveNumber === 2) { finalHealthMod = 1.2; finalSpeedMod = 1.2; }
                    else if (game.waveNumber === 3) { finalHealthMod = 1.3; finalSpeedMod = 1.3; }
                }

                let waveSpeedMultiplier = 1 + game.waveNumber * 0.05;
                let waveHealthMultiplier = 1 + (game.waveNumber * 0.075);

                if (game.waveNumber <= 5 && game.difficulty !== 'hard') {
                    waveHealthMultiplier *= 0.7;
                    waveSpeedMultiplier *= 0.85;
                }

                this.isFlying = config.isFlying || typeData.isFlying;
                this.speed = typeData.speed * waveSpeedMultiplier * finalSpeedMod;
                this.maxHealth = Math.floor(baseHealth * typeData.health * waveHealthMultiplier * finalHealthMod);
                
                if (['boss', 'healer', 'disabler'].includes(this.type)) { this.maxHealth *= 2; }

                this.health = this.maxHealth;
                this.value = Math.floor(baseValue * typeData.value);
                let damageToDeal = typeData.baseDamage;

                if (config.isTutorial) { this.health *= 0.5; this.maxHealth *= 0.5; this.value *= 3; damageToDeal = 20; }

                this.baseDamage = damageToDeal;
                this.width = TILE_SIZE * typeData.size; this.height = TILE_SIZE * typeData.size;
                this.color = typeData.color;
                this.pathIndex = 0; this.active = true; this.damagingTowers = new Set();
                this.effects = new Map();
                if (this.type === 'healer') {
                    this.abilityCooldown = 0; this.isInvulnerable = true;
                    this.invulnerabilityTimer = 180; this.invulnerabilityCooldown = 300;
                    const healAmountBase = typeData.healAmount;
                    this.healAmount = game.difficulty === 'hard' ? healAmountBase * 1.65 : healAmountBase * 1.45;
                }
                if (this.type === 'disabler') { this.dashCooldown = 480; }
            }
            update(allEnemies, allTowers) {
                if (!this.active) return;
                if (this.type === 'healer') {
                    if (this.invulnerabilityTimer > 0) {
                        this.invulnerabilityTimer--;
                        if (this.invulnerabilityTimer <= 0) { this.isInvulnerable = false; this.abilityCooldown = this.invulnerabilityCooldown; }
                    } else if (this.abilityCooldown > 0) {
                        this.abilityCooldown--;
                        if (this.abilityCooldown <= 0) { this.isInvulnerable = true; this.invulnerabilityTimer = 180; }
                    }
                }
                if (this.type === 'disabler') {
                    this.dashCooldown--;
                    if (this.dashCooldown <= 0) {
                        this.pathIndex = Math.min(this.pathIndex + 2, this.game.path.length - 1);
                        const newPos = this.game.path[this.pathIndex];
                        if(newPos) { this.x = newPos.x; this.y = newPos.y + TILE_SIZE / 2; }
                        this.dashCooldown = 480;
                    }
                }
                let currentSpeedMultiplier = 1;
                const effectsToRemove = [];
                for (const [type, effect] of this.effects.entries()) {
                    effect.duration--;
                    if (type === 'acid') { this.takeDamage(effect.damagePerTick, null); }
                    if (type === 'slow') { currentSpeedMultiplier = Math.min(currentSpeedMultiplier, effect.multiplier); }
                    if (effect.duration <= 0) { effectsToRemove.push(type); }
                }
                effectsToRemove.forEach(type => this.effects.delete(type));
                if (this.type === 'healer') {
                    this.abilityCooldown--;
                    if (this.abilityCooldown <= 0) {
                        const typeData = ENEMY_TYPES.healer;
                        this.game.effects.push(new Effect(this.game, this.x, this.y, typeData.healRadius, 'rgba(255, 128, 171, 0.3)', 15));
                        allEnemies.forEach(e => {
                            if (e !== this && e.active) {
                                const dist = Math.hypot(this.x - e.x, this.y - e.y);
                                if (dist < typeData.healRadius) { e.health = Math.min(e.maxHealth, e.health + (e.maxHealth * this.healAmount)); }
                            }
                        });
                        this.abilityCooldown = typeData.healRate;
                    }
                }
                if (this.type === 'disabler') {
                    this.abilityCooldown--;
                    if (this.abilityCooldown <= 0) {
                        const typeData = ENEMY_TYPES.disabler;
                        this.game.effects.push(new Effect(this.game, this.x, this.y, typeData.disableRadius, 'rgba(213, 0, 249, 0.3)', 15));
                        allTowers.forEach(t => {
                            const dist = Math.hypot(this.x - t.x, this.y - t.y);
                            if (dist < typeData.disableRadius) { t.disabledTimer = typeData.disableDuration; }
                        });
                        this.abilityCooldown = typeData.disableRate;
                    }
                }
                const currentPath = this.isFlying ? this.game.airPath : this.game.path;
                const targetPoint = currentPath[this.pathIndex]; 
                if (!targetPoint) return;
                const dx = targetPoint.x - this.x, dy = targetPoint.y + TILE_SIZE / 2 - this.y; const dist = Math.sqrt(dx * dx + dy * dy);
                const currentSpeed = this.speed * currentSpeedMultiplier;
                if (dist < currentSpeed) {
                    this.pathIndex++;
                    if (this.pathIndex >= currentPath.length) {
                        this.active = false;
                        let finalDamage = this.baseDamage;
                        if (finalDamage < 1) finalDamage = Math.floor(this.game.maxBaseHealth * finalDamage);
                        this.game.damageBase(finalDamage); return;
                    }
                } else { this.x += (dx / dist) * currentSpeed; this.y += (dy / dist) * currentSpeed; }
            }
            draw(ctx, frameCount) {
                ctx.save();
                if (this.isFlying) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(this.x, this.y + this.height / 2 + 5, this.width / 2, this.width / 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.fillStyle = this.color; 
                if (this.isInvulnerable) { ctx.globalAlpha = 0.5 + 0.5 * Math.sin(frameCount * 0.3); }
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                ctx.globalAlpha = 1;
                if (this.effects.size > 0) {
                    const firstEffectType = this.effects.keys().next().value;
                    let flashColor = '';
                    if (firstEffectType === 'acid') flashColor = 'rgba(127, 255, 0, 0.7)';
                    if (firstEffectType === 'slow') flashColor = 'rgba(100, 181, 246, 0.7)';
                    if (flashColor && frameCount % 20 < 10) { ctx.fillStyle = flashColor; ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height); }
                }
                if (this.type === 'healer') {
                    ctx.strokeStyle = '#f44336'; ctx.lineWidth = 3; const crossSize = this.width / 4;
                    ctx.beginPath(); ctx.moveTo(this.x, this.y - crossSize); ctx.lineTo(this.x, this.y + crossSize); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(this.x - crossSize, this.y); ctx.lineTo(this.x + crossSize, this.y); ctx.stroke();
                }
                if (this.type === 'disabler' && frameCount % 4 < 2) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; ctx.lineWidth = 1;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(this.x - this.width/2 + Math.random() * this.width, this.y - this.height/2 + Math.random() * this.height);
                        ctx.lineTo(this.x - this.width/2 + Math.random() * this.width, this.y - this.height/2 + Math.random() * this.height);
                        ctx.stroke();
                    }
                }
                const hbW = this.width, hbH = 5; ctx.fillStyle = '#333'; ctx.fillRect(this.x - hbW / 2, this.y - this.height / 2 - 10, hbW, hbH);
                ctx.fillStyle = '#76FF03'; ctx.fillRect(this.x - hbW / 2, this.y - this.height / 2 - 10, hbW * (this.health / this.maxHealth), hbH);
                ctx.restore();
            }
            takeDamage(amount, tower) {
                if (this.isInvulnerable) return;
                this.health -= amount; if (tower) this.damagingTowers.add(tower);
                if (this.health <= 0 && this.active) {
                    this.active = false; 
                    this.game.enemyDefeated(this);
                }
            }
            applyEffect(type, effectData) { this.effects.set(type, { ...effectData }); }
             teleport(indicesBack) {
                this.pathIndex = Math.max(0, this.pathIndex - indicesBack);
                const newPos = this.game.path[this.pathIndex];
                if (newPos) { this.x = newPos.x; this.y = newPos.y; }
            }
        }

        class Tower {
            constructor(game, gridX, gridY, type) {
                this.game = game; this.x = gridX * TILE_SIZE + TILE_SIZE / 2; this.y = gridY * TILE_SIZE + TILE_SIZE / 2;
                this.gridX = gridX; this.gridY = gridY; this.typeKey = type;
                this.typeInfo = JSON.parse(JSON.stringify(game.towerTypes[type]));
                this.fireCooldown = 0; this.upgradeCount = 0; this.MAX_UPGRADES = 8; this.isEvolved = false;
                const modifiers = DIFFICULTY_MODIFIERS[this.game.difficulty];
                const baseCost = this.typeInfo.cost * modifiers.towerCost;
                this.totalInvestedGold = baseCost;
                this.upgradeCost = Math.floor(baseCost * 0.6);
                this.disabledTimer = 0; this.shotsLeft = 0;
                if (this.typeInfo.special === 'plasma') { this.plasmaTarget = null; this.plasmaStacks = 0; this.plasmaEffect = null; }
            }
            update(enemies) {
                if (this.disabledTimer > 0) {
                    this.disabledTimer--;
                    if (this.plasmaTarget) {
                        this.plasmaTarget = null; this.plasmaStacks = 0;
                        if (this.plasmaEffect) { this.plasmaEffect.active = false; this.plasmaEffect = null; }
                    }
                    return;
                }
                if (this.typeInfo.special === 'plasma') {
                    const target = this.findTarget(enemies);
                    if (target && target === this.plasmaTarget) {
                        if (this.plasmaStacks < this.typeInfo.rampUp.maxStacks) { this.plasmaStacks++; }
                        const totalDamage = this.typeInfo.damage + (this.plasmaStacks * this.typeInfo.rampUp.damage);
                        target.takeDamage(totalDamage / 60, this);
                        if (!this.plasmaEffect || !this.plasmaEffect.active) {
                             this.plasmaEffect = new PlasmaBeamEffect(this.game, this, target);
                             this.game.effects.push(this.plasmaEffect);
                        }
                    } else if (target) {
                        this.plasmaTarget = target; this.plasmaStacks = 1;
                        if (this.plasmaEffect) this.plasmaEffect.active = false;
                        this.plasmaEffect = new PlasmaBeamEffect(this.game, this, target);
                        this.game.effects.push(this.plasmaEffect);
                    } else {
                        this.plasmaTarget = null; this.plasmaStacks = 0;
                        if (this.plasmaEffect) { this.plasmaEffect.active = false; this.plasmaEffect = null; }
                    }
                    return;
                }
                this.fireCooldown--;
                if (this.fireCooldown <= 0) { 
                    if (this.typeInfo.shotsPerWave && this.shotsLeft <= 0) { return; }
                    if (this.typeInfo.special === 'tesla') { this.shoot(enemies); } 
                    else { const target = this.findTarget(enemies); if (target) { this.shoot(target); } }
                    this.fireCooldown = this.typeInfo.fireRate; 
                }
            }
            
            draw(ctx, frameCount) {
                ctx.save();
                const coreRadius = TILE_SIZE / 2 - 2;
                ctx.fillStyle = '#555'; ctx.beginPath(); ctx.arc(this.x, this.y, coreRadius, 0, Math.PI * 2); ctx.fill();
                ctx.font = `${TILE_SIZE * 0.8}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(this.typeInfo.emoji, this.x, this.y);
                if (this.disabledTimer > 0) {
                    ctx.fillStyle = 'rgba(50, 50, 50, 0.7)'; ctx.beginPath(); ctx.arc(this.x, this.y, coreRadius, 0, Math.PI * 2); ctx.fill();
                    if (frameCount % 4 < 2) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; ctx.lineWidth = 1;
                        for (let i = 0; i < 5; i++) {
                            ctx.beginPath();
                            ctx.moveTo(this.x - coreRadius + Math.random() * coreRadius * 2, this.y - coreRadius + Math.random() * coreRadius * 2);
                            ctx.lineTo(this.x - coreRadius + Math.random() * coreRadius * 2, this.y - coreRadius + Math.random() * coreRadius * 2);
                            ctx.stroke();
                        }
                    }
                }
                const pipRadius = 2.5; const pipOrbitRadius = TILE_SIZE / 2 - 4;
                for (let i = 0; i < this.upgradeCount; i++) {
                    const angle = (i * (Math.PI / 4)) - (Math.PI / 2) - (Math.PI / 8);
                    ctx.fillStyle = '#FFC107'; ctx.beginPath();
                    ctx.arc(this.x + pipOrbitRadius * Math.cos(angle), this.y + pipOrbitRadius * Math.sin(angle), pipRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                if (this.isEvolved && this.typeInfo.shotsPerWave) {
                    ctx.fillStyle = 'white'; ctx.font = 'bold 10px Segoe UI'; ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
                    ctx.fillText(this.shotsLeft, this.x + TILE_SIZE / 2, this.y + TILE_SIZE / 2);
                }
                ctx.restore();
            }
            findTarget(enemies) {
                let potentialTargets = enemies.filter(e => {
                    if (!e.active) return false;
                    if (e.isFlying && !this.typeInfo.canHitFlying) return false;
                    if (!e.isFlying && !this.typeInfo.canHitGround && this.typeInfo.canHitGround !== undefined) return false;
                    const dist = Math.hypot(e.x - this.x, e.y - this.y);
                    return dist < this.typeInfo.range;
                });
                if (this.typeInfo.special === 'plasma') {
                    const flyingBosses = potentialTargets.filter(e => e.type === 'boss' && e.isFlying);
                    if (flyingBosses.length > 0) potentialTargets = flyingBosses;
                    else {
                        const flyingElites = potentialTargets.filter(e => ['healer', 'disabler'].includes(e.type) && e.isFlying);
                        if (flyingElites.length > 0) potentialTargets = flyingElites;
                        else potentialTargets = potentialTargets.filter(e => e.isFlying);
                    }
                }
                if (potentialTargets.length === 0) return null;
                return potentialTargets.sort((a,b) => b.pathIndex - a.pathIndex)[0];
            }
            shoot(targetOrEnemies) {
                if (this.typeInfo.special === 'plasma') return;
                if (this.typeInfo.special === 'tesla') {
                    const targetsInRange = targetOrEnemies.filter(e => e.active && Math.hypot(this.x - e.x, this.y - e.y) < this.typeInfo.range);
                    if (targetsInRange.length > 0) {
                        const maxTargets = this.typeInfo.chain.targets;
                        const finalTargets = targetsInRange.sort((a, b) => Math.hypot(this.x - a.x, this.y - a.y) - Math.hypot(this.x - b.x, this.y - b.y)).slice(0, maxTargets);
                        const targetPositions = finalTargets.map(t => ({x: t.x, y: t.y}));
                        this.game.effects.push(new TeslaEffect(this.game, {x: this.x, y: this.y}, targetPositions, 15));
                        finalTargets.forEach(t => { t.takeDamage(this.typeInfo.damage, this); });
                    }
                } 
                else if (this.typeInfo.projectileType === 'beam') {
                    targetOrEnemies.takeDamage(this.typeInfo.damage, this);
                    this.game.effects.push(new Effect(this.game, this.x, this.y, 0, this.typeInfo.projectileColor, 10, targetOrEnemies));
                } 
                else {
                    this.game.projectiles.push(new Projectile(this.game, this.x, this.y, targetOrEnemies, this, this.typeKey, this.typeInfo.special));
                }
                if (this.typeInfo.shotsPerWave) { this.shotsLeft--; }
            }
            
            applyUpgradeStats() {
                const uInfo = this.game.towerTypes[this.typeKey].upgrade;
                if(uInfo.damage) this.typeInfo.damage += uInfo.damage;
                if(uInfo.range) this.typeInfo.range += uInfo.range;
                if(uInfo.fireRate) this.typeInfo.fireRate = Math.max(10, this.typeInfo.fireRate - uInfo.fireRate);
                if(uInfo.splashRadius && this.typeInfo.splashRadius) this.typeInfo.splashRadius += uInfo.splashRadius;
                if(uInfo.acidMultiplier && this.typeInfo.acid) this.typeInfo.acid.multiplier += uInfo.acidMultiplier;
                if(uInfo.slowRadius && this.typeInfo.slowRadius) this.typeInfo.slowRadius += uInfo.slowRadius;
            }
            upgrade() {
                this.totalInvestedGold += this.upgradeCost;
                this.upgradeCount++;
                this.applyUpgradeStats();
                this.upgradeCost = Math.floor(this.upgradeCost * 1.7);
            }
            evolve(pathKey) {
                if (this.isEvolved || !this.typeInfo.evolutions) return;
                const evolutionData = this.game.towerTypes[this.typeKey].evolutions.paths[pathKey];
                const finalEvolutionCost = this.upgradeCost * (evolutionData.evolutionCostMultiplier || 1);
                if (this.game.gold >= finalEvolutionCost || cheats.unlimitedResources) {
                    if (!cheats.unlimitedResources) { this.game.gold -= finalEvolutionCost; }
                    this.totalInvestedGold += finalEvolutionCost;
                    Object.assign(this.typeInfo, evolutionData);
                    if (this.typeInfo.shotsPerWave) { this.shotsLeft = this.typeInfo.shotsPerWave; }
                    if (this.typeInfo.special === 'plasma') { this.plasmaTarget = null; this.plasmaStacks = 0; this.plasmaEffect = null; }
                    this.isEvolved = true;
                    this.game.closeMenu();
                }
            }
        }

        class Projectile {
            constructor(game, x, y, target, tower, typeKey, special = null) {
                this.game = game; this.x = x; this.y = y; this.tower = tower; this.typeKey = typeKey;
                this.speed = tower.typeInfo.projectileSpeed; 
                this.damage = tower.typeInfo.damage; 
                this.color = tower.typeInfo.projectileColor; 
                this.active = true;
                this.special = special;
                this.projectileType = tower.typeInfo.projectileType;
                if (this.special === 'sniper') {
                    const evolutionLevel = tower.typeInfo.evolutions.level;
                    const waveBonus = Math.max(0, this.game.waveNumber - evolutionLevel);
                    this.damage *= (1 + waveBonus * 0.15);
                }
                this.targetX = target.x;
                this.targetY = target.y;
                const dx = this.targetX - this.x; const dy = this.targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                this.velocityX = (dx / dist) * this.speed;
                this.velocityY = (dy / dist) * this.speed;
                this.rotation = Math.atan2(dy, dx);
                this.isGroundTarget = ['cannon', 'ice', 'acid', 'pull', 'teleport'].includes(this.special) || ['cannon', 'ice', 'acid'].includes(this.typeKey);
                if (this.typeKey === 'acid') { this.particles = []; }
            }
            update() {
                if (!this.active) return;
                if (this.projectileType === 'beam' || this.special === 'tesla') { this.active = false; return; }
                this.x += this.velocityX; this.y += this.velocityY;
                if (this.x < 0 || this.x > this.game.width || this.y < 0 || this.y > this.game.height) { this.active = false; return; }
                if (this.typeKey === 'acid') { this.game.effects.push(new Particle(this.game, this.x, this.y, this.color)); }
                if (this.isGroundTarget) {
                    const distToTarget = Math.hypot(this.x - this.targetX, this.y - this.targetY);
                    if (distToTarget < this.speed) { this.active = false; this.onHitGround(this.targetX, this.targetY); }
                } else {
                    for (const enemy of this.game.enemies) {
                        if (!enemy.active) continue;
                        if (enemy.isFlying && !this.tower.typeInfo.canHitFlying) continue;
                        if (!enemy.isFlying && !this.tower.typeInfo.canHitGround && this.tower.typeInfo.canHitGround !== undefined) continue;
                        const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                        if (dist < enemy.width / 2) { this.active = false; this.onHit(enemy); return; }
                    }
                }
            }
            onHit(enemy) { enemy.takeDamage(this.damage, this.tower); }
            onHitGround(impactX, impactY) {
                const tInfo = this.tower.typeInfo;
                if (tInfo.special === 'pull') { this.game.effects.push(new SingularityEffect(this.game, impactX, impactY, tInfo.splashRadius)); } 
                else if (tInfo.special === 'teleport') {
                    this.game.enemies.forEach(e => {
                        if (!e.active || e.isFlying) return;
                        const d = Math.hypot(e.x - impactX, e.y - impactY);
                        if (d <= tInfo.splashRadius) { e.teleport(3); }
                    });
                }
                if (this.typeKey === 'cannon' && !tInfo.special) {
                    this.game.effects.push(new Effect(this.game, impactX, impactY, tInfo.splashRadius, 'rgba(100, 100, 100, 0.5)', 15));
                    this.game.enemies.forEach(e => {
                        if (!e.active || e.isFlying) return;
                        const dX = e.x - impactX, dY = e.y - impactY; const sDist = Math.sqrt(dX*dX + dY*dY);
                        if (sDist <= tInfo.splashRadius) e.takeDamage(this.damage, this.tower);
                    });
                } else if (this.typeKey === 'ice') { 
                    const slowPower = Math.max(tInfo.slow.maxSlow, tInfo.slow.baseMultiplier - (this.damage * tInfo.slow.damageScale));
                    this.game.effects.push(new Effect(this.game, impactX, impactY, tInfo.slowRadius, 'rgba(3, 169, 244, 0.3)', 20));
                    this.game.enemies.forEach(e => {
                        if (!e.active || e.isFlying) return;
                        const dX = e.x - impactX, dY = e.y - impactY; const sDist = Math.sqrt(dX*dX + dY*dY);
                        if (sDist <= tInfo.slowRadius) { e.applyEffect('slow', { multiplier: slowPower, duration: tInfo.slow.duration }); }
                    });
                } else if (this.typeKey === 'acid') {
                    this.game.effects.push(new AcidPuddle(this.game, impactX, impactY, this.damage, tInfo.acid));
                }
            }
            draw(ctx) {
                if (this.projectileType === 'beam' || this.special === 'tesla') { return; }
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = this.color;
                switch(this.special) {
                    case 'sniper': ctx.fillRect(-10, -1.5, 20, 3); break;
                    case 'gatling': ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI * 2); ctx.fill(); break;
                    case 'pull': ctx.globalAlpha = 0.5 + 0.5 * Math.sin(this.game.frameCount * 0.2); ctx.beginPath(); ctx.arc(0, 0, 7, 0, Math.PI * 2); ctx.fill(); break;
                    case 'teleport':
                        ctx.beginPath(); ctx.arc(0, 0, 7, 0, Math.PI * 2); ctx.fill();
                        for(let i = 0; i < 3; i++) {
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; ctx.lineWidth = 1; ctx.beginPath();
                            ctx.moveTo(Math.random() * 10 - 5, Math.random() * 10 - 5);
                            ctx.lineTo(Math.random() * 10 - 5, Math.random() * 10 - 5);
                            ctx.stroke();
                        }
                        break;
                    default:
                        switch(this.typeKey) {
                            case 'ice': ctx.beginPath(); ctx.moveTo(0, -6); ctx.lineTo(6, 0); ctx.lineTo(0, 6); ctx.lineTo(-6, 0); ctx.closePath(); ctx.fill(); break;
                            case 'cannon': ctx.beginPath(); ctx.arc(0, 0, 7, 0, Math.PI * 2); ctx.fill(); break;
                            default: ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI * 2); ctx.fill();
                        }
                }
                ctx.restore();
            }
        }

        class Effect {
            constructor(game, x, y, radius, color, life, target = null) {
                this.game = game; this.x = x; this.y = y; this.maxRadius = radius; this.color = color;
                this.life = life; this.maxLife = life; this.active = true;
                this.target = target;
            }
            update() { this.life--; if (this.life <= 0) this.active = false; }
            draw(ctx) {
                if (this.target) {
                    ctx.save(); ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.target.x, this.target.y);
                    ctx.strokeStyle = this.color; ctx.lineWidth = 2 + (this.life / this.maxLife) * 3;
                    ctx.globalAlpha = this.life / this.maxLife; ctx.stroke(); ctx.restore();
                } else {
                    ctx.save();
                    const r = this.maxRadius * (1 - (this.life / this.maxLife));
                    ctx.globalAlpha = this.life / this.maxLife; ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
                    ctx.strokeStyle = this.color; ctx.lineWidth = 3; ctx.stroke();
                    ctx.restore();
                }
            }
        }
        
        class PlasmaBeamEffect extends Effect {
            constructor(game, tower, target) {
                super(game, tower.x, tower.y, 0, '', 9999);
                this.tower = tower; this.target = target;
            }
            update() { if (!this.target.active || this.tower.plasmaTarget !== this.target) { this.active = false; } }
            draw(ctx) {
                if (!this.target || !this.target.active) return;
                const stacks = this.tower.plasmaStacks;
                const maxStacks = this.tower.typeInfo.rampUp.maxStacks;
                const intensity = Math.min(1, stacks / (maxStacks * 0.5));
                ctx.save(); ctx.beginPath(); ctx.moveTo(this.tower.x, this.tower.y); ctx.lineTo(this.target.x, this.target.y);
                ctx.strokeStyle = `rgba(255, 50, 100, ${0.2 * intensity})`; ctx.lineWidth = 10 + 8 * intensity;
                ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 20; ctx.stroke();
                ctx.strokeStyle = `rgba(255, 150, 150, ${0.7 * intensity})`; ctx.lineWidth = 4 + 3 * intensity;
                ctx.shadowBlur = 10; ctx.stroke();
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.9 * intensity})`; ctx.lineWidth = 2;
                ctx.shadowBlur = 5; ctx.stroke();
                ctx.restore();
            }
        }

        class TeslaEffect extends Effect {
            constructor(game, startPos, targetPositions, life) {
                super(game, startPos.x, startPos.y, 0, '#80DEEA', life);
                this.targetPositions = targetPositions;
            }
            draw(ctx) {
                ctx.save(); ctx.lineWidth = 3; ctx.strokeStyle = `rgba(128, 222, 234, ${this.life / this.maxLife})`;
                ctx.shadowColor = '#00BCD4'; ctx.shadowBlur = 10;
                this.targetPositions.forEach(endPos => { this.drawLightning(ctx, this.x, this.y, endPos.x, endPos.y); });
                ctx.restore();
            }
            drawLightning(ctx, x1, y1, x2, y2) {
                ctx.beginPath(); ctx.moveTo(x1, y1);
                const dx = x2 - x1; const dy = y2 - y1; const dist = Math.hypot(dx, dy);
                const segments = Math.max(5, Math.floor(dist / 15)); const roughness = 10;
                for (let i = 1; i < segments; i++) {
                    const t = i / segments;
                    const randX = (Math.random() - 0.5) * roughness * (1 - t);
                    const randY = (Math.random() - 0.5) * roughness * (1 - t);
                    ctx.lineTo(x1 + dx * t + randX, y1 + dy * t + randY);
                }
                ctx.lineTo(x2, y2); ctx.stroke();
            }
        }

        class AcidPuddle extends Effect {
            constructor(game, x, y, damage, acidData) {
                super(game, x, y, TILE_SIZE * 0.8, 'rgba(127, 255, 0, 0.4)', 144);
                this.damage = damage; this.acidData = acidData; this.affectedEnemies = new Set();
            }
            update() {
                super.update();
                this.game.enemies.forEach(e => {
                    if (e.active && !e.isFlying && !this.affectedEnemies.has(e)) {
                        const dist = Math.hypot(this.x - e.x, this.y - e.y);
                        if (dist < this.maxRadius) {
                            const acidDps = this.damage * this.acidData.multiplier;
                            e.applyEffect('acid', { damagePerTick: acidDps, duration: this.acidData.duration });
                            this.affectedEnemies.add(e);
                        }
                    }
                });
            }
            draw(ctx) {
                ctx.save(); ctx.globalAlpha = (this.life / this.maxLife) * 0.5;
                ctx.fillStyle = this.color; ctx.beginPath();
                ctx.arc(this.x, this.y, this.maxRadius, 0, Math.PI * 2);
                ctx.fill(); ctx.restore();
            }
        }

        class Particle extends Effect {
            constructor(game, x, y, color) {
                super(game, x, y, 0, color, 20);
                this.size = Math.random() * 2 + 1;
            }
            draw(ctx) {
                ctx.save(); ctx.globalAlpha = this.life / this.maxLife;
                ctx.fillStyle = this.color; ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill(); ctx.restore();
            }
        }

        class SingularityEffect extends Effect {
            constructor(game, x, y, radius) {
                super(game, x, y, radius, 'rgba(150, 50, 255, 0.7)', 60);
                this.pullStrength = 2.5;
            }
            update() {
                super.update();
                this.game.enemies.forEach(e => {
                    if (e.active && !e.isFlying) {
                        const dist = Math.hypot(e.x - this.x, e.y - this.y);
                        if (dist < this.maxRadius) {
                            const angle = Math.atan2(this.y - e.y, this.x - e.x);
                            e.x += Math.cos(angle) * this.pullStrength;
                            e.y += Math.sin(angle) * this.pullStrength;
                        }
                    }
                });
            }
            draw(ctx) {
                ctx.save();
                const r = this.maxRadius * (this.life / this.maxLife);
                ctx.globalAlpha = (this.life / this.maxLife) * 0.5;
                ctx.fillStyle = this.color; ctx.beginPath();
                ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
                ctx.fill(); ctx.restore();
            }
        }

        class MeteorEffect extends Effect {
            constructor(game, x, y, radius, damage) {
                super(game, x, y, radius, 'rgba(255, 100, 0, 0.7)', 45);
                this.damage = damage; this.fallDuration = 30; this.hasImpacted = false;
            }
            update() {
                this.life--; if (this.life <= 0) this.active = false;
                if (this.life <= (this.maxLife - this.fallDuration) && !this.hasImpacted) { this.impact(); this.hasImpacted = true; }
            }
            draw(ctx) {
                ctx.save();
                if (this.life > (this.maxLife - this.fallDuration)) {
                    const fallProgress = (this.maxLife - this.life) / this.fallDuration;
                    const meteorY = this.y * fallProgress - 50 * (1-fallProgress);
                    ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.arc(this.x, meteorY, 15, 0, Math.PI * 2); ctx.fill();
                } else {
                    const explosionLife = this.maxLife - this.fallDuration;
                    const r = this.maxRadius * (1 - ((this.life) / explosionLife));
                    ctx.globalAlpha = this.life / explosionLife; ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
                    ctx.fillStyle = this.color; ctx.fill();
                }
                ctx.restore();
            }
            impact() {
                this.game.enemies.forEach(e => {
                    if (!e.active) return;
                    const dX = e.x - this.x, dY = e.y - this.y; const dist = Math.sqrt(dX*dX + dY*dY);
                    if (dist <= this.maxRadius) e.takeDamage(this.damage, null);
                });
            }
        }

        // --- CLASE DEL TUTORIAL INTERACTIVO ---
        class TutorialManager {
            constructor(game) {
                this.game = game;
                this.currentStep = 0;
                this.isPaused = false;
                this.waitingFor = null;

                // Elementos del DOM
                this.overlay = document.getElementById('tutorial-overlay');
                this.highlight = document.getElementById('tutorial-highlight');
                this.messageBox = document.getElementById('tutorial-message-box');
                this.messageText = document.getElementById('tutorial-message-text');
                this.nextButton = document.getElementById('tutorial-next-step-button');

                this.steps = [
                    { 
                        text: "¡Bienvenido! Tu objetivo es defender la base (al final del camino) de los enemigos.",
                        highlightTarget: () => this.game.canvas,
                        waitFor: { type: 'button_click' }
                    },
                    {
                        text: "Para construir, haz clic en una casilla vacía como esta.",
                        highlightTarget: () => {
                            const rect = this.game.canvas.getBoundingClientRect();
                            return { 
                                left: rect.left + (5 * TILE_SIZE * this.game.scale), 
                                top: rect.top + (3 * TILE_SIZE * this.game.scale), 
                                width: TILE_SIZE * this.game.scale, 
                                height: TILE_SIZE * this.game.scale 
                            };
                        },
                        waitFor: { type: 'canvas_click', condition: (data) => {
                            const gridX = Math.floor(data.x / TILE_SIZE);
                            const gridY = Math.floor(data.y / TILE_SIZE);
                            return gridX === 5 && gridY === 3;
                        }}
                    },
                    {
                        text: "¡Excelente! Ahora construye una Torre de Flechas. Es tu defensa principal al inicio.",
                        waitFor: { type: 'tower_built', condition: (data) => data.type === 'arrow' }
                    },
                    {
                        text: "Tienes un límite de torres que puedes construir. ¡Úsalo sabiamente!",
                        highlightTarget: () => document.getElementById('tower-count-stat'),
                        waitFor: { type: 'button_click' }
                    },
                    {
                        text: "¡Todo listo! Presiona 'Iniciar' para comenzar la primera oleada.",
                        highlightTarget: () => document.getElementById('wave-button'),
                        waitFor: { type: 'wave_started' }
                    },
                    {
                        text: "¡Buen trabajo! Al superar oleadas ganas Diamantes 💎, una moneda muy valiosa.",
                        highlightTarget: () => document.getElementById('diamonds-stat'),
                        waitFor: { type: 'wave_cleared' }
                    },
                    {
                        text: "Los diamantes se usan para habilidades poderosas, como el Meteorito que desbloquearás más adelante.",
                        highlightTarget: () => document.getElementById('meteor-button'),
                        waitFor: { type: 'button_click' }
                    },
                    {
                        text: "En el panel derecho tienes herramientas útiles. 'Arsenal' te muestra las torres que has desbloqueado.",
                        highlightTarget: () => document.getElementById('arsenal-button'),
                        waitFor: { type: 'button_click' }
                    },
                    {
                        text: "'Bestiario' te da información sobre los enemigos que has encontrado.",
                        highlightTarget: () => document.getElementById('bestiary-button'),
                        waitFor: { type: 'button_click' }
                    },
                    {
                        text: "Y 'Poderes' te recuerda el costo y efecto de tus habilidades especiales.",
                        highlightTarget: () => document.getElementById('powers-button'),
                        waitFor: { type: 'button_click' }
                    },
                    {
                        text: "¡Has completado el tutorial! Ahora estás listo para jugar. ¡Buena suerte!",
                        highlightTarget: () => this.game.canvas,
                        waitFor: { type: 'button_click' }
                    }
                ];
            }

            start() {
                this.overlay.style.display = 'block';
                this.currentStep = -1;
                this.nextStep();
            }

            nextStep() {
                this.currentStep++;
                if (this.currentStep >= this.steps.length) {
                    this.end();
                    return;
                }
                this.runStep(this.currentStep);
            }

            runStep(index) {
                const step = this.steps[index];
                this.isPaused = (step.waitFor.type !== 'wave_cleared'); // Pause unless waiting for wave to clear
                this.game.isPaused = this.isPaused;
                this.waitingFor = step.waitFor;
                this.showMessage(step.text);

                if (step.highlightTarget) {
                    this.highlightElement(step.highlightTarget());
                } else {
                    this.highlight.style.display = 'none';
                }

                if (step.waitFor.type === 'button_click' && !step.waitFor.element) {
                    this.nextButton.style.display = 'block';
                    this.nextButton.onclick = () => {
                        this.nextButton.style.display = 'none';
                        this.nextStep();
                    };
                } else {
                     this.nextButton.style.display = 'none';
                }
            }
            
            highlightElement(target) {
                if (!target) {
                    this.highlight.style.display = 'none';
                    return;
                }
                
                let rect;
                if (target instanceof HTMLElement) {
                    rect = target.getBoundingClientRect();
                } else {
                    rect = target; // Es un objeto con left, top, width, height
                }

                this.highlight.style.display = 'block';
                this.highlight.style.left = `${rect.left - 5}px`;
                this.highlight.style.top = `${rect.top - 5}px`;
                this.highlight.style.width = `${rect.width + 10}px`;
                this.highlight.style.height = `${rect.height + 10}px`;

                // --- POSICIONAMIENTO INTELIGENTE DE LA CAJA DE MENSAJE ---
                const canvasRect = this.game.canvas.getBoundingClientRect();
                const msgBox = this.messageBox;
                const msgBoxRect = msgBox.getBoundingClientRect(); // Get its dimensions
                const margin = 15; // Margin from edges

                // Center of the highlighted target
                const targetCenterX = rect.left + rect.width / 2;
                const targetCenterY = rect.top + rect.height / 2;

                // Default position: bottom right of the canvas
                let newLeft = canvasRect.right - msgBoxRect.width - margin;
                let newTop = canvasRect.bottom - msgBoxRect.height - margin;

                // If the target is in the bottom-right quadrant, move the box to the top-left
                if (targetCenterX > canvasRect.left + canvasRect.width / 2 && targetCenterY > canvasRect.top + canvasRect.height / 2) {
                    newLeft = canvasRect.left + margin;
                    newTop = canvasRect.top + margin;
                } 
                // If the target is in the bottom-left, move box to top-right
                else if (targetCenterX <= canvasRect.left + canvasRect.width / 2 && targetCenterY > canvasRect.top + canvasRect.height / 2) {
                    newLeft = canvasRect.right - msgBoxRect.width - margin;
                    newTop = canvasRect.top + margin;
                }
                // If the target is in the top-right, move box to bottom-left
                else if (targetCenterX > canvasRect.left + canvasRect.width / 2 && targetCenterY <= canvasRect.top + canvasRect.height / 2) {
                    newLeft = canvasRect.left + margin;
                    newTop = canvasRect.bottom - msgBoxRect.height - margin;
                }
                // If the target is in the top-left, move box to bottom-right (the default)

                // Clamp values to ensure it's always inside the canvas
                newLeft = Math.max(canvasRect.left, Math.min(newLeft, canvasRect.right - msgBoxRect.width));
                newTop = Math.max(canvasRect.top, Math.min(newTop, canvasRect.bottom - msgBoxRect.height));

                msgBox.style.left = `${newLeft}px`;
                msgBox.style.top = `${newTop}px`;
            }

            showMessage(text) {
                this.messageText.innerHTML = text;
            }

            isWaitingForInput() {
                return !!this.waitingFor;
            }

            handleInput(inputType, data) {
                if (!this.waitingFor || this.waitingFor.type !== inputType) return false;
                
                if (this.waitingFor.condition) {
                    if (this.waitingFor.condition(data)) {
                        this.nextStep();
                        return true;
                    }
                }
                return false;
            }

            checkCondition(conditionType, data) {
                 if (!this.waitingFor || this.waitingFor.type !== conditionType) return false;
                 if (this.waitingFor.condition) {
                       if(this.waitingFor.condition(data)) {
                           this.nextStep();
                           return true;
                       }
                 } else {
                       this.nextStep();
                       return true;
                 }
                 return false;
            }

            getWaveConfig() {
                return [{ type: 'standard' }, { type: 'standard' }];
            }

            end() {
                this.overlay.style.display = 'none';
                window.location.reload();
            }
        }
        
        // --- LÓGICA DE LA INTERFAZ Y EL MENÚ ---
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const menuCanvas = document.getElementById('menu-background-canvas');
            let game;
            let selectedDifficulty = 'normal';

            // --- DEV TOOLS ---
            let secretCodeSequence = [];
            const targetSequence = ['gold-rush-button', 'pause-button', 'wave-button'];
            let isDeveloperMode = false;
            

            // Elementos de la interfaz
            const mainMenuScreen = document.getElementById('main-menu-screen');
            const mapSelectionScreen = document.getElementById('map-selection-screen');
            const gameUiContainer = document.getElementById('game-ui-container');
            const tutorialPromptModal = document.getElementById('tutorial-prompt-modal');
            const playOptionsModal = document.getElementById('play-options-modal');
            const arsenalModal = document.getElementById('arsenal-modal');
            const bestiaryModal = document.getElementById('bestiary-modal');
            const powersModal = document.getElementById('powers-modal');
            const meteorUnlockModal = document.getElementById('meteor-unlock-modal');
            const devToolsButton = document.getElementById('dev-tools-button');
            const devToolsModal = document.getElementById('dev-tools-modal');
            const difficultyModal = document.getElementById('difficulty-modal');
            const difficultyButton = document.getElementById('difficulty-button');
            const masteryUnlockModal = document.getElementById('mastery-unlock-modal');
            const playAgainButton = document.getElementById('play-again-button');
            const hardModeInfoModal = document.getElementById('hard-mode-info-modal');
            const closeHardModeInfoButton = document.getElementById('close-hard-mode-info-button');
            const hideHardModeInfoCheckbox = document.getElementById('hide-hard-mode-info-checkbox');


            // Botones del menú principal
            const playButton = document.getElementById('play-button');
            const tutorialButton = document.getElementById('tutorial-button');
            const exitButton = document.getElementById('exit-button');
            const continueButton = document.getElementById('continue-button');
            const newGameButton = document.getElementById('new-game-button');

            // --- LÓGICA DEL NUEVO MENÚ ---
            let particles = [];
            let animationFrameId;
            let menuMusicPlayer;
            let menuMusicAnalyser;

            function setupMainMenu() {
                menuCanvas.style.display = 'block';
                const ctx = menuCanvas.getContext('2d');
                
                function resizeMenuCanvas() {
                    menuCanvas.width = window.innerWidth;
                    menuCanvas.height = window.innerHeight;
                }
                
                class Particle {
                    constructor() {
                        this.x = Math.random() * menuCanvas.width;
                        this.y = Math.random() * menuCanvas.height;
                        this.size = Math.random() * 2 + 1;
                        this.baseSize = this.size;
                        this.speedX = (Math.random() - 0.5) * 0.5;
                        this.speedY = (Math.random() - 0.5) * 0.5;
                        this.opacity = Math.random() * 0.5 + 0.2;
                        this.baseOpacity = this.opacity;
                        this.pulse = 0;
                    }
                    update() {
                        this.x += this.speedX;
                        this.y += this.speedY;
                        if (this.x < 0 || this.x > menuCanvas.width) this.speedX *= -1;
                        if (this.y < 0 || this.y > menuCanvas.height) this.speedY *= -1;

                        if (this.pulse > 0) {
                            this.pulse--;
                            const pulseRatio = this.pulse / 10;
                            this.size = this.baseSize + 8 * pulseRatio;
                            this.opacity = this.baseOpacity + 0.8 * pulseRatio;
                        } else {
                            this.size = this.baseSize;
                            this.opacity = this.baseOpacity;
                        }
                    }
                    draw() {
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                        ctx.shadowColor = '#fff';
                        ctx.shadowBlur = 10;
                        ctx.fill();
                    }
                }

                function initParticles() {
                    particles = [];
                    const numberOfParticles = (menuCanvas.width * menuCanvas.height) / 9000;
                    for (let i = 0; i < numberOfParticles; i++) {
                        particles.push(new Particle());
                    }
                }

                let lastBeat = 0;
                function animateParticles() {
                    ctx.clearRect(0, 0, menuCanvas.width, menuCanvas.height);
                    
                    if (menuMusicAnalyser) {
                        const values = menuMusicAnalyser.getValue();
                        const avg = values.reduce((sum, val) => sum + Math.abs(val), 0) / values.length;
                        
                        if (avg > 0.05 && (Date.now() - lastBeat > 150)) { // Threshold y cooldown para evitar demasiados saltos
                            lastBeat = Date.now();
                            const particleToPulse = particles[Math.floor(Math.random() * particles.length)];
                            if(particleToPulse) particleToPulse.pulse = 10;
                        }
                    }

                    particles.forEach(p => {
                        p.update();
                        p.draw();
                    });
                    animationFrameId = requestAnimationFrame(animateParticles);
                }

                window.addEventListener('resize', () => {
                    resizeMenuCanvas();
                    initParticles();
                });

                resizeMenuCanvas();
                initParticles();
                animateParticles();
            }
            
            function stopMainMenuAnimation() {
                if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
                 menuCanvas.style.display = 'none';
            }

            function setupGameListeners() {
                // --- SECRET CODE LISTENER ---
                const secretButtons = ['gold-rush-button', 'pause-button', 'wave-button'];
                secretButtons.forEach(id => {
                    document.getElementById(id).addEventListener('click', () => {
                        if (isDeveloperMode) return;
                        secretCodeSequence.push(id);
                        if (secretCodeSequence.length > targetSequence.length) {
                            secretCodeSequence.shift();
                        }
                        if (JSON.stringify(secretCodeSequence) === JSON.stringify(targetSequence)) {
                            isDeveloperMode = true;
                            devToolsButton.style.display = 'block';
                            secretCodeSequence = [];
                        }
                    });
                });

                document.getElementById('wave-button').onclick = () => game.startWave();
                document.getElementById('pause-button').onclick = () => game.togglePause();
                document.getElementById('speed-1x-button').onclick = () => game.setSpeed(1);
                document.getElementById('speed-2x-button').onclick = () => game.setSpeed(2);
                document.getElementById('speed-5x-button').onclick = () => game.setSpeed(5);
                document.getElementById('meteor-button').onclick = () => game.activateMeteor();
                document.getElementById('gold-rush-button').onclick = () => game.activateGoldRush();
                document.getElementById('lucky-button').onclick = () => game.feelingLucky();
                document.getElementById('continue-endless-button').onclick = () => game.continueEndlessMode();
                document.getElementById('fullscreen-button').onclick = toggleFullScreen;
                document.getElementById('exit-to-menu-button').onclick = () => {
                    stopMusic();
                    window.location.reload();
                };
                
                document.getElementById('arsenal-button').onclick = () => {
                    game.pauseGame();
                    updateArsenalModal();
                    arsenalModal.style.display = 'flex';
                    resizeHandler();
                };
                document.getElementById('close-arsenal-button').onclick = () => {
                    arsenalModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };
                document.getElementById('close-arsenal-x').onclick = () => {
                    arsenalModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };

                document.getElementById('bestiary-button').onclick = () => {
                    game.pauseGame();
                    updateBestiaryModal();
                    bestiaryModal.style.display = 'flex';
                    resizeHandler();
                };
                document.getElementById('close-bestiary-button').onclick = () => {
                    bestiaryModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };
                document.getElementById('close-bestiary-x').onclick = () => {
                    bestiaryModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };
                
                document.getElementById('powers-button').onclick = () => {
                    game.pauseGame();
                    updatePowersModal();
                    powersModal.style.display = 'flex';
                    resizeHandler();
                };
                document.getElementById('close-powers-button').onclick = () => {
                    powersModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };
                document.getElementById('close-powers-x').onclick = () => {
                    powersModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };

                const closeMeteorUnlock = () => {
                    if (document.getElementById('hide-meteor-checkbox').checked) {
                        localStorage.setItem('hideMeteorUnlock', 'true');
                    }
                    meteorUnlockModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };
                document.getElementById('close-meteor-unlock-button').onclick = closeMeteorUnlock;
                
                document.getElementById('close-mastery-unlock-button').onclick = () => {
                    masteryUnlockModal.style.display = 'none';
                    document.getElementById('wave-button').disabled = false;
                    game.pauseGame();
                };


                canvas.addEventListener('mousemove', (e) => {
                    if(game) {
                        game.mousePos = { x: e.clientX, y: e.clientY };
                    }
                });

                canvas.addEventListener('click', (e) => {
                    if(game) {
                        const { x, y } = getGameCoordinates(e.clientX, e.clientY);
                        game.handleCanvasClick(x, y);
                    }
                });
                
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault(); 
                    if (e.changedTouches.length === 1 && game) {
                        const touch = e.changedTouches[0];
                        const { x, y } = getGameCoordinates(touch.clientX, touch.clientY);
                        game.handleCanvasClick(x, y);
                    }
                });

                window.onkeydown = (event) => {
                    if (event.key === 'Escape' && game) { 
                        game.closeMenu(); 
                        game.activeAbility = null; 
                    }
                };

                // --- DEV TOOLS LISTENERS ---
                devToolsButton.addEventListener('click', () => {
                    devToolsModal.style.display = 'flex';
                    game.pauseGame();
                });

                document.getElementById('close-dev-tools-x').addEventListener('click', () => {
                    devToolsModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                });

                document.getElementById('dev-resources').addEventListener('click', (e) => {
                    cheats.unlimitedResources = !cheats.unlimitedResources;
                    e.target.classList.toggle('active', cheats.unlimitedResources);
                    if (cheats.unlimitedResources) {
                        game.gold = 999999;
                        game.diamonds = 9999;
                        game.updateUI();
                    }
                });
                document.getElementById('dev-health').addEventListener('click', (e) => {
                    cheats.unlimitedHealth = !cheats.unlimitedHealth;
                    e.target.classList.toggle('active', cheats.unlimitedHealth);
                });
                document.getElementById('dev-cooldowns').addEventListener('click', (e) => {
                    cheats.noCooldowns = !cheats.noCooldowns;
                    e.target.classList.toggle('active', cheats.noCooldowns);
                });
                document.getElementById('dev-exit').addEventListener('click', () => {
                    isDeveloperMode = false;
                    Object.keys(cheats).forEach(k => cheats[k] = false);
                    document.querySelectorAll('.dev-options .modal-button').forEach(b => b.classList.remove('active'));
                    devToolsButton.style.display = 'none';
                    devToolsModal.style.display = 'none';
                    game.resumeGame();
                });
            }

            function actuallyLaunchGame(mapId, savedData, difficulty) {
                stopMainMenuAnimation();
                stopMenuMusic();
                document.body.style.backgroundColor = 'var(--primary-bg)';
                
                function setBodyTheme(themeName) {
                    document.body.classList.remove('theme-classic', 'theme-serpentine', 'theme-crossroads', 'theme-direct');
                    if (themeName) {
                        document.body.classList.add(`theme-${themeName}`);
                    }
                }
                setBodyTheme(mapId || 'direct');

                mapSelectionScreen.style.display = 'none';
                playOptionsModal.style.display = 'none';
                mainMenuScreen.style.display = 'none';
                gameUiContainer.style.display = 'flex';
                
                game = new Game(canvas, mapId, savedData, false, difficulty);
                generateImages();
                setupGameListeners();
                playMusic();
                
                setTimeout(resizeHandler, 0);
            }

            function showHardModeInfoModal(callback) {
                hardModeInfoModal.style.display = 'flex';
                closeHardModeInfoButton.onclick = () => {
                    if (hideHardModeInfoCheckbox.checked) {
                        localStorage.setItem('hideHardModeInfo', 'true');
                    }
                    hardModeInfoModal.style.display = 'none';
                    callback();
                };
            }

            function launchGame(mapId, savedData = null) {
                const difficulty = savedData && savedData.difficulty ? savedData.difficulty : selectedDifficulty;

                if (!savedData && difficulty === 'hard' && !localStorage.getItem('hideHardModeInfo')) {
                    showHardModeInfoModal(() => actuallyLaunchGame(mapId, null, difficulty));
                } else {
                    actuallyLaunchGame(mapId, savedData, difficulty);
                }
            }

            function launchTutorial() {
                stopMainMenuAnimation();
                stopMenuMusic();
                document.body.style.backgroundColor = 'var(--primary-bg)';
                
                function setBodyTheme(themeName) {
                    document.body.classList.remove('theme-classic', 'theme-serpentine', 'theme-crossroads', 'theme-direct');
                    if (themeName) {
                        document.body.classList.add(`theme-${themeName}`);
                    }
                }
                setBodyTheme('classic');

                mainMenuScreen.style.display = 'none';
                gameUiContainer.style.display = 'flex';
                game = new Game(canvas, 'classic', null, true);
                generateImages();
                setupGameListeners();
                playMusic();
                
                setTimeout(() => {
                    resizeHandler();
                    game.tutorialManager.start();
                }, 0);
            }


            // --- Event Listeners del Menú Principal ---
            playButton.addEventListener('click', () => {
                const savedGame = localStorage.getItem('towerDefenseProgress');
                if (savedGame) {
                    playOptionsModal.style.display = 'flex';
                } else {
                     if (!localStorage.getItem('hideTutorialPrompt')) {
                        tutorialPromptModal.style.display = 'flex';
                    } else {
                        mainMenuScreen.style.display = 'none';
                        difficultyModal.style.display = 'flex';
                        resizeHandler();
                    }
                }
            });

            difficultyButton.addEventListener('click', () => {
                mainMenuScreen.style.display = 'none';
                difficultyModal.style.display = 'flex';
                resizeHandler();
            });

            document.querySelectorAll('.difficulty-select-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    selectedDifficulty = e.target.dataset.difficulty;
                    difficultyModal.style.display = 'none';
                    mapSelectionScreen.style.display = 'flex';
                    resizeHandler();
                });
            });

            continueButton.addEventListener('click', () => {
                 const savedGameData = JSON.parse(localStorage.getItem('towerDefenseProgress'));
                 if (savedGameData) {
                    launchGame(savedGameData.mapId, savedGameData);
                 }
            });
            
            newGameButton.addEventListener('click', () => {
                localStorage.removeItem('towerDefenseProgress');
                playOptionsModal.style.display = 'none';
                mainMenuScreen.style.display = 'none';
                difficultyModal.style.display = 'flex';
                resizeHandler();
            });

            playOptionsModal.querySelector('.modal-close-button').addEventListener('click', () => {
                playOptionsModal.style.display = 'none';
            });


            tutorialButton.addEventListener('click', launchTutorial);
            
            exitButton.addEventListener('click', () => {
                window.close();
            });

            playAgainButton.addEventListener('click', () => window.location.reload());

            // --- Event Listeners del Modal de Pregunta del Tutorial ---
            document.getElementById('play-tutorial-button').addEventListener('click', () => {
                if (document.getElementById('hide-tutorial-prompt-checkbox').checked) {
                    localStorage.setItem('hideTutorialPrompt', 'true');
                }
                tutorialPromptModal.style.display = 'none';
                launchTutorial();
            });

            document.getElementById('skip-tutorial-button').addEventListener('click', () => {
                if (document.getElementById('hide-tutorial-prompt-checkbox').checked) {
                    localStorage.setItem('hideTutorialPrompt', 'true');
                }
                tutorialPromptModal.style.display = 'none';
                mainMenuScreen.style.display = 'none';
                difficultyModal.style.display = 'flex';
                resizeHandler();
            });

            // --- Lógica de Escalado General ---
            function resizeHandler() {
                // Escalar el juego si está visible
                if (window.getComputedStyle(gameUiContainer).display !== 'none' && game) {
                    const nativeWidth = 800 + 240 + 4;
                    const nativeHeight = 520 + document.getElementById('top-bar').offsetHeight;
                    game.scale = Math.min(window.innerWidth / nativeWidth, window.innerHeight / nativeHeight);
                    gameUiContainer.style.transform = `scale(${game.scale})`;
                    if (game.isTutorial && game.tutorialManager && game.tutorialManager.steps && game.tutorialManager.currentStep >= 0 && game.tutorialManager.currentStep < game.tutorialManager.steps.length) {
                        game.tutorialManager.highlightElement(game.tutorialManager.steps[game.tutorialManager.currentStep].highlightTarget());
                    }
                }

                // Escalar el menú o la pantalla de mapas si están visibles
                document.querySelectorAll('.screen').forEach(screen => {
                    if (window.getComputedStyle(screen).display !== 'none') {
                        const scale = Math.min(window.innerWidth / screen.offsetWidth, window.innerHeight / screen.offsetHeight, 1.2);
                        screen.style.transform = `scale(${scale})`;
                    }
                });

                // Escalar modales abiertos
                [arsenalModal, bestiaryModal, playOptionsModal, tutorialPromptModal, powersModal, devToolsModal, difficultyModal, masteryUnlockModal, hardModeInfoModal].forEach(modal => {
                    const modalContent = modal.querySelector('.modal-content');
                    if(window.getComputedStyle(modal).display !== 'none'){
                        const modalScale = Math.min( (window.innerWidth / modalContent.offsetWidth) * 0.8, (window.innerHeight / modalContent.offsetHeight) * 0.8, 1);
                        modalContent.style.transform = `scale(${modalScale})`;
                    }
                });
            }

            window.addEventListener('resize', resizeHandler);
            
            // Llamada inicial para escalar el menú principal
            resizeHandler();


            function getGameCoordinates(clientX, clientY) {
                if (!game) return {x: 0, y: 0};
                const rect = canvas.getBoundingClientRect();
                const xOnScaledCanvas = clientX - rect.left;
                const yOnScaledCanvas = clientY - rect.top;
                const xOnNativeCanvas = xOnScaledCanvas / game.scale;
                const yOnNativeCanvas = yOnScaledCanvas / game.scale;
                
                return { x: xOnNativeCanvas, y: yOnNativeCanvas };
            }

            const TOWER_IMAGES = {};
            const ENEMY_IMAGES = {};

            function generateImages() {
                for (const type in TOWER_TYPES) {
                    const info = TOWER_TYPES[type];
                    const tempCanvas = document.createElement('canvas'); tempCanvas.width = 50; tempCanvas.height = 50;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.fillStyle = '#555'; tempCtx.beginPath(); tempCtx.arc(25, 25, 23, 0, Math.PI * 2); tempCtx.fill();
                    tempCtx.font = '35px sans-serif';
                    tempCtx.textAlign = 'center';
                    tempCtx.textBaseline = 'middle';
                    tempCtx.fillText(info.emoji, 25, 25);
                    TOWER_IMAGES[type] = tempCanvas.toDataURL();
                }
                for (const type in ENEMY_TYPES) {
                    const info = ENEMY_TYPES[type];
                    const tempCanvas = document.createElement('canvas'); tempCanvas.width = 50; tempCanvas.height = 50;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.fillStyle = info.color;
                    tempCtx.fillRect(25 - (TILE_SIZE * info.size / 2), 25 - (TILE_SIZE * info.size / 2), TILE_SIZE * info.size, TILE_SIZE * info.size);
                    ENEMY_IMAGES[type] = tempCanvas.toDataURL();
                }
            }

            function updateArsenalModal() {
                const container = document.getElementById('arsenal-cards-container');
                container.innerHTML = ''; 

                for (const type in game.towerTypes) {
                    const towerInfo = game.towerTypes[type];
                    const card = document.createElement('div');
                    card.className = 'info-card';

                    if (game && game.unlockedTowers.has(type)) {
                        const saleValue = Math.floor(towerInfo.cost * 0.7);
                        let html = `
                            <div class="info-card-header">
                                <img class="visual" src="${TOWER_IMAGES[type]}" alt="${towerInfo.name}">
                                <h4>${towerInfo.name}</h4>
                            </div>
                            <p>${towerInfo.desc}</p>
                            <p class="costs">Costo Base: ${towerInfo.cost} | Venta: ${saleValue}</p>
                        `;

                        if (towerInfo.evolutions) {
                            html += `<hr style="border-color: #555; margin: 10px 0;"><h5>Evoluciones (Nivel 8):</h5>`;
                            for (const pathKey in towerInfo.evolutions.paths) {
                                const evo = towerInfo.evolutions.paths[pathKey];
                                html += `<p><strong>${evo.emoji} ${evo.name}:</strong> ${evo.desc}</p>`;
                            }
                        }
                        card.innerHTML = html;

                    } else {
                        card.classList.add('locked');
                        card.innerHTML = `<span>?</span>`;
                    }
                    container.appendChild(card);
                }
            }
            
            function updateBestiaryModal() {
                const container = document.getElementById('bestiary-cards-container');
                container.innerHTML = '';

                for (const type in ENEMY_TYPES) {
                    const enemyInfo = ENEMY_TYPES[type];
                    const card = document.createElement('div');
                    card.className = 'info-card';

                    if (game && game.discoveredEnemies.has(type)) {
                        card.innerHTML = `
                            <div class="info-card-header">
                                <img class="visual" src="${ENEMY_IMAGES[type]}" alt="${enemyInfo.name}">
                                <h4>${enemyInfo.name}</h4>
                            </div>
                            <p>${enemyInfo.desc}</p>
                        `;
                    } else {
                        card.classList.add('locked');
                        card.innerHTML = `<span>?</span>`;
                    }
                    container.appendChild(card);
                }
            }
            
            function updatePowersModal() {
                const container = document.getElementById('powers-cards-container');
                container.innerHTML = '';
                for (const key in ABILITIES) {
                    const ability = ABILITIES[key];
                    const name = key === 'meteor' ? 'Meteorito' : 'Fiebre de Oro';
                    const desc = key === 'meteor' ? 'Invoca un meteorito del cielo que inflige daño masivo en un área. Ideal para eliminar grupos grandes o jefes.' : 'Duplica temporalmente todo el oro ganado al derrotar enemigos. ¡Úsalo antes de una oleada grande para maximizar tus ganancias!';
                    
                    const card = document.createElement('div');
                    card.className = 'info-card';
                    card.innerHTML = `
                        <h4>${name}</h4>
                        <p>${desc}</p>
                        <p class="costs">Costo: ${ability.cost} 💎</p>
                    `;
                    container.appendChild(card);
                }
            }

            function toggleFullScreen() {
                const elem = document.documentElement;
                if (!document.fullscreenElement) {
                    if (elem.requestFullscreen) {
                        elem.requestFullscreen();
                    } else if (elem.webkitRequestFullscreen) { /* Safari */
                        elem.webkitRequestFullscreen();
                    }
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            }

            function isTouchDevice() {
                return (('ontouchstart' in window) || (navigator.maxTouchPoints > 0));
            }

            function isIphone() {
                return /iPhone|iPad|iPod/i.test(navigator.userAgent);
            }


            if (isTouchDevice()) {
                document.body.classList.add('is-touch');
            }
            if (isIphone()) {
                document.body.classList.add('is-iphone');
            }

            // --- Lógica de Música y Volumen ---
            const bgm = document.getElementById('bgm');
            const menuBgm = document.getElementById('menu-bgm');
            const volumeButton = document.getElementById('volume-button');
            const volumeSlider = document.getElementById('volume-slider');
            const menuVolumeButton = document.getElementById('menu-volume-button');
            const menuVolumeSlider = document.getElementById('menu-volume-slider');
            let isMuted = false;
            
            const masterVolume = new Tone.Volume(0).toDestination();
            const uiClickSound = new Tone.Synth({
                oscillator: { type: 'sine' },
                envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 0.1 }
            }).connect(masterVolume);

            const playClickSound = () => {
                if (Tone.context.state !== 'running') {
                    Tone.start();
                }
                uiClickSound.triggerAttackRelease("G5", "32n");
            };

            document.querySelectorAll('button').forEach(button => {
                button.addEventListener('click', playClickSound);
            });


            function initMusic() {
                const savedVolume = localStorage.getItem('td_volume');
                const savedMute = localStorage.getItem('td_muted') === 'true';

                const volume = savedVolume !== null ? parseFloat(savedVolume) : 0.25; // Default 25%
                isMuted = savedMute;
                
                const toDecibels = (value) => {
                    return value === 0 ? -Infinity : Tone.gainToDb(value);
                };

                bgm.volume = volume;
                menuBgm.volume = volume;
                masterVolume.volume.value = toDecibels(volume);
                volumeSlider.value = volume;
                menuVolumeSlider.value = volume;
                
                if (isMuted) {
                    bgm.muted = true;
                    menuBgm.muted = true;
                    masterVolume.mute = true;
                    volumeButton.textContent = '🔇';
                    menuVolumeButton.textContent = '🔇';
                } else {
                    updateVolumeIcon(volume, volumeButton);
                    updateVolumeIcon(volume, menuVolumeButton);
                }

                volumeButton.addEventListener('click', () => {
                    volumeSlider.classList.toggle('hidden');
                });
                 menuVolumeButton.addEventListener('click', () => {
                    menuVolumeSlider.classList.toggle('hidden');
                });

                function handleVolumeChange(e) {
                    const newVolume = parseFloat(e.target.value);
                    bgm.volume = newVolume;
                    menuBgm.volume = newVolume;
                    if (menuMusicPlayer) {
                         menuMusicPlayer.volume.value = toDecibels(newVolume);
                    }
                    masterVolume.volume.value = toDecibels(newVolume);
                    
                    isMuted = newVolume === 0;
                    bgm.muted = isMuted;
                    menuBgm.muted = isMuted;
                    if(menuMusicPlayer) menuMusicPlayer.mute = isMuted;
                    masterVolume.mute = isMuted;

                    localStorage.setItem('td_volume', newVolume);
                    localStorage.setItem('td_muted', isMuted);

                    volumeSlider.value = newVolume;
                    menuVolumeSlider.value = newVolume;
                    updateVolumeIcon(newVolume, volumeButton);
                    updateVolumeIcon(newVolume, menuVolumeButton);
                }

                volumeSlider.addEventListener('input', handleVolumeChange);
                menuVolumeSlider.addEventListener('input', handleVolumeChange);
            }
            
            function updateVolumeIcon(volume, button) {
                if (isMuted || volume === 0) {
                    button.textContent = '🔇';
                } else if (volume < 0.5) {
                    button.textContent = '🔉';
                } else {
                    button.textContent = '🔊';
                }
            }

            async function playMusic() {
                try {
                    await Tone.start();
                    await bgm.play();
                } catch(e) {
                    console.warn("La reproducción de audio del juego fue bloqueada por el navegador.");
                }
            }

            function stopMusic() {
                bgm.pause();
                bgm.currentTime = 0;
            }
            
            async function playMenuMusic() {
                if (menuMusicPlayer) return; 
                try {
                    await Tone.start();
                    const initialVolume = parseFloat(localStorage.getItem('td_volume') || 0.25);
                    const initialMute = localStorage.getItem('td_muted') === 'true';
                    const dbVolume = initialVolume === 0 ? -Infinity : Tone.gainToDb(initialVolume);

                    menuMusicPlayer = new Tone.Player({
                        url: "Music/BGM/silent-shadows-376165.mp3",
                        loop: true,
                        autostart: true,
                        volume: dbVolume,
                        mute: initialMute
                    }).toDestination();
                    
                    menuMusicAnalyser = new Tone.Analyser('waveform', 128);
                    menuMusicPlayer.connect(menuMusicAnalyser);

                } catch(e) {
                    console.warn("La reproducción de audio del menú fue bloqueada por el navegador.", e);
                }
            }

            function stopMenuMusic() {
                if (menuMusicPlayer) {
                    menuMusicPlayer.stop();
                    menuMusicPlayer.dispose();
                    menuMusicPlayer = null;
                    menuMusicAnalyser = null;
                }
            }
            
            initMusic();
            setupMainMenu();
            playMenuMusic();


            document.querySelectorAll('.map-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const mapId = e.target.dataset.map;
                    launchGame(mapId, null);
                });
            });
        });
    </script>
</body>
</html>
