<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense Progresivo</title>

    <!-- Meta tags for iOS Web App -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TD Progresivo">
    <!-- Para un √≠cono personalizado, necesitar√≠as subir una imagen y enlazarla aqu√≠ -->
    <!-- <link rel="apple-touch-icon" href="icon.png"> -->

    <!-- BIBLIOTECA DE SONIDO A√ëADIDA -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }
        .screen {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            background-color: #2c2c2c;
            padding: 40px;
            border-radius: 10px;
            border: 2px solid #444;
            position: relative; /* A√±adido para posicionar la versi√≥n */
        }
        .screen h1 {
            margin: 0 0 20px 0;
            color: #00ff87;
        }
        #main-menu-screen {
            display: flex;
        }
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 250px;
        }
        .menu-button {
            padding: 15px 30px;
            font-size: 1.3em;
            font-weight: bold;
            background-color: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }
        .menu-button:hover:not(:disabled) {
            background-color: #00ff87;
            color: #1a1a1a;
            transform: scale(1.05);
        }
        .menu-button:disabled {
            background-color: #222;
            color: #555;
            cursor: not-allowed;
        }
        #map-selection-screen h1 {
            margin: 0 0 20px 0;
            color: #00ff87;
        }
        .map-selection-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        .map-button {
            padding: 20px 40px;
            font-size: 1.2em;
            font-weight: bold;
            background-color: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }
        .map-button:hover {
            background-color: #00ff87;
            color: #1a1a1a;
            transform: scale(1.05);
        }
        #game-ui-container {
            display: none;
            flex-direction: column;
            border: 2px solid #444;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            background-color: #2c2c2c;
            transform-origin: center center;
        }
        #top-bar {
            display: flex;
            flex-direction: column; /* Cambiado a columna para dos filas */
            padding: 5px 15px;
            background-color: #252525;
            border-bottom: 2px solid #444;
        }
        .top-bar-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        .ui-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .stat {
            font-size: 1.1em;
            font-weight: bold;
            transition: color 0.3s ease, text-shadow 0.3s ease;
        }
        .stat-icon {
            font-size: 1.3em;
        }
        #gold-stat.gold-rush-active {
            color: #FFD700;
            text-shadow: 0 0 8px #FFD700;
        }
        #base-health-bar-container {
            width: 150px;
            height: 18px;
            background-color: #444;
            border-radius: 9px;
            overflow: hidden;
        }
        #base-health-bar {
            height: 100%;
            background-color: #f44336;
            transition: width 0.3s ease;
        }
        .control-button, #wave-button, .ability-button, .modal-button, .side-panel-button {
            padding: 8px 12px;
            color: white;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            background-color: #333;
            transition: background-color 0.3s;
            position: relative;
            font-size: 0.9em;
        }
        .control-button:hover, #wave-button:hover:not(:disabled), .ability-button:hover:not(:disabled), .modal-button:hover, .side-panel-button:hover {
            background-color: #454545;
        }
        .side-panel-button {
             width: 100%;
        }
        #arsenal-button {
            background-color: #00796B;
        }
        #arsenal-button:hover {
            background-color: #004D40;
        }
        #bestiary-button {
            background-color: #C2185B;
        }
        #bestiary-button:hover {
            background-color: #880E4F;
        }
        #powers-button {
            background-color: #FFC107;
        }
        #powers-button:hover {
            background-color: #FFA000;
        }
        .control-button.active {
            background-color: #00ff87;
            color: #1a1a1a;
            font-weight: bold;
            border-color: #00ff87;
        }
        #wave-button {
            background-color: #f44336;
            font-weight: bold;
        }
        #wave-button:hover:not(:disabled) { background-color: #d32f2f; }
        #wave-button:disabled { background-color: #555; color: #888; cursor: not-allowed; }
        .ability-button {
            background-color: #9C27B0;
        }
        .ability-button:hover:not(:disabled) { background-color: #7B1FA2; }
        .ability-button:disabled { background-color: #555; color: #888; cursor: not-allowed; }
        .gem-cost {
            font-size: 0.8em;
            color: #B2EBF2; /* Light cyan to represent gems */
            font-weight: bold;
            margin-left: 5px;
        }
        .cooldown-text {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2em; color: rgba(255, 255, 255, 0.8);
            font-weight: bold; text-shadow: 1px 1px 3px black;
        }
        canvas {
            display: block;
            cursor: default;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #game-wrapper { position: relative; }
        #screen-flash, #gold-rush-effect {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            opacity: 0;
            z-index: 999; pointer-events: none;
        }
        #screen-flash { background-color: red; }
        #gold-rush-effect {
            box-shadow: inset 0 0 25px 10px gold;
            border-radius: 8px;
            transition: opacity 0.5s ease-in-out;
        }
        #gold-rush-effect.active {
            opacity: 0.7;
        }
        .modal {
            display: none; position: fixed; z-index: 1000;
            left: 0; top: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7);
            justify-content: center; align-items: center;
        }
        .modal-content {
            background-color: #2c2c2c; padding: 30px;
            border-radius: 10px;
            text-align: center; color: white;
            position: relative;
            transform-origin: center center;
            max-height: 90vh; /* L√≠mite de altura para responsividad */
            overflow-y: auto; /* Scroll si el contenido es muy alto */
        }
        .game-over-content { border: 2px solid #f44336; }
        .victory-content { border: 2px solid #00ff87; }
        .modal-content h2 { margin-top: 0; }
        .game-over-content h2 { color: #f44336; }
        .victory-content h2 { color: #00ff87; }
        
        #rotate-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #1a1a1a;
            color: #fff;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 2000;
            font-size: 1.5em;
        }

        #main-content {
            display: flex;
        }

        #side-panel {
            width: 240px;
            padding: 15px;
            background-color: #252525;
            border-left: 2px solid #444;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        #game-explanation-bar p {
            margin: 0;
            font-size: 0.85em;
            color: #ccc;
            line-height: 1.4;
        }
        #game-explanation-bar p strong {
            color: #00ff87;
        }

        /* --- ESTILOS DE MODALES --- */
        #arsenal-modal .modal-content, #bestiary-modal .modal-content, #powers-modal .modal-content {
            width: 80vw;
            max-width: 900px;
        }
        #arsenal-modal .modal-content { border: 2px solid #00ff87; }
        #bestiary-modal .modal-content { border: 2px solid #C2185B; }
        #powers-modal .modal-content { border: 2px solid #FFC107; }
        #arsenal-modal h2 { color: #00ff87; }
        #bestiary-modal h2 { color: #C2185B; }
        #powers-modal h2 { color: #FFC107; }
        .modal-close-button {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.5em;
            color: #fff;
            background: none;
            border: none;
            cursor: pointer;
        }
        #arsenal-cards-container, #bestiary-cards-container, #powers-cards-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
            margin-bottom: 20px;
        }
        .info-card {
            background-color: #333;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 15px;
            text-align: left;
        }
        .info-card.locked {
            background-color: #222;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 4em;
            color: #444;
        }
        .info-card-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .info-card-header .visual {
            width: 50px;
            height: 50px;
            background-color: #444;
            border-radius: 5px;
        }
        .info-card-header h4 {
            margin: 0;
            font-size: 1.1em;
        }
        .info-card p {
            font-size: 0.9em;
            color: #ccc;
            margin: 5px 0;
        }
        .info-card .costs {
            font-size: 0.8em;
            color: #aaa;
        }
        
        /* --- ESTILOS DEL MODAL DE DESBLOQUEO --- */
        #meteor-unlock-modal .modal-content {
            border: 2px solid #FFC107;
        }
        #meteor-unlock-modal h2 {
            color: #FFC107;
        }
        .dont-show-again {
            margin-top: 20px;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .button-wrapper {
            position: relative;
        }
        .button-flash {
            display: none;
            position: absolute;
            top: -5px; left: -5px; right: -5px; bottom: -5px;
            border-radius: 8px;
            box-shadow: 0 0 15px 5px #FFC107;
            animation: flash 1s infinite;
            z-index: -1;
        }
        .button-flash.flashing {
            display: block;
        }
        @keyframes flash {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
        /* --- FIN DE ESTILOS DEL MODAL --- */

        /* --- ESTILOS BOT√ìN PANTALLA COMPLETA --- */
        #fullscreen-button {
            display: none;
            background-color: #3F51B5;
        }
        #fullscreen-button:hover {
            background-color: #303F9F;
        }
        body.is-touch #fullscreen-button {
            display: block;
        }
        #fullscreen-helper {
            display: none;
            font-size: 0.75em;
            color: #aaa;
            text-align: center;
            margin-top: -15px;
        }
        body.is-iphone #fullscreen-helper {
            display: block;
        }
        /* --- FIN DE ESTILOS --- */

        /* --- ESTILOS DEL TUTORIAL INTERACTIVO --- */
        #tutorial-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1001;
            pointer-events: none; /* Permite clics a trav√©s del overlay */
        }
        #tutorial-highlight {
            position: absolute;
            border: 3px dashed #FFD700;
            border-radius: 8px;
            box-shadow: 0 0 20px #FFD700;
            transition: all 0.3s ease;
            pointer-events: none; /* FIX: No debe capturar eventos de rat√≥n */
        }
        #tutorial-message-box {
            position: absolute;
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #FFD700;
            max-width: 300px;
            font-size: 1.1em;
            line-height: 1.5;
            pointer-events: all; /* La caja de mensaje es interactiva */
        }
        .clickable {
            pointer-events: all !important;
        }
        /* --- FIN DE ESTILOS DEL TUTORIAL --- */

        /* --- VERSI√ìN DEL JUEGO --- */
        #version-display {
            position: absolute;
            bottom: 15px;
            left: 15px;
            font-size: 0.9em;
            color: #888;
        }
        /* --- FIN DE ESTILOS --- */

        @media (orientation: portrait) {
            #game-ui-container, #map-selection-screen, #game-over-modal, #victory-modal, #main-menu-screen {
                display: none !important;
            }
            #rotate-screen {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <div id="rotate-screen">
        <p>Por favor, rota tu dispositivo para jugar.</p>
        <p>Juego dise√±ado para modo horizontal.</p>
    </div>

    <div id="main-menu-screen" class="screen">
        <h1>Tower Defense Progresivo</h1>
        <div class="menu-buttons">
            <button id="play-button" class="menu-button">Jugar</button>
            <button id="game-mode-button" class="menu-button" disabled>Modo de Juego</button>
            <button id="tutorial-button" class="menu-button">Tutorial</button>
            <button id="exit-button" class="menu-button">Salir</button>
        </div>
        <div id="version-display">v1.0.5</div>
    </div>

    <div id="map-selection-screen" class="screen">
        <h1>Selecciona un Mapa</h1>
        <div class="map-selection-buttons">
            <button class="map-button" data-map="classic">El Sendero Cl√°sico</button>
            <button class="map-button" data-map="serpentine">Ca√±√≥n Serpenteante</button>
            <button class="map-button" data-map="crossroads">Encrucijada Mortal</button>
            <button class="map-button" data-map="direct">Asalto Directo</button>
        </div>
    </div>

    <div id="game-ui-container">
        <div id="top-bar">
            <div class="top-bar-row">
                <div class="ui-group">
                    <span class="stat stat-icon">‚ù§Ô∏è</span>
                    <div id="base-health-bar-container"><div id="base-health-bar"></div></div>
                    <span id="base-health-stat" class="stat">100/100</span>
                </div>
                <div class="ui-group">
                     <span id="player-level-stat" class="stat">Nivel 1</span>
                </div>
            </div>
            <div class="top-bar-row">
                 <div class="ui-group">
                    <span id="gold-stat" class="stat">  200</span>
                    <span id="diamonds-stat" class="stat">üíé 5</span>
                </div>
                <div class="ui-group">
                    <h3 style="margin:0;">Oleada <span id="wave-number">0</span></h3>
                    <button id="wave-button">Iniciar</button>
                </div>
                <div class="ui-group">
                    <div class="button-wrapper">
                        <button id="meteor-button" class="ability-button">Meteorito<span class="gem-cost"></span></button>
                        <div id="meteor-button-flash" class="button-flash"></div>
                    </div>
                    <button id="gold-rush-button" class="ability-button">Fiebre Oro<span class="gem-cost"></span></button>
                    <button id="pause-button" class="control-button">Pausa</button>
                    <button id="speed-1x-button" class="control-button active">1x</button>
                    <button id="speed-2x-button" class="control-button">2x</button>
                    <button id="speed-5x-button" class="control-button">5x</button>
                </div>
            </div>
        </div>

        <div id="main-content">
            <div id="game-wrapper">
                <div id="screen-flash"></div>
                <div id="gold-rush-effect"></div>
                <canvas id="gameCanvas" width="800" height="520"></canvas>
            </div>

            <div id="side-panel">
                <button id="arsenal-button" class="side-panel-button">Arsenal de Torres</button>
                <button id="bestiary-button" class="side-panel-button">Bestiario</button>
                <button id="powers-button" class="side-panel-button">Poderes</button>
                <button id="fullscreen-button" class="side-panel-button">Pantalla Completa</button>
                <div id="fullscreen-helper">(En iPhone, usa Compartir > A√±adir a pantalla de inicio)</div>
                <div id="game-explanation-bar">
                    <p><strong>Objetivo:</strong> ¬°Sobrevive a las oleadas! Construye y mejora torres para defender tu base. Gana oro y XP para desbloquear m√°s poder.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- MODALES -->
    <div id="play-options-modal" class="modal">
        <div class="modal-content">
            <h2>Jugar</h2>
            <div class="menu-buttons">
                <button id="continue-button" class="menu-button">Continuar</button>
                <button id="new-game-button" class="menu-button">Nueva Partida</button>
            </div>
            <button class="modal-close-button" style="top: 15px; right: 20px;">&times;</button>
        </div>
    </div>

    <div id="tutorial-prompt-modal" class="modal">
        <div class="modal-content">
            <h2>¬°Bienvenido!</h2>
            <p>Parece que es tu primera vez. ¬øTe gustar√≠a ver el tutorial primero?</p>
            <div class="dont-show-again">
                <input type="checkbox" id="hide-tutorial-prompt-checkbox">
                <label for="hide-tutorial-prompt-checkbox">No volver a mostrar</label>
            </div>
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
                <button id="play-tutorial-button" class="modal-button">Jugar Tutorial</button>
                <button id="skip-tutorial-button" class="modal-button">Saltar</button>
            </div>
        </div>
    </div>

    <div id="game-over-modal" class="modal">
        <div class="modal-content game-over-content">
            <h2>Fin del Juego</h2>
            <p>Tu base ha sido destruida.</p>
            <p>Alcanzaste la oleada <span id="final-wave-stat"></span>.</p>
            <button class="modal-button" onclick="window.location.reload()">Jugar de Nuevo</button>
        </div>
    </div>

    <div id="victory-modal" class="modal">
        <div class="modal-content victory-content">
            <h2>¬°VICTORIA!</h2>
            <p>¬°Has superado el desaf√≠o principal al completar la oleada 25!</p>
            <p>¬øTe atreves a continuar en el modo infinito?</p>
            <button id="continue-endless-button" class="modal-button">Continuar (Modo Infinito)</button>
        </div>
    </div>

    <div id="arsenal-modal" class="modal">
        <div class="modal-content">
            <button id="close-arsenal-x" class="modal-close-button">&times;</button>
            <h2>Arsenal de Torres</h2>
            <div id="arsenal-cards-container"></div>
            <button id="close-arsenal-button" class="modal-button">Cerrar</button>
        </div>
    </div>

    <div id="bestiary-modal" class="modal">
        <div class="modal-content">
            <button id="close-bestiary-x" class="modal-close-button">&times;</button>
            <h2>Bestiario</h2>
            <div id="bestiary-cards-container"></div>
            <button id="close-bestiary-button" class="modal-button">Cerrar</button>
        </div>
    </div>

    <div id="powers-modal" class="modal">
        <div class="modal-content">
            <button id="close-powers-x" class="modal-close-button">&times;</button>
            <h2>Poderes Especiales</h2>
            <div id="powers-cards-container"></div>
            <button id="close-powers-button" class="modal-button">Cerrar</button>
        </div>
    </div>

    <div id="meteor-unlock-modal" class="modal">
        <div class="modal-content">
            <h2>¬°Habilidad Desbloqueada!</h2>
            <p>¬°Has alcanzado la oleada 3 y desbloqueado el <strong>Meteorito</strong>!</p>
            <p>√ösalo para infligir da√±o masivo en un √°rea. ¬°Ideal contra jefes y grupos grandes!</p>
            <div class="dont-show-again">
                <input type="checkbox" id="hide-meteor-checkbox">
                <label for="hide-meteor-checkbox">No volver a mostrar</label>
            </div>
            <button id="close-meteor-unlock-button" class="modal-button" style="margin-top: 20px;">Entendido</button>
        </div>
    </div>

    <!-- Elementos del Tutorial Interactivo -->
    <div id="tutorial-overlay">
        <div id="tutorial-highlight"></div>
        <div id="tutorial-message-box">
            <p id="tutorial-message-text"></p>
            <button id="tutorial-next-step-button" class="modal-button" style="margin-top: 10px; display: none;">Entendido</button>
        </div>
    </div>


    <script>
        // --- CONFIGURACI√ìN DEL JUEGO ---
        const TILE_SIZE = 40;
        const MAPS = {
            'classic': [ { x: 0, y: 5 }, { x: 3, y: 5 }, { x: 3, y: 2 }, { x: 8, y: 2 }, { x: 8, y: 12 }, { x: 13, y: 12 }, { x: 13, y: 7 }, { x: 20, y: 7 } ],
            'serpentine': [ { x: 0, y: 2 }, { x: 17, y: 2 }, { x: 17, y: 5 }, { x: 2, y: 5 }, { x: 2, y: 8 }, { x: 17, y: 8 }, { x: 17, y: 11 }, { x: 0, y: 11 } ],
            'crossroads': [ { x: 0, y: 7 }, { x: 4, y: 7 }, { x: 4, y: 2 }, { x: 15, y: 2 }, { x: 15, y: 7 }, { x: 10, y: 7 }, { x: 10, y: 12 }, { x: 15, y: 12 }, { x: 15, y: 7 }, { x: 20, y: 7 } ],
            'direct': [ { x: 0, y: 7 }, { x: 10, y: 7 }, { x: 10, y: 2 }, { x: 20, y: 2 } ]
        };
        const AIR_PATHS = {
            'classic': [ { x: 0, y: 5 }, { x: 8, y: 5 }, { x: 8, y: 7 }, { x: 20, y: 7 } ],
            'serpentine': [ { x: 0, y: 2 }, { x: 10, y: 6 }, { x: 0, y: 11 } ],
            'crossroads': [ { x: 0, y: 7 }, { x: 10, y: 2 }, { x: 10, y: 12 }, { x: 20, y: 7 } ],
            'direct': [ { x: 0, y: 7 }, { x: 20, y: 2 } ]
        };
        const TOWER_TYPES = {
            'arrow': { name: 'Flechas', desc: 'R√°pida y barata. La √∫nica defensa inicial contra enemigos a√©reos.', cost: 50, damage: 15, range: 100, fireRate: 60, projectileSpeed: 5, color: '#8BC34A', projectileColor: '#CDDC39', unlockLevel: 1, upgrade: { damage: 5, range: 10 }, canHitFlying: true },
            'cannon': { name: 'Ca√±√≥n', desc: 'Lenta pero poderosa. Su da√±o en √°rea es ideal contra grupos de enemigos terrestres.', cost: 120, damage: 40, range: 80, fireRate: 120, projectileSpeed: 4, color: '#607D8B', projectileColor: '#212121', unlockLevel: 2, splashRadius: 65, upgrade: { damage: 20, range: 5, splashRadius: 5 }, canHitFlying: false },
            'acid': { name: '√Åcido', desc: 'Aplica un veneno que da√±a con el tiempo. El da√±o del veneno escala con el da√±o de la torre.', cost: 100, damage: 8, range: 110, fireRate: 80, projectileSpeed: 5, color: '#7FFF00', projectileColor: '#ADFF2F', unlockLevel: 3, acid: { multiplier: 0.05, duration: 180 }, upgrade: { damage: 2, acidMultiplier: 0.02, range: 10 }, canHitFlying: true },
            'ice': { name: 'Hielo', desc: 'Aplica una ralentizaci√≥n en un √°rea que se vuelve m√°s potente con el da√±o. Mejorar el rango aumenta el √°rea de efecto.', cost: 150, damage: 5, range: 120, fireRate: 90, projectileSpeed: 6, color: '#03A9F4', projectileColor: '#B3E5FC', unlockLevel: 4, slow: { baseMultiplier: 0.6, damageScale: 0.002, maxSlow: 0.35 }, slowRadius: 15, upgrade: { damage: 3, range: 15, slowRadius: 5 }, canHitFlying: false }
        };
        const ENEMY_TYPES = {
            'standard': { name: 'Esbirro', desc: 'Unidad b√°sica terrestre. D√©bil pero numerosa.', health: 1, speed: 1, value: 1, color: '#E53935', size: 0.8, baseDamage: 10, isFlying: false },
            'fast': { name: 'Corredor', desc: 'R√°pido y peque√±o. Dif√≠cil de acertar para torres lentas.', health: 0.7, speed: 1.8, value: 1.2, color: '#FDD835', size: 0.6, baseDamage: 10, isFlying: false },
            'flying': { name: 'Espectro', desc: 'Ignora el camino y vuela directo a la base. Solo algunas torres pueden atacarlo.', health: 0.8, speed: 1.2, value: 1.5, color: '#E0E0E0', size: 0.7, baseDamage: 15, isFlying: true },
            'healer': { name: 'Sanador', desc: 'Cura a los aliados cercanos. ¬°Una prioridad alta!', health: 1.2, speed: 0.8, value: 3, color: '#FF80AB', size: 0.9, baseDamage: 5, isFlying: false, healRadius: 60, healAmount: 0.075, healRate: 60 },
            'disabler': { name: 'Disruptor', desc: 'Desactiva temporalmente las torres cercanas con un pulso electromagn√©tico.', health: 1.5, speed: 0.9, value: 4, color: '#D500F9', size: 0.9, baseDamage: 5, isFlying: false, disableRadius: 70, disableDuration: 180, disableRate: 120 },
            'boss': { name: 'Jefe', desc: 'Extremadamente resistente y peligroso. ¬°Prep√°rate bien!', health: 15, speed: 0.6, value: 20, color: '#6A1B9A', size: 1.5, baseDamage: 0.55, isFlying: false }
        };
        const ABILITIES = {
            meteor: { cost: 4, cooldown: (60 * 30) * 3, damage: (300 * 3.5) * 2, radius: 160 },
            goldRush: { cost: 2, cooldown: 60 * 45, duration: 60 * 8, multiplier: 2.8 }
        };

        class Game {
            constructor(canvas, mapId, savedData = null, isTutorial = false) {
                this.canvas = canvas; this.ctx = canvas.getContext('2d');
                this.width = canvas.width; this.height = canvas.height;
                this.mapId = mapId;
                this.isTutorial = isTutorial;
                this.tutorialManager = null;
                this.grid = []; 
                this.path = MAPS[mapId].map(p => ({ x: p.x * TILE_SIZE, y: p.y * TILE_SIZE }));
                this.airPath = AIR_PATHS[mapId].map(p => ({ x: p.x * TILE_SIZE, y: p.y * TILE_SIZE }));
                this.towers = []; this.enemies = []; this.projectiles = []; this.effects = []; 
                this.waveNumber = 0; this.gold = 200; this.diamonds = 5;
                this.playerLevel = 1; this.playerXp = 0; this.playerXpToNextLevel = 100;
                this.baseHealth = 100; this.maxBaseHealth = 100;
                this.waveInProgress = false;
                this.isPaused = false; this.gameSpeed = 1;
                this.speedBeforePause = 1;
                this.activeAbility = null;
                this.meteorCooldown = 0; this.goldRushCooldown = 0; this.goldRushTimer = 0;
                this.activeMenu = { isOpen: false, type: null, x: 0, y: 0, options: [], target: null };
                this.gameWon = false;
                this.selectedTower = null;
                this.frameCount = 0;
                this.discoveredEnemies = new Set();
                this.showPathArrows = true; // Para el indicador de camino

                this.camera = { x: 0, y: 0, scale: 1 };
                this.mousePos = { x: 0, y: 0 };
                this.scale = 1;

                this.createGridAndPath();

                if (savedData && savedData.towers) {
                    this.loadState(savedData);
                }

                if (this.isTutorial) {
                    this.tutorialManager = new TutorialManager(this);
                }

                this.init();
            }

            init() {
                this.updateUI(); 
                this.gameLoop();
            }
            
            gameLoop() {
                if (!this.isPaused) for (let i = 0; i < this.gameSpeed; i++) this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }

            update() {
                if (this.isTutorial && this.tutorialManager.isPaused) return;

                this.frameCount++;
                const cdMultiplier = this.waveNumber >= 25 ? 0.25 : 1;
                if(this.meteorCooldown > 0) this.meteorCooldown--;
                if(this.goldRushCooldown > 0) this.goldRushCooldown--;
                if(this.goldRushTimer > 0) {
                    this.goldRushTimer--;
                    if (this.goldRushTimer === 0) {
                        document.getElementById('gold-rush-effect').classList.remove('active');
                        document.getElementById('gold-stat').classList.remove('gold-rush-active');
                    }
                }
                this.updateAbilityButtons();

                if (!this.waveInProgress) return;

                this.enemies.forEach(e => e.update(this.enemies, this.towers)); 
                this.towers.forEach(t => t.update(this.enemies));
                this.projectiles.forEach(p => p.update()); this.effects.forEach(e => e.update());

                this.enemies = this.enemies.filter(e => e.active); this.projectiles = this.projectiles.filter(p => p.active); this.effects = this.effects.filter(e => e.active);

                if (this.waveInProgress && this.enemies.length === 0) {
                    this.waveInProgress = false;
                    this.diamonds += this.waveNumber >= 25 ? 3 : 1.2;
                    
                    if (this.isTutorial) {
                        this.tutorialManager.checkCondition('wave_cleared');
                    } else if (this.waveNumber === 25 && !this.gameWon) {
                        this.gameWon = true;
                        this.showVictoryScreen();
                    } else {
                        document.getElementById('wave-button').disabled = false;
                        this.pauseGame();
                    }
                    if (!this.isTutorial) this.saveState();
                    this.updateUI();
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                this.drawPath(); 
                this.drawGrid();

                if (this.showPathArrows) {
                    this.drawPathArrows();
                }
                
                if (this.selectedTower) {
                    this.ctx.beginPath();
                    this.ctx.arc(this.selectedTower.x, this.selectedTower.y, this.selectedTower.typeInfo.range, 0, Math.PI * 2);
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    this.ctx.fill();
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    this.ctx.stroke();
                }

                this.towers.forEach(t => t.draw(this.ctx, this.frameCount)); 
                this.enemies.forEach(e => e.draw(this.ctx, this.frameCount));
                this.projectiles.forEach(p => p.draw(this.ctx)); 
                this.effects.forEach(e => e.draw(this.ctx));
                
                if (this.activeMenu.isOpen) this.drawMenu();
                
                if (this.activeAbility === 'meteor' && this.mousePos) {
                    const rect = this.canvas.getBoundingClientRect();
                    const canvasX = (this.mousePos.x - rect.left) / this.scale;
                    const canvasY = (this.mousePos.y - rect.top) / this.scale;

                    this.ctx.beginPath(); this.ctx.arc(canvasX, canvasY, ABILITIES.meteor.radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = 'rgba(255, 0, 100, 0.3)'; this.ctx.fill();
                }
            }

            startWave() {
                if (this.waveInProgress) return;

                if (this.isTutorial) {
                    if (!this.tutorialManager.checkCondition('wave_started')) {
                        return; 
                    }
                } else {
                    this.resumeGame();
                }
                
                this.waveNumber++;
                if (this.waveNumber === 1) {
                    this.showPathArrows = false;
                }
                
                if (!this.isTutorial && this.waveNumber === 25) this.triggerWave25Alert();
                
                if (!this.isTutorial && this.waveNumber === 3 && !localStorage.getItem('hideMeteorUnlock')) {
                    this.showMeteorUnlockModal();
                }

                this.waveInProgress = true; document.getElementById('wave-button').disabled = true; 
                
                const waveConfig = this.isTutorial ? this.tutorialManager.getWaveConfig() : this.getWaveConfig(this.waveNumber);

                const baseHealth = 50 + this.waveNumber * 15; const baseValue = 10 + this.waveNumber * 2;
                waveConfig.forEach((conf, i) => {
                    this.discoveredEnemies.add(conf.type);
                    const spawnDelay = (conf.type === 'boss' && this.waveNumber >= 25) ? 180 : 60;
                    this.enemies.push(new Enemy(this, -i * spawnDelay, this.path[0].y, baseHealth, baseValue, conf.type));
                });
                this.updateUI();
            }
            
            showMeteorUnlockModal() {
                this.pauseGame();
                document.getElementById('meteor-unlock-modal').style.display = 'flex';
                const flashEl = document.getElementById('meteor-button-flash');
                flashEl.classList.add('flashing');
                setTimeout(() => {
                    flashEl.classList.remove('flashing');
                }, 5000);
            }

            getWaveConfig(waveNum) {
                if (waveNum > 25) {
                    let numBosses;
                    if (waveNum <= 27) numBosses = 1;
                    else numBosses = 2 + Math.floor((waveNum - 28) / 3);
                    return Array(numBosses).fill({ type: 'boss' });
                }
                if (waveNum === 25) return [{ type: 'boss' }, { type: 'boss' }, { type: 'boss' }, { type: 'boss' }];
                let config = [];
                if ([3, 7, 11, 15].includes(waveNum)) config.push({ type: 'boss' });
                const enemyCount = 5 + waveNum * 2;
                for (let i = 0; i < enemyCount; i++) {
                    let type = 'standard';
                    const rand = Math.random();
                    if (waveNum >= 12 && rand < 0.15) {
                        type = 'disabler';
                    } else if (waveNum >= 8 && rand < 0.25) {
                        type = 'healer';
                    } else if (waveNum >= 5 && rand < 0.35) {
                        type = 'flying';
                    } else if (waveNum >= 4 && rand < 0.45) {
                        type = 'fast';
                    }
                    config.push({ type });
                }
                return config;
            }
            
            togglePause() { 
                if (this.isTutorial) return;
                if (this.isPaused) {
                    this.resumeGame();
                } else {
                    this.pauseGame();
                }
            }
            pauseGame() { 
                if (!this.isPaused) {
                    this.speedBeforePause = this.gameSpeed;
                }
                this.isPaused = true; 
                document.getElementById('pause-button').textContent = 'Reanudar'; 
            }
            resumeGame() { 
                this.isPaused = false; 
                document.getElementById('pause-button').textContent = 'Pausa'; 
                this.setSpeed(this.speedBeforePause);
            }
            
            setSpeed(speed) { 
                if (this.isTutorial) return;
                this.gameSpeed = speed; 
                this.speedBeforePause = speed;
                document.getElementById('speed-1x-button').classList.toggle('active', speed === 1); 
                document.getElementById('speed-2x-button').classList.toggle('active', speed === 2);
                document.getElementById('speed-5x-button').classList.toggle('active', speed === 5);
            }

            triggerWave25Alert() {
                const flashEl = document.getElementById('screen-flash'); let count = 0;
                const interval = setInterval(() => {
                    flashEl.style.opacity = flashEl.style.opacity === '0.4' ? '0' : '0.4'; count++;
                    if (count >= 6) { clearInterval(interval); flashEl.style.opacity = '0'; }
                }, 250);
            }

            activateMeteor() {
                if (this.activeAbility === 'meteor') {
                    this.activeAbility = null;
                    this.canvas.style.cursor = 'default';
                    return;
                }
                if (this.diamonds >= ABILITIES.meteor.cost && this.meteorCooldown <= 0) {
                    this.activeAbility = 'meteor';
                    this.canvas.style.cursor = 'crosshair';
                    this.closeMenu();
                }
            }
            triggerMeteor(x, y) {
                const baseDamage = ABILITIES.meteor.damage;
                const finalDamage = baseDamage * (1 + (this.playerLevel - 1) * 0.25);

                this.diamonds -= ABILITIES.meteor.cost; 
                this.meteorCooldown = ABILITIES.meteor.cooldown * (this.waveNumber >= 25 ? 0.25 : 1); 
                this.activeAbility = null;
                this.canvas.style.cursor = 'default';
                this.effects.push(new MeteorEffect(this, x, y, ABILITIES.meteor.radius, finalDamage)); 
                this.updateUI();
            }
            activateGoldRush() {
                if (this.diamonds >= ABILITIES.goldRush.cost && this.goldRushCooldown <= 0) {
                    this.diamonds -= ABILITIES.goldRush.cost;
                    this.goldRushCooldown = ABILITIES.goldRush.cooldown * (this.waveNumber >= 25 ? 0.25 : 1);
                    this.goldRushTimer = ABILITIES.goldRush.duration;
                    document.getElementById('gold-rush-effect').classList.add('active');
                    document.getElementById('gold-stat').classList.add('gold-rush-active');
                    this.updateUI();
                }
            }
            
            createGridAndPath() {
                for (let y = 0; y < this.height / TILE_SIZE; y++) { this.grid[y] = []; for (let x = 0; x < this.width / TILE_SIZE; x++) this.grid[y][x] = { buildable: true, x: x, y: y }; }
                for (let i = 0; i < this.path.length - 1; i++) {
                    let s = this.path[i], e = this.path[i+1]; let sX = Math.floor(s.x/TILE_SIZE), sY = Math.floor(s.y/TILE_SIZE), eX = Math.floor(e.x/TILE_SIZE), eY = Math.floor(e.y/TILE_SIZE);
                    for (let x = Math.min(sX, eX); x <= Math.max(sX, eX); x++) for (let y = Math.min(sY, eY); y <= Math.max(sY, eY); y++) if (this.grid[y] && this.grid[y][x]) this.grid[y][x].buildable = false;
                }
            }

            drawGrid() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                for (let y = 0; y < this.height / TILE_SIZE; y++) for (let x = 0; x < this.width / TILE_SIZE; x++) this.ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
            
            drawPath() {
                this.ctx.fillStyle = '#404040';
                for (let y = 0; y < this.grid.length; y++) {
                    for (let x = 0; x < this.grid[y].length; x++) {
                        if (this.grid[y] && this.grid[y][x] && !this.grid[y][x].buildable) {
                            this.ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        }
                    }
                }
            }

            drawPathArrows() {
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                const arrowSize = 10;
                const arrowSpacing = 50; // pixels between arrows

                for (let i = 0; i < this.path.length - 1; i++) {
                    const start = this.path[i];
                    const end = this.path[i+1];

                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const segmentLength = Math.hypot(dx, dy);
                    const angle = Math.atan2(dy, dx);

                    // Calculate how many arrows fit and draw them
                    for (let dist = arrowSpacing / 2; dist < segmentLength; dist += arrowSpacing) {
                        const x = start.x + (dx / segmentLength) * dist + TILE_SIZE / 2; // Center on path
                        const y = start.y + (dy / segmentLength) * dist + TILE_SIZE / 2; // Center on path

                        this.ctx.save();
                        this.ctx.translate(x, y);
                        this.ctx.rotate(angle);

                        // Draw triangle
                        this.ctx.beginPath();
                        this.ctx.moveTo(-arrowSize, -arrowSize / 2);
                        this.ctx.lineTo(0, 0);
                        this.ctx.lineTo(-arrowSize, arrowSize / 2);
                        this.ctx.closePath();
                        this.ctx.fill();

                        this.ctx.restore();
                    }
                }
            }
            
            canBuildAt(gX, gY) { return this.grid[gY] && this.grid[gY][gX] && this.grid[gY][gX].buildable; }

            handleCanvasClick(x, y) {
                if (this.isTutorial) {
                    const tutorialHandled = this.tutorialManager.handleInput('canvas_click', { x, y });
                    if (tutorialHandled) {
                        // The tutorial might advance and immediately want us to open the build menu
                        const gX = Math.floor(x / TILE_SIZE);
                        const gY = Math.floor(y / TILE_SIZE);
                        if (this.canBuildAt(gX, gY)) {
                            this.openBuildMenu(gX, gY);
                        }
                        return; 
                    }
                }
                
                const clickX = x;
                const clickY = y;

                if (this.activeAbility === 'meteor') { this.triggerMeteor(clickX, clickY); return; }
                if (this.activeMenu.isOpen) {
                    const clickedOnMenu = this.activeMenu.options.some(option => {
                        const dx = clickX - option.x; const dy = clickY - option.y;
                        if (dx * dx + dy * dy < option.radius * option.radius) {
                            option.action(); this.closeMenu(); return true;
                        }
                        return false;
                    });
                    if (clickedOnMenu) return;
                }
                
                const gX = Math.floor(clickX / TILE_SIZE);
                const gY = Math.floor(clickY / TILE_SIZE);
                const clickedTower = this.towers.find(t => t.gridX === gX && t.gridY === gY);

                if (clickedTower) {
                    if (this.selectedTower === clickedTower) {
                        this.closeMenu();
                    } else {
                        this.selectedTower = clickedTower;
                        this.openUpgradeMenu(clickedTower);
                    }
                } else if (this.canBuildAt(gX, gY)) {
                    if (this.activeMenu.isOpen && this.activeMenu.type === 'build' && this.activeMenu.target.gridX === gX && this.activeMenu.target.gridY === gY) {
                         this.closeMenu();
                    } else {
                        this.closeMenu();
                        this.openBuildMenu(gX, gY);
                    }
                } else {
                    this.closeMenu();
                }
            }
            
            enemyDefeated(enemy) {
                const goldGain = Math.floor(enemy.value * (this.goldRushTimer > 0 ? ABILITIES.goldRush.multiplier : 1) * 0.94);
                this.gold += goldGain; this.addPlayerXp(enemy.value); this.updateUI();
            }
            
            addPlayerXp(amount) {
                this.playerXp += amount;
                if (this.playerXp >= this.playerXpToNextLevel) {
                    this.playerLevel++; this.playerXp -= this.playerXpToNextLevel; this.playerXpToNextLevel = Math.floor(this.playerXpToNextLevel * 1.5);
                    this.maxBaseHealth += 25; this.baseHealth = Math.min(this.baseHealth + 50, this.maxBaseHealth);
                }
                this.updateUI();
            }

            damageBase(amount) {
                this.baseHealth -= amount; this.updateUI();
                if (this.baseHealth <= 0) this.gameOver();
            }

            gameOver() {
                if (this.isTutorial) {
                    this.tutorialManager.end();
                    return;
                }
                this.isPaused = true; this.waveInProgress = false;
                document.getElementById('final-wave-stat').textContent = this.waveNumber; document.getElementById('game-over-modal').style.display = 'flex';
            }

            showVictoryScreen() {
                this.isPaused = true;
                document.getElementById('victory-modal').style.display = 'flex';
            }
            
            continueEndlessMode() {
                document.getElementById('victory-modal').style.display = 'none';
                document.getElementById('wave-button').disabled = false;
                this.pauseGame();
            }

            updateUI() {
                document.getElementById('gold-stat').textContent = `üí∞ ${Math.floor(this.gold)}`;
                document.getElementById('diamonds-stat').textContent = `üíé ${Math.floor(this.diamonds)}`;
                document.getElementById('player-level-stat').textContent = `Nivel ${this.playerLevel}`;
                document.getElementById('base-health-stat').textContent = `${Math.max(0, this.baseHealth)}/${this.maxBaseHealth}`;
                document.getElementById('base-health-bar').style.width = `${(this.baseHealth / this.maxBaseHealth) * 100}%`;
                document.getElementById('wave-number').textContent = this.waveNumber;
            }

            updateAbilityButtons() {
                const meteorBtn = document.getElementById('meteor-button'); 
                const goldRushBtn = document.getElementById('gold-rush-button');
                
                meteorBtn.parentElement.style.display = this.waveNumber >= 3 || this.isTutorial ? 'block' : 'none';

                meteorBtn.querySelector('.gem-cost').textContent = `(üíé ${ABILITIES.meteor.cost})`;
                goldRushBtn.querySelector('.gem-cost').textContent = `(üíé ${ABILITIES.goldRush.cost})`;

                this.updateButtonCooldown(meteorBtn, this.meteorCooldown); 
                this.updateButtonCooldown(goldRushBtn, this.goldRushCooldown);
                meteorBtn.disabled = this.diamonds < ABILITIES.meteor.cost || this.meteorCooldown > 0;
                goldRushBtn.disabled = this.diamonds < ABILITIES.goldRush.cost || this.goldRushCooldown > 0;
            }

            updateButtonCooldown(button, currentCD) {
                let cdText = button.querySelector('.cooldown-text');
                if (currentCD > 0) {
                    if (!cdText) { cdText = document.createElement('span'); cdText.className = 'cooldown-text'; button.appendChild(cdText); }
                    cdText.textContent = Math.ceil(currentCD / 60);
                } else if (cdText) { button.removeChild(cdText); }
            }

            openBuildMenu(gridX, gridY) {
                this.selectedTower = null;
                const menuX = gridX * TILE_SIZE + TILE_SIZE / 2; const menuY = gridY * TILE_SIZE + TILE_SIZE / 2;
                const options = [];
                let angle = -Math.PI / 2;
                const availableTowers = Object.keys(TOWER_TYPES).filter(type => this.playerLevel >= TOWER_TYPES[type].unlockLevel);
                const angleStep = (Math.PI * 2) / availableTowers.length;
                
                for (const type of availableTowers) {
                    const towerInfo = TOWER_TYPES[type];
                    options.push({
                        x: menuX + Math.cos(angle) * 50, y: menuY + Math.sin(angle) * 50, radius: 20,
                        label: towerInfo.name, cost: towerInfo.cost, color: towerInfo.color,
                        action: () => this.buildTower(gridX, gridY, type)
                    });
                    angle += angleStep;
                }
                this.activeMenu = { isOpen: true, type: 'build', x: menuX, y: menuY, options, target: {gridX, gridY} };
                if (this.isTutorial) this.tutorialManager.checkCondition('build_menu_opened');
            }

            openUpgradeMenu(tower) {
                const menuX = tower.x; const menuY = tower.y;
                const options = [
                    { x: menuX, y: menuY - 50, radius: 20, label: 'Da√±o', cost: tower.damageUpgradeCost, color: '#F44336', action: () => this.upgradeTower(tower, 'damage') },
                    { x: menuX + 50, y: menuY, radius: 20, label: 'Rango', cost: tower.rangeUpgradeCost, color: '#2196F3', action: () => this.upgradeTower(tower, 'range') },
                    { x: menuX - 50, y: menuY, radius: 20, label: 'Vender', cost: Math.floor(tower.totalInvestedGold * 0.7), color: '#4CAF50', action: () => this.sellTower(tower) }
                ];
                this.activeMenu = { isOpen: true, type: 'upgrade', x: menuX, y: menuY, options, target: tower };
                if (this.isTutorial) this.tutorialManager.checkCondition('upgrade_menu_opened');
            }

            closeMenu() { 
                this.activeMenu.isOpen = false; 
                this.activeMenu.type = null;
                this.activeMenu.target = null;
                this.selectedTower = null;
                this.canvas.style.cursor = 'default';
            }

            drawMenu() {
                this.ctx.font = 'bold 12px Segoe UI'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle';
                this.activeMenu.options.forEach(opt => {
                    this.ctx.beginPath(); this.ctx.arc(opt.x, opt.y, opt.radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = opt.color; this.ctx.globalAlpha = 0.8; this.ctx.fill(); this.ctx.globalAlpha = 1;
                    this.ctx.strokeStyle = 'white'; this.ctx.stroke();
                    this.ctx.fillStyle = 'white'; this.ctx.fillText(opt.label, opt.x, opt.y - 8);
                    this.ctx.fillText(`üí∞ ${opt.cost}`, opt.x, opt.y + 8);
                });
            }

            buildTower(gridX, gridY, type) {
                const towerInfo = TOWER_TYPES[type];
                if (this.gold >= towerInfo.cost) {
                    this.gold -= towerInfo.cost; this.towers.push(new Tower(this, gridX, gridY, type));
                    this.grid[gridY][gridX].buildable = false; this.updateUI();
                    if (this.isTutorial) this.tutorialManager.checkCondition('tower_built', { type: type });
                }
            }

            upgradeTower(tower, stat) {
                const cost = stat === 'damage' ? tower.damageUpgradeCost : tower.rangeUpgradeCost;
                if (this.gold >= cost) { this.gold -= cost; tower.upgradeStat(stat, cost); this.updateUI(); }
            }

            sellTower(tower) {
                this.gold += Math.floor(tower.totalInvestedGold * 0.7);
                this.grid[tower.gridY][tower.gridX].buildable = true;
                this.towers = this.towers.filter(t => t !== tower); this.updateUI();
            }

            // --- Funciones de Guardado y Carga ---
            saveState() {
                const simplifiedTowers = this.towers.map(t => ({
                    gridX: t.gridX,
                    gridY: t.gridY,
                    typeKey: t.typeKey,
                    level: t.level,
                    xp: t.xp,
                    damageUpgrades: t.damageUpgrades,
                    rangeUpgrades: t.rangeUpgrades,
                    totalInvestedGold: t.totalInvestedGold
                }));

                const state = {
                    mapId: this.mapId,
                    waveNumber: this.waveNumber,
                    gold: this.gold,
                    diamonds: this.diamonds,
                    playerLevel: this.playerLevel,
                    playerXp: this.playerXp,
                    playerXpToNextLevel: this.playerXpToNextLevel,
                    baseHealth: this.baseHealth,
                    maxBaseHealth: this.maxBaseHealth,
                    discoveredEnemies: Array.from(this.discoveredEnemies),
                    towers: simplifiedTowers
                };
                localStorage.setItem('towerDefenseProgress', JSON.stringify(state));
            }

            loadState(savedData) {
                this.mapId = savedData.mapId;
                this.waveNumber = savedData.waveNumber;
                this.gold = savedData.gold;
                this.diamonds = savedData.diamonds;
                this.playerLevel = savedData.playerLevel;
                this.playerXp = savedData.playerXp;
                this.playerXpToNextLevel = savedData.playerXpToNextLevel;
                this.baseHealth = savedData.baseHealth;
                this.maxBaseHealth = savedData.maxBaseHealth;
                this.discoveredEnemies = new Set(savedData.discoveredEnemies);

                this.towers = savedData.towers.map(tData => {
                    const tower = new Tower(this, tData.gridX, tData.gridY, tData.typeKey);
                    tower.level = tData.level;
                    tower.xp = tData.xp;
                    tower.damageUpgrades = tData.damageUpgrades;
                    tower.rangeUpgrades = tData.rangeUpgrades;
                    tower.totalInvestedGold = tData.totalInvestedGold;
                    // Actualizar las estad√≠sticas de la torre en base a las mejoras cargadas
                    for(let i = 0; i < tower.damageUpgrades; i++) {
                        tower.typeInfo.damage += TOWER_TYPES[tower.typeKey].upgrade.damage; 
                        if (tower.typeInfo.acid) tower.typeInfo.acid.multiplier += TOWER_TYPES[tower.typeKey].upgrade.acidMultiplier;
                        tower.damageUpgradeCost = Math.floor(tower.damageUpgradeCost * 1.6);
                    }
                     for(let i = 0; i < tower.rangeUpgrades; i++) {
                        tower.typeInfo.range += TOWER_TYPES[tower.typeKey].upgrade.range; 
                        if (tower.typeInfo.slowRadius !== undefined) tower.typeInfo.slowRadius += TOWER_TYPES[tower.typeKey].upgrade.slowRadius;
                        tower.rangeUpgradeCost = Math.floor(tower.rangeUpgradeCost * 1.8);
                    }
                    this.grid[tData.gridY][tData.gridX].buildable = false;
                    return tower;
                });
            }
        }

        class Enemy {
            constructor(game, x, y, baseHealth, baseValue, type) {
                this.game = game; this.x = x; this.y = y; this.type = type;
                const typeData = ENEMY_TYPES[type];
                this.isFlying = typeData.isFlying;
                this.speed = typeData.speed * (1 + game.waveNumber * 0.05) * 1.15;
                
                let healthMultiplier = 1 + (game.waveNumber * 0.075);
                // Llantitas de bici feature
                if (game.waveNumber <= 3) {
                    healthMultiplier *= 0.7;
                }
                
                this.maxHealth = Math.floor(baseHealth * typeData.health * healthMultiplier); 
                this.health = this.maxHealth;
                this.value = Math.floor(baseValue * typeData.value);
                this.width = TILE_SIZE * typeData.size; this.height = TILE_SIZE * typeData.size;
                this.color = typeData.color;
                this.pathIndex = 0; this.active = true; this.damagingTowers = new Set();
                this.effects = new Map();
                if (type === 'healer' || type === 'disabler') {
                    this.abilityCooldown = 0;
                }
            }
            update(allEnemies, allTowers) {
                if (!this.active) return;
                
                let currentSpeedMultiplier = 1;
                const effectsToRemove = [];

                for (const [type, effect] of this.effects.entries()) {
                    effect.duration--;
                    if (type === 'acid') {
                        this.takeDamage(effect.damagePerTick, null);
                    }
                    if (type === 'slow') {
                        currentSpeedMultiplier = Math.min(currentSpeedMultiplier, effect.multiplier);
                    }
                    if (effect.duration <= 0) {
                        effectsToRemove.push(type);
                    }
                }
                effectsToRemove.forEach(type => this.effects.delete(type));

                if (this.type === 'healer') {
                    this.abilityCooldown--;
                    if (this.abilityCooldown <= 0) {
                        const typeData = ENEMY_TYPES.healer;
                        this.game.effects.push(new Effect(this.game, this.x, this.y, typeData.healRadius, 'rgba(255, 128, 171, 0.3)', 15));
                        allEnemies.forEach(e => {
                            if (e !== this && e.active) {
                                const dist = Math.hypot(this.x - e.x, this.y - e.y);
                                if (dist < typeData.healRadius) {
                                    e.health = Math.min(e.maxHealth, e.health + (e.maxHealth * typeData.healAmount));
                                }
                            }
                        });
                        this.abilityCooldown = typeData.healRate;
                    }
                }

                if (this.type === 'disabler') {
                    this.abilityCooldown--;
                    if (this.abilityCooldown <= 0) {
                        const typeData = ENEMY_TYPES.disabler;
                        this.game.effects.push(new Effect(this.game, this.x, this.y, typeData.disableRadius, 'rgba(213, 0, 249, 0.3)', 15));
                        allTowers.forEach(t => {
                            const dist = Math.hypot(this.x - t.x, this.y - t.y);
                            if (dist < typeData.disableRadius) {
                                t.disabledTimer = typeData.disableDuration;
                            }
                        });
                        this.abilityCooldown = typeData.disableRate;
                    }
                }

                const currentPath = this.isFlying ? this.game.airPath : this.game.path;
                const targetPoint = currentPath[this.pathIndex]; 
                if (!targetPoint) return;

                const dx = targetPoint.x - this.x, dy = targetPoint.y + TILE_SIZE / 2 - this.y; const dist = Math.sqrt(dx * dx + dy * dy);
                const currentSpeed = this.speed * currentSpeedMultiplier;
                if (dist < currentSpeed) {
                    this.pathIndex++;
                    if (this.pathIndex >= currentPath.length) {
                        this.active = false;
                        const typeData = ENEMY_TYPES[this.type]; let damageToDeal = typeData.baseDamage;
                        if (damageToDeal < 1) damageToDeal = Math.floor(this.game.maxBaseHealth * damageToDeal);
                        this.game.damageBase(damageToDeal); return;
                    }
                } else { this.x += (dx / dist) * currentSpeed; this.y += (dy / dist) * currentSpeed; }
            }
            draw(ctx, frameCount) {
                if (this.isFlying) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(this.x, this.y + this.height / 2 + 5, this.width / 2, this.width / 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.fillStyle = this.color; 
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                
                if (this.effects.size > 0) {
                    const firstEffectType = this.effects.keys().next().value;
                    let flashColor = '';
                    if (firstEffectType === 'acid') flashColor = 'rgba(127, 255, 0, 0.7)';
                    if (firstEffectType === 'slow') flashColor = 'rgba(100, 181, 246, 0.7)';
                    
                    if (flashColor && frameCount % 20 < 10) {
                        ctx.fillStyle = flashColor;
                        ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                    }
                }

                const hbW = this.width, hbH = 5; ctx.fillStyle = '#333'; ctx.fillRect(this.x - hbW / 2, this.y - this.height / 2 - 10, hbW, hbH);
                ctx.fillStyle = '#76FF03'; ctx.fillRect(this.x - hbW / 2, this.y - this.height / 2 - 10, hbW * (this.health / this.maxHealth), hbH);
            }
            takeDamage(amount, tower) {
                this.health -= amount; if (tower) this.damagingTowers.add(tower);
                if (this.health <= 0 && this.active) {
                    this.active = false; this.game.enemyDefeated(this);
                    if (tower) { const xpPerTower = Math.ceil(this.value / this.damagingTowers.size); this.damagingTowers.forEach(t => t.gainXp(xpPerTower)); }
                }
            }
            applyEffect(type, effectData) {
                this.effects.set(type, { ...effectData });
            }
        }

        class Tower {
            constructor(game, gridX, gridY, type) {
                this.game = game; this.x = gridX * TILE_SIZE + TILE_SIZE / 2; this.y = gridY * TILE_SIZE + TILE_SIZE / 2;
                this.gridX = gridX; this.gridY = gridY; this.typeKey = type;
                this.typeInfo = JSON.parse(JSON.stringify(TOWER_TYPES[type]));
                this.fireCooldown = 0; this.level = 1; this.xp = 0; this.xpToNextLevel = 50;
                this.totalInvestedGold = this.typeInfo.cost; this.damageUpgradeCost = Math.floor(this.typeInfo.cost * 0.4); this.rangeUpgradeCost = Math.floor(this.typeInfo.cost * 0.5);
                this.damageUpgrades = 0;
                this.rangeUpgrades = 0;
                this.disabledTimer = 0;
            }
            update(enemies) {
                if (this.disabledTimer > 0) {
                    this.disabledTimer--;
                    return;
                }
                this.fireCooldown--;
                if (this.fireCooldown <= 0) { const target = this.findTarget(enemies); if (target) { this.shoot(target); this.fireCooldown = this.typeInfo.fireRate; } }
            }
            draw(ctx, frameCount) {
                const totalUpgrades = this.damageUpgrades + this.rangeUpgrades;
                const coreRadius = TILE_SIZE / 2 - 5;

                ctx.fillStyle = '#555'; 
                ctx.beginPath(); 
                ctx.arc(this.x, this.y, TILE_SIZE / 2 - 2, 0, Math.PI * 2); 
                ctx.fill();

                ctx.fillStyle = this.typeInfo.color;
                ctx.beginPath();
                if (totalUpgrades < 4) {
                    ctx.arc(this.x, this.y, coreRadius, 0, Math.PI * 2);
                } else if (totalUpgrades < 8) {
                    const angle = -Math.PI / 2;
                    ctx.moveTo(this.x + coreRadius * Math.cos(angle), this.y + coreRadius * Math.sin(angle));
                    ctx.lineTo(this.x + coreRadius * Math.cos(angle + 2 * Math.PI / 3), this.y + coreRadius * Math.sin(angle + 2 * Math.PI / 3));
                    ctx.lineTo(this.x + coreRadius * Math.cos(angle + 4 * Math.PI / 3), this.y + coreRadius * Math.sin(angle + 4 * Math.PI / 3));
                } else {
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i - Math.PI / 6;
                        ctx.lineTo(this.x + coreRadius * Math.cos(angle), this.y + coreRadius * Math.sin(angle));
                    }
                }
                ctx.closePath();
                ctx.fill();

                if (this.disabledTimer > 0) {
                    ctx.fillStyle = 'rgba(50, 50, 50, 0.7)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, TILE_SIZE / 2 - 2, 0, Math.PI * 2);
                    ctx.fill();
                    // Efecto de est√°tica
                    if (frameCount % 4 < 2) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.lineWidth = 1;
                        for (let i = 0; i < 5; i++) {
                            ctx.beginPath();
                            ctx.moveTo(this.x - coreRadius + Math.random() * coreRadius * 2, this.y - coreRadius + Math.random() * coreRadius * 2);
                            ctx.lineTo(this.x - coreRadius + Math.random() * coreRadius * 2, this.y - coreRadius + Math.random() * coreRadius * 2);
                            ctx.stroke();
                        }
                    }
                }

                const pipRadius = 2;
                const pipOrbitRadius = TILE_SIZE / 2 - 3;
                for (let i = 0; i < this.damageUpgrades; i++) {
                    const angle = (i * 0.5) - Math.PI / 2;
                    ctx.fillStyle = '#F44336';
                    ctx.beginPath();
                    ctx.arc(this.x + pipOrbitRadius * Math.cos(angle), this.y + pipOrbitRadius * Math.sin(angle), pipRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                for (let i = 0; i < this.rangeUpgrades; i++) {
                    const angle = (i * -0.5) + Math.PI / 2;
                    ctx.fillStyle = '#2196F3';
                    ctx.beginPath();
                    ctx.arc(this.x + pipOrbitRadius * Math.cos(angle), this.y + pipOrbitRadius * Math.sin(angle), pipRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.fillStyle = 'white'; 
                ctx.font = 'bold 14px sans-serif'; 
                ctx.textAlign = 'center'; 
                ctx.textBaseline = 'middle'; 
                ctx.fillText(this.level, this.x, this.y);
            }
            findTarget(enemies) {
                let closestEnemy = null;
                let minDistance = Infinity;

                for (const e of enemies) {
                    if (e.isFlying && !this.typeInfo.canHitFlying) {
                        continue;
                    }

                    const dx = e.x - this.x;
                    const dy = e.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < this.typeInfo.range && dist < minDistance) {
                        minDistance = dist;
                        closestEnemy = e;
                    }
                }
                return closestEnemy;
            }
            shoot(target) { const p = new Projectile(this.game, this.x, this.y, target, this, this.typeKey); this.game.projectiles.push(p); }
            gainXp(amount) { this.xp += amount; if (this.xp >= this.xpToNextLevel) this.levelUp(); }
            levelUp() {
                this.level++; this.xp -= this.xpToNextLevel; this.xpToNextLevel = Math.floor(this.xpToNextLevel * 1.8);
                const uInfo = TOWER_TYPES[this.typeKey].upgrade; this.typeInfo.damage += uInfo.damage; this.typeInfo.range += uInfo.range;
                if (uInfo.splashRadius) this.typeInfo.splashRadius += uInfo.splashRadius;
                if (uInfo.acidMultiplier) this.typeInfo.acid.multiplier += uInfo.acidMultiplier;
            }
            upgradeStat(stat, cost) {
                this.totalInvestedGold += cost;
                if (stat === 'damage') { 
                    this.typeInfo.damage += TOWER_TYPES[this.typeKey].upgrade.damage; 
                    if (this.typeInfo.acid) this.typeInfo.acid.multiplier += TOWER_TYPES[this.typeKey].upgrade.acidMultiplier;
                    this.damageUpgradeCost = Math.floor(this.damageUpgradeCost * 1.6);
                    this.damageUpgrades++;
                } else if (stat === 'range') { 
                    this.typeInfo.range += TOWER_TYPES[this.typeKey].upgrade.range; 
                    if (this.typeInfo.slowRadius !== undefined) this.typeInfo.slowRadius += TOWER_TYPES[this.typeKey].upgrade.slowRadius;
                    this.rangeUpgradeCost = Math.floor(this.rangeUpgradeCost * 1.8);
                    this.rangeUpgrades++;
                }
            }
        }

        class Projectile {
            constructor(game, x, y, target, tower, typeKey) {
                this.game = game; this.x = x; this.y = y; this.target = target; this.tower = tower; this.typeKey = typeKey;
                this.speed = tower.typeInfo.projectileSpeed; this.damage = tower.typeInfo.damage; this.color = tower.typeInfo.projectileColor; this.active = true;
            }
            update() {
                if (!this.active || !this.target.active) { this.active = false; return; }
                const dx = this.target.x - this.x, dy = this.target.y - this.y; const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < this.speed) {
                    this.active = false; const tInfo = this.tower.typeInfo;
                    if (this.typeKey === 'cannon') {
                        this.game.effects.push(new Effect(this.game, this.target.x, this.target.y, tInfo.splashRadius, 'rgba(100, 100, 100, 0.5)', 15));
                        this.game.enemies.forEach(e => {
                            if (!e.active || e.isFlying) return;
                            const dX = e.x - this.target.x, dY = e.y - this.target.y; const sDist = Math.sqrt(dX*dX + dY*dY);
                            if (sDist <= tInfo.splashRadius) e.takeDamage(this.damage, this.tower);
                        });
                    } else if (this.typeKey === 'ice') { 
                        const slowPower = Math.max(tInfo.slow.maxSlow, tInfo.slow.baseMultiplier - (this.damage * tInfo.slow.damageScale));
                        const slowEffect = () => {
                            this.target.applyEffect('slow', { multiplier: slowPower, duration: tInfo.slow.duration });
                            this.target.takeDamage(this.damage, this.tower); 
                        };
                        
                        if (tInfo.slowRadius > 0) {
                            this.game.effects.push(new Effect(this.game, this.target.x, this.target.y, tInfo.slowRadius, 'rgba(3, 169, 244, 0.3)', 20));
                            this.game.enemies.forEach(e => {
                                if (!e.active || e.isFlying) return;
                                const dX = e.x - this.target.x, dY = e.y - this.target.y; const sDist = Math.sqrt(dX*dX + dY*dY);
                                if (sDist <= tInfo.slowRadius) {
                                    e.applyEffect('slow', { multiplier: slowPower, duration: tInfo.slow.duration });
                                }
                            });
                            this.target.takeDamage(this.damage, this.tower);
                        } else {
                            slowEffect();
                        }
                    } else if (this.typeKey === 'acid') {
                        const acidDps = this.damage * tInfo.acid.multiplier;
                        this.target.applyEffect('acid', { damagePerTick: acidDps, duration: tInfo.acid.duration });
                        this.target.takeDamage(this.damage, this.tower);
                    } else {
                        this.target.takeDamage(this.damage, this.tower);
                    }
                } else { this.x += (dx / dist) * this.speed; this.y += (dy / dist) * this.speed; }
            }
            draw(ctx) { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, 5, 0, Math.PI * 2); ctx.fill(); }
        }

        class Effect {
            constructor(game, x, y, radius, color, life) {
                this.game = game; this.x = x; this.y = y; this.maxRadius = radius; this.color = color;
                this.life = life; this.maxLife = life; this.active = true;
            }
            update() { this.life--; if (this.life <= 0) this.active = false; }
            draw(ctx) {
                const r = this.maxRadius * (1 - (this.life / this.maxLife));
                ctx.globalAlpha = this.life / this.maxLife; ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
                ctx.strokeStyle = this.color; ctx.lineWidth = 3; ctx.stroke(); ctx.globalAlpha = 1.0; ctx.lineWidth = 1;
            }
        }

        class MeteorEffect extends Effect {
            constructor(game, x, y, radius, damage) {
                super(game, x, y, radius, 'rgba(255, 100, 0, 0.7)', 45);
                this.damage = damage; this.fallDuration = 30; this.hasImpacted = false;
            }
            update() {
                this.life--; if (this.life <= 0) this.active = false;
                if (this.life <= (this.maxLife - this.fallDuration) && !this.hasImpacted) { this.impact(); this.hasImpacted = true; }
            }
            draw(ctx) {
                if (this.life > (this.maxLife - this.fallDuration)) {
                    const fallProgress = (this.maxLife - this.life) / this.fallDuration;
                    const meteorY = this.y * fallProgress - 50 * (1-fallProgress);
                    ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.arc(this.x, meteorY, 15, 0, Math.PI * 2); ctx.fill();
                } else {
                    const explosionLife = this.maxLife - this.fallDuration;
                    const r = this.maxRadius * (1 - ((this.life) / explosionLife));
                    ctx.globalAlpha = this.life / explosionLife; ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
                    ctx.fillStyle = this.color; ctx.fill(); ctx.globalAlpha = 1.0;
                }
            }
            impact() {
                this.game.enemies.forEach(e => {
                    if (!e.active) return;
                    const dX = e.x - this.x, dY = e.y - this.y; const dist = Math.sqrt(dX*dX + dY*dY);
                    if (dist <= this.maxRadius) e.takeDamage(this.damage, null);
                });
            }
        }

        // --- CLASE DEL TUTORIAL INTERACTIVO ---
        class TutorialManager {
            constructor(game) {
                this.game = game;
                this.currentStep = 0;
                this.isPaused = false;
                this.waitingFor = null;

                // Elementos del DOM
                this.overlay = document.getElementById('tutorial-overlay');
                this.highlight = document.getElementById('tutorial-highlight');
                this.messageBox = document.getElementById('tutorial-message-box');
                this.messageText = document.getElementById('tutorial-message-text');
                this.nextButton = document.getElementById('tutorial-next-step-button');

                this.steps = [
                    { 
                        text: "¬°Bienvenido al tutorial! Tu objetivo es defender la base (al final del camino) de los enemigos que vienen por aqu√≠.",
                        highlightTarget: () => this.game.canvas,
                        waitFor: { type: 'button_click' }
                    },
                    {
                        text: "Para defenderte, necesitas construir torres. Haz clic en esta casilla vac√≠a para empezar.",
                        highlightTarget: () => {
                            const rect = this.game.canvas.getBoundingClientRect();
                            return { 
                                left: rect.left + (5 * TILE_SIZE * this.game.scale), 
                                top: rect.top + (3 * TILE_SIZE * this.game.scale), 
                                width: TILE_SIZE * this.game.scale, 
                                height: TILE_SIZE * this.game.scale 
                            };
                        },
                        waitFor: { type: 'canvas_click', condition: (data) => {
                            const gridX = Math.floor(data.x / TILE_SIZE);
                            const gridY = Math.floor(data.y / TILE_SIZE);
                            return gridX === 5 && gridY === 3;
                        }}
                    },
                    {
                        text: "¬°Excelente! Ahora construye una Torre de Flechas. Es la √∫nica disponible al principio.",
                        waitFor: { type: 'tower_built', condition: (data) => data.type === 'arrow' }
                    },
                    {
                        text: "¬°Bien hecho! Ahora tienes tu primera defensa. Las torres atacan autom√°ticamente a los enemigos en su rango. Presiona 'Iniciar' para comenzar la primera oleada.",
                        highlightTarget: () => document.getElementById('wave-button'),
                        waitFor: { type: 'wave_started' }
                    },
                    {
                        text: "¬°Mira c√≥mo tu torre defiende la base! Cuando la oleada termine, podr√°s construir m√°s.",
                        waitFor: { type: 'wave_cleared' }
                    },
                    {
                        text: "¬°Felicidades! Has completado el tutorial. Ahora est√°s listo para jugar. ¬°Buena suerte!",
                        highlightTarget: () => this.game.canvas,
                        waitFor: { type: 'button_click' }
                    }
                ];
            }

            start() {
                this.overlay.style.display = 'block';
                this.currentStep = -1;
                this.nextStep();
            }

            nextStep() {
                this.currentStep++;
                if (this.currentStep >= this.steps.length) {
                    this.end();
                    return;
                }
                this.runStep(this.currentStep);
            }

            runStep(index) {
                const step = this.steps[index];
                this.isPaused = (step.waitFor.type !== 'wave_cleared'); // Pause unless waiting for wave to clear
                this.game.isPaused = this.isPaused;
                this.waitingFor = step.waitFor;
                this.showMessage(step.text);

                if (step.highlightTarget) {
                    this.highlightElement(step.highlightTarget());
                } else {
                    this.highlight.style.display = 'none';
                }

                if (step.waitFor.type === 'button_click' && !step.waitFor.element) {
                    this.nextButton.style.display = 'block';
                    this.nextButton.onclick = () => {
                        this.nextButton.style.display = 'none';
                        this.nextStep();
                    };
                } else {
                     this.nextButton.style.display = 'none';
                }
            }
            
            highlightElement(target) {
                if (!target) {
                    this.highlight.style.display = 'none';
                    return;
                }
                
                let rect;
                if (target instanceof HTMLElement) {
                    rect = target.getBoundingClientRect();
                } else {
                    rect = target; // Es un objeto con left, top, width, height
                }

                this.highlight.style.display = 'block';
                this.highlight.style.left = `${rect.left - 5}px`;
                this.highlight.style.top = `${rect.top - 5}px`;
                this.highlight.style.width = `${rect.width + 10}px`;
                this.highlight.style.height = `${rect.height + 10}px`;

                // --- NEW MESSAGE BOX LOGIC ---
                const canvasRect = this.game.canvas.getBoundingClientRect();
                const msgBox = this.messageBox;
                
                // Reset position to calculate natural width
                msgBox.style.left = '0px';
                msgBox.style.top = '0px';
                const msgBoxRect = msgBox.getBoundingClientRect();

                // Position at top-center of canvas, safely inside
                let newLeft = canvasRect.left + (canvasRect.width / 2) - (msgBoxRect.width / 2);
                let newTop = canvasRect.top + 20;

                // Ensure it stays within viewport bounds horizontally
                if (newLeft < 10) newLeft = 10;
                if ((newLeft + msgBoxRect.width) > window.innerWidth - 10) {
                    newLeft = window.innerWidth - msgBoxRect.width - 10;
                }
                
                msgBox.style.top = `${newTop}px`;
                msgBox.style.left = `${newLeft}px`;
            }

            showMessage(text) {
                this.messageText.innerHTML = text;
            }

            isWaitingForInput() {
                return !!this.waitingFor;
            }

            handleInput(inputType, data) {
                if (!this.waitingFor || this.waitingFor.type !== inputType) return false;
                
                if (this.waitingFor.condition) {
                    if (this.waitingFor.condition(data)) {
                        this.nextStep();
                        return true;
                    }
                }
                return false;
            }

            checkCondition(conditionType, data) {
                 if (!this.waitingFor || this.waitingFor.type !== conditionType) return false;
                 if (this.waitingFor.condition) {
                     if(this.waitingFor.condition(data)) {
                        this.nextStep();
                        return true;
                     }
                 } else {
                     this.nextStep();
                     return true;
                 }
                 return false;
            }

            getWaveConfig() {
                return [{ type: 'standard' }, { type: 'standard' }];
            }

            end() {
                this.overlay.style.display = 'none';
                alert("¬°Tutorial completado! Volver√°s al men√∫ principal.");
                window.location.reload();
            }
        }
        
        // --- L√ìGICA DE LA INTERFAZ Y EL MEN√ö ---
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            let game;

            // Elementos de la interfaz
            const mainMenuScreen = document.getElementById('main-menu-screen');
            const mapSelectionScreen = document.getElementById('map-selection-screen');
            const gameUiContainer = document.getElementById('game-ui-container');
            const tutorialPromptModal = document.getElementById('tutorial-prompt-modal');
            const playOptionsModal = document.getElementById('play-options-modal');
            const arsenalModal = document.getElementById('arsenal-modal');
            const bestiaryModal = document.getElementById('bestiary-modal');
            const powersModal = document.getElementById('powers-modal');
            const meteorUnlockModal = document.getElementById('meteor-unlock-modal');

            // Botones del men√∫ principal
            const playButton = document.getElementById('play-button');
            const tutorialButton = document.getElementById('tutorial-button');
            const exitButton = document.getElementById('exit-button');
            const continueButton = document.getElementById('continue-button');
            const newGameButton = document.getElementById('new-game-button');

            function setupGameListeners() {
                document.getElementById('wave-button').onclick = () => game.startWave();
                document.getElementById('pause-button').onclick = () => game.togglePause();
                document.getElementById('speed-1x-button').onclick = () => game.setSpeed(1);
                document.getElementById('speed-2x-button').onclick = () => game.setSpeed(2);
                document.getElementById('speed-5x-button').onclick = () => game.setSpeed(5);
                document.getElementById('meteor-button').onclick = () => game.activateMeteor();
                document.getElementById('gold-rush-button').onclick = () => game.activateGoldRush();
                document.getElementById('continue-endless-button').onclick = () => game.continueEndlessMode();
                document.getElementById('fullscreen-button').onclick = toggleFullScreen;
                
                document.getElementById('arsenal-button').onclick = () => {
                    game.pauseGame();
                    updateArsenalModal();
                    arsenalModal.style.display = 'flex';
                    resizeGame();
                };
                document.getElementById('close-arsenal-button').onclick = () => {
                    arsenalModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };
                document.getElementById('close-arsenal-x').onclick = () => {
                    arsenalModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };

                document.getElementById('bestiary-button').onclick = () => {
                    game.pauseGame();
                    updateBestiaryModal();
                    bestiaryModal.style.display = 'flex';
                    resizeGame();
                };
                document.getElementById('close-bestiary-button').onclick = () => {
                    bestiaryModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };
                document.getElementById('close-bestiary-x').onclick = () => {
                    bestiaryModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };
                
                document.getElementById('powers-button').onclick = () => {
                    game.pauseGame();
                    updatePowersModal();
                    powersModal.style.display = 'flex';
                    resizeGame();
                };
                document.getElementById('close-powers-button').onclick = () => {
                    powersModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };
                document.getElementById('close-powers-x').onclick = () => {
                    powersModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };

                const closeMeteorUnlock = () => {
                    if (document.getElementById('hide-meteor-checkbox').checked) {
                        localStorage.setItem('hideMeteorUnlock', 'true');
                    }
                    meteorUnlockModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };
                document.getElementById('close-meteor-unlock-button').onclick = closeMeteorUnlock;

                canvas.addEventListener('mousemove', (e) => {
                    if(game) {
                        game.mousePos = { x: e.clientX, y: e.clientY };
                    }
                });

                canvas.addEventListener('click', (e) => {
                    if(game) {
                        const { x, y } = getGameCoordinates(e.clientX, e.clientY);
                        game.handleCanvasClick(x, y);
                    }
                });
                
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault(); 
                    if (e.changedTouches.length === 1 && game) {
                        const touch = e.changedTouches[0];
                        const { x, y } = getGameCoordinates(touch.clientX, touch.clientY);
                        game.handleCanvasClick(x, y);
                    }
                });

                window.onkeydown = (event) => {
                    if (event.key === 'Escape' && game) { 
                        game.closeMenu(); 
                        game.activeAbility = null; 
                    }
                };
            }

            function launchGame(mapId, savedData = null) {
                mapSelectionScreen.style.display = 'none';
                playOptionsModal.style.display = 'none';
                mainMenuScreen.style.display = 'none';
                gameUiContainer.style.display = 'flex';

                game = new Game(canvas, mapId, savedData, false);
                generateImages();
                setupGameListeners();
                
                setTimeout(resizeGame, 0);
            }

            function launchTutorial() {
                mainMenuScreen.style.display = 'none';
                gameUiContainer.style.display = 'flex';
                game = new Game(canvas, 'classic', null, true);
                generateImages();
                setupGameListeners();
                
                setTimeout(() => {
                    resizeGame();
                }, 0);
            }


            // --- Event Listeners del Men√∫ Principal ---
            playButton.addEventListener('click', () => {
                const savedGame = localStorage.getItem('towerDefenseProgress');
                if (savedGame) {
                    playOptionsModal.style.display = 'flex';
                } else {
                     if (!localStorage.getItem('hideTutorialPrompt')) {
                        tutorialPromptModal.style.display = 'flex';
                    } else {
                        mainMenuScreen.style.display = 'none';
                        mapSelectionScreen.style.display = 'flex';
                    }
                }
            });

            continueButton.addEventListener('click', () => {
                 const savedGameData = JSON.parse(localStorage.getItem('towerDefenseProgress'));
                 if (savedGameData) {
                    launchGame(savedGameData.mapId, savedGameData);
                 }
            });
            
            newGameButton.addEventListener('click', () => {
                localStorage.removeItem('towerDefenseProgress');
                playOptionsModal.style.display = 'none';
                mainMenuScreen.style.display = 'none';
                mapSelectionScreen.style.display = 'flex';
            });

            playOptionsModal.querySelector('.modal-close-button').addEventListener('click', () => {
                playOptionsModal.style.display = 'none';
            });


            tutorialButton.addEventListener('click', launchTutorial);
            
            exitButton.addEventListener('click', () => {
                window.close();
            });

            // --- Event Listeners del Modal de Pregunta del Tutorial ---
            document.getElementById('play-tutorial-button').addEventListener('click', () => {
                if (document.getElementById('hide-tutorial-prompt-checkbox').checked) {
                    localStorage.setItem('hideTutorialPrompt', 'true');
                }
                tutorialPromptModal.style.display = 'none';
                launchTutorial();
            });

            document.getElementById('skip-tutorial-button').addEventListener('click', () => {
                if (document.getElementById('hide-tutorial-prompt-checkbox').checked) {
                    localStorage.setItem('hideTutorialPrompt', 'true');
                }
                tutorialPromptModal.style.display = 'none';
                mainMenuScreen.style.display = 'none';
                mapSelectionScreen.style.display = 'flex';
            });

            // --- L√≥gica de Inicio del Juego ---
            function resizeGame() {
                if (!game || window.getComputedStyle(gameUiContainer).display === 'none') return;
                
                const nativeWidth = 800 + 240 + 4;
                const nativeHeight = 520 + document.getElementById('top-bar').offsetHeight;
                
                game.scale = Math.min(window.innerWidth / nativeWidth, window.innerHeight / nativeHeight);
                gameUiContainer.style.transform = `scale(${game.scale})`;

                [arsenalModal, bestiaryModal, playOptionsModal, tutorialPromptModal, powersModal].forEach(modal => {
                    const modalContent = modal.querySelector('.modal-content');
                    if(window.getComputedStyle(modal).display !== 'none'){
                        const modalScale = Math.min( (window.innerWidth / modalContent.offsetWidth) * 0.8, (window.innerHeight / modalContent.offsetHeight) * 0.8, 1);
                        modalContent.style.transform = `scale(${modalScale})`;
                    }
                });
                 if (game.isTutorial && game.tutorialManager.currentStep < game.tutorialManager.steps.length) {
                    game.tutorialManager.highlightElement(game.tutorialManager.steps[game.tutorialManager.currentStep].highlightTarget());
                }
            }
            window.addEventListener('resize', resizeGame);

            function getGameCoordinates(clientX, clientY) {
                if (!game) return {x: 0, y: 0};
                const rect = canvas.getBoundingClientRect();
                const xOnScaledCanvas = clientX - rect.left;
                const yOnScaledCanvas = clientY - rect.top;
                const xOnNativeCanvas = xOnScaledCanvas / game.scale;
                const yOnNativeCanvas = yOnScaledCanvas / game.scale;
                
                return { x: xOnNativeCanvas, y: yOnNativeCanvas };
            }

            const TOWER_IMAGES = {};
            const ENEMY_IMAGES = {};

            function generateImages() {
                for (const type in TOWER_TYPES) {
                    const info = TOWER_TYPES[type];
                    const tempCanvas = document.createElement('canvas'); tempCanvas.width = 50; tempCanvas.height = 50;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.fillStyle = '#555'; tempCtx.beginPath(); tempCtx.arc(25, 25, 23, 0, Math.PI * 2); tempCtx.fill();
                    tempCtx.fillStyle = info.color; tempCtx.beginPath(); tempCtx.arc(25, 25, 20, 0, Math.PI * 2); tempCtx.fill();
                    TOWER_IMAGES[type] = tempCanvas.toDataURL();
                }
                for (const type in ENEMY_TYPES) {
                    const info = ENEMY_TYPES[type];
                    const tempCanvas = document.createElement('canvas'); tempCanvas.width = 50; tempCanvas.height = 50;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.fillStyle = info.color;
                    tempCtx.fillRect(25 - (TILE_SIZE * info.size / 2), 25 - (TILE_SIZE * info.size / 2), TILE_SIZE * info.size, TILE_SIZE * info.size);
                    ENEMY_IMAGES[type] = tempCanvas.toDataURL();
                }
            }

            function updateArsenalModal() {
                const container = document.getElementById('arsenal-cards-container');
                container.innerHTML = ''; 

                for (const type in TOWER_TYPES) {
                    const towerInfo = TOWER_TYPES[type];
                    const card = document.createElement('div');
                    card.className = 'info-card';

                    if (game && game.playerLevel >= towerInfo.unlockLevel) {
                        const saleValue = Math.floor(towerInfo.cost * 0.7);
                        card.innerHTML = `
                            <div class="info-card-header">
                                <img class="visual" src="${TOWER_IMAGES[type]}" alt="${towerInfo.name}">
                                <h4>${towerInfo.name}</h4>
                            </div>
                            <p>${towerInfo.desc}</p>
                            <p class="costs">Costo: ${towerInfo.cost} | Venta: ${saleValue}</p>
                        `;
                    } else {
                        card.classList.add('locked');
                        card.innerHTML = `<span>?</span>`;
                    }
                    container.appendChild(card);
                }
            }
            
            function updateBestiaryModal() {
                const container = document.getElementById('bestiary-cards-container');
                container.innerHTML = '';

                for (const type in ENEMY_TYPES) {
                    const enemyInfo = ENEMY_TYPES[type];
                    const card = document.createElement('div');
                    card.className = 'info-card';

                    if (game && game.discoveredEnemies.has(type)) {
                        card.innerHTML = `
                            <div class="info-card-header">
                                <img class="visual" src="${ENEMY_IMAGES[type]}" alt="${enemyInfo.name}">
                                <h4>${enemyInfo.name}</h4>
                            </div>
                            <p>${enemyInfo.desc}</p>
                        `;
                    } else {
                        card.classList.add('locked');
                        card.innerHTML = `<span>?</span>`;
                    }
                    container.appendChild(card);
                }
            }
            
            function updatePowersModal() {
                const container = document.getElementById('powers-cards-container');
                container.innerHTML = '';
                for (const key in ABILITIES) {
                    const ability = ABILITIES[key];
                    const name = key === 'meteor' ? 'Meteorito' : 'Fiebre de Oro';
                    const desc = key === 'meteor' ? 'Invoca un meteorito del cielo que inflige da√±o masivo en un √°rea. Ideal para eliminar grupos grandes o jefes.' : 'Duplica temporalmente todo el oro ganado al derrotar enemigos. ¬°√ösalo antes de una oleada grande para maximizar tus ganancias!';
                    
                    const card = document.createElement('div');
                    card.className = 'info-card';
                    card.innerHTML = `
                        <h4>${name}</h4>
                        <p>${desc}</p>
                        <p class="costs">Costo: ${ability.cost} üíé</p>
                    `;
                    container.appendChild(card);
                }
            }

            function toggleFullScreen() {
                const elem = document.documentElement;
                if (!document.fullscreenElement) {
                    if (elem.requestFullscreen) {
                        elem.requestFullscreen();
                    } else if (elem.webkitRequestFullscreen) { /* Safari */
                        elem.webkitRequestFullscreen();
                    }
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            }

            function isTouchDevice() {
                return (('ontouchstart' in window) || (navigator.maxTouchPoints > 0));
            }

            function isIphone() {
                return /iPhone|iPad|iPod/i.test(navigator.userAgent);
            }


            if (isTouchDevice()) {
                document.body.classList.add('is-touch');
            }
            if (isIphone()) {
                document.body.classList.add('is-iphone');
            }

            document.querySelectorAll('.map-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const mapId = e.target.dataset.map;
                    launchGame(mapId, null); // Inicia un nuevo juego con el mapa seleccionado
                });
            });
        });
    </script>
</body>
</html>
 