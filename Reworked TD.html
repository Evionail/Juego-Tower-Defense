<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense Progresivo</title>

    <!-- Meta tags for iOS Web App -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TD Progresivo">
    <!-- Para un ícono personalizado, necesitarías subir una imagen y enlazarla aquí -->
    <!-- <link rel="apple-touch-icon" href="icon.png"> -->

    <!-- BIBLIOTECA DE SONIDO AÑADIDA -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }
        .screen {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            background-color: #2c2c2c;
            padding: 40px;
            border-radius: 10px;
            border: 2px solid #444;
            position: relative; /* Añadido para posicionar la versión */
            transform-origin: center center; /* Añadido para el escalado */
        }
        .screen h1 {
            margin: 0 0 20px 0;
            color: #00ff87;
        }
        #main-menu-screen {
            display: flex;
        }
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 250px;
        }
        .menu-button {
            padding: 15px 30px;
            font-size: 1.3em;
            font-weight: bold;
            background-color: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color: 0.3s, transform: 0.2s;
        }
        .menu-button:hover:not(:disabled) {
            background-color: #00ff87;
            color: #1a1a1a;
            transform: scale(1.05);
        }
        .menu-button:disabled {
            background-color: #222;
            color: #555;
            cursor: not-allowed;
        }
        #map-selection-screen h1 {
            margin: 0 0 20px 0;
            color: #00ff87;
        }
        .map-selection-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        .map-button {
            padding: 20px 40px;
            font-size: 1.2em;
            font-weight: bold;
            background-color: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color: 0.3s, transform: 0.2s;
        }
        .map-button:hover {
            background-color: #00ff87;
            color: #1a1a1a;
            transform: scale(1.05);
        }
        #game-ui-container {
            display: none;
            flex-direction: column;
            border: 2px solid #444;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            background-color: #2c2c2c;
            transform-origin: center center;
        }
        #top-bar {
            display: flex;
            flex-direction: column; /* Cambiado a columna para dos filas */
            padding: 5px 15px;
            background-color: #252525;
            border-bottom: 2px solid #444;
        }
        .top-bar-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        .ui-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .stat {
            font-size: 1.1em;
            font-weight: bold;
            transition: color 0.3s ease, text-shadow 0.3s ease;
        }
        .stat-icon {
            font-size: 1.3em;
        }
        #gold-stat.gold-rush-active {
            color: #FFD700;
            text-shadow: 0 0 8px #FFD700;
        }
        #base-health-bar-container {
            width: 150px;
            height: 18px;
            background-color: #444;
            border-radius: 9px;
            overflow: hidden;
        }
        #base-health-bar {
            height: 100%;
            background-color: #f44336;
            transition: width 0.3s ease;
        }
        .control-button, #wave-button, .ability-button, .modal-button, .side-panel-button {
            padding: 8px 12px;
            color: white;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            background-color: #333;
            transition: background-color: 0.3s;
            position: relative;
            font-size: 0.9em;
        }
        .control-button:hover, #wave-button:hover:not(:disabled), .ability-button:hover:not(:disabled), .modal-button:hover, .side-panel-button:hover {
            background-color: #454545;
        }
        .side-panel-button {
             width: 100%;
        }
        #arsenal-button {
            background-color: #00796B;
        }
        #arsenal-button:hover {
            background-color: #004D40;
        }
        #bestiary-button {
            background-color: #C2185B;
        }
        #bestiary-button:hover {
            background-color: #880E4F;
        }
        #powers-button {
            background-color: #FFC107;
        }
        #powers-button:hover {
            background-color: #FFA000;
        }
        .control-button.active {
            background-color: #00ff87;
            color: #1a1a1a;
            font-weight: bold;
            border-color: #00ff87;
        }
        #wave-button {
            background-color: #f44336;
            font-weight: bold;
        }
        #wave-button:hover:not(:disabled) { background-color: #d32f2f; }
        #wave-button:disabled { background-color: #555; color: #888; cursor: not-allowed; }
        .ability-button {
            background-color: #9C27B0;
        }
        .ability-button:hover:not(:disabled) { background-color: #7B1FA2; }
        .ability-button:disabled { background-color: #555; color: #888; cursor: not-allowed; }
        .gem-cost {
            font-size: 0.8em;
            color: #B2EBF2; /* Light cyan to represent gems */
            font-weight: bold;
            margin-left: 5px;
        }
        .cooldown-text {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2em; color: rgba(255, 255, 255, 0.8);
            font-weight: bold; text-shadow: 1px 1px 3px black;
        }
        canvas {
            display: block;
            cursor: default;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #game-wrapper { position: relative; }
        #screen-flash, #gold-rush-effect {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            opacity: 0;
            z-index: 999; pointer-events: none;
        }
        #screen-flash { background-color: red; }
        #gold-rush-effect {
            box-shadow: inset 0 0 25px 10px gold;
            border-radius: 8px;
            transition: opacity 0.5s ease-in-out;
        }
        #gold-rush-effect.active {
            opacity: 0.7;
        }
        .modal {
            display: none; position: fixed; z-index: 1000;
            left: 0; top: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7);
            justify-content: center; align-items: center;
        }
        .modal-content {
            background-color: #2c2c2c; padding: 30px;
            border-radius: 10px;
            text-align: center; color: white;
            position: relative;
            transform-origin: center center;
            max-height: 90vh; /* Límite de altura para responsividad */
            overflow-y: auto; /* Scroll si el contenido es muy alto */
        }
        .game-over-content { border: 2px solid #f44336; }
        .victory-content { border: 2px solid #00ff87; }
        .modal-content h2 { margin-top: 0; }
        .game-over-content h2 { color: #f44336; }
        .victory-content h2 { color: #00ff87; }
        
        #rotate-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #1a1a1a;
            color: #fff;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 2000;
            font-size: 1.5em;
        }

        #main-content {
            display: flex;
        }

        #side-panel {
            width: 240px;
            padding: 15px;
            background-color: #252525;
            border-left: 2px solid #444;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        #game-explanation-bar p {
            margin: 0;
            font-size: 0.85em;
            color: #ccc;
            line-height: 1.4;
        }
        #game-explanation-bar p strong {
            color: #00ff87;
        }

        /* --- ESTILOS DE MODALES --- */
        #arsenal-modal .modal-content, #bestiary-modal .modal-content, #powers-modal .modal-content, #dev-tools-modal .modal-content {
            width: 80vw;
            max-width: 900px;
        }
        #arsenal-modal .modal-content { border: 2px solid #00ff87; }
        #bestiary-modal .modal-content { border: 2px solid #C2185B; }
        #powers-modal .modal-content { border: 2px solid #FFC107; }
        #dev-tools-modal .modal-content { border: 2px solid #ff00ff; }
        #arsenal-modal h2 { color: #00ff87; }
        #bestiary-modal h2 { color: #C2185B; }
        #powers-modal h2 { color: #FFC107; }
        #dev-tools-modal h2 { color: #ff00ff; }

        .modal-close-button {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.5em;
            color: #fff;
            background: none;
            border: none;
            cursor: pointer;
        }
        #arsenal-cards-container, #bestiary-cards-container, #powers-cards-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
            margin-bottom: 20px;
        }
        .info-card {
            background-color: #333;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 15px;
            text-align: left;
        }
        .info-card.locked {
            background-color: #222;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 4em;
            color: #444;
        }
        .info-card-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .info-card-header .visual {
            width: 50px;
            height: 50px;
            background-color: #444;
            border-radius: 5px;
        }
        .info-card-header h4 {
            margin: 0;
            font-size: 1.1em;
        }
        .info-card p {
            font-size: 0.9em;
            color: #ccc;
            margin: 5px 0;
        }
        .info-card .costs {
            font-size: 0.8em;
            color: #aaa;
        }
        
        /* --- ESTILOS DEL MODAL DE DESBLOQUEO --- */
        #meteor-unlock-modal .modal-content, #tower-unlock-modal .modal-content, #tower-evolution-modal .modal-content {
            border: 2px solid #FFC107;
        }
        #meteor-unlock-modal h2, #tower-unlock-modal h2, #tower-evolution-modal h2 {
            color: #FFC107;
        }
        .dont-show-again {
            margin-top: 20px;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .button-wrapper {
            position: relative;
        }
        .button-flash {
            display: none;
            position: absolute;
            top: -5px; left: -5px; right: -5px; bottom: -5px;
            border-radius: 8px;
            animation: flash 1s infinite;
            z-index: -1;
        }
        #meteor-button-flash { box-shadow: 0 0 15px 5px #FFC107; }
        #arsenal-button-flash { box-shadow: 0 0 15px 5px #00796B; }
        .button-flash.flashing {
            display: block;
        }
        @keyframes flash {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
        /* --- FIN DE ESTILOS DEL MODAL --- */

        /* --- ESTILOS BOTÓN PANTALLA COMPLETA --- */
        #fullscreen-button {
            display: none;
            background-color: #3F51B5;
        }
        #fullscreen-button:hover {
            background-color: #303F9F;
        }
        body.is-touch #fullscreen-button {
            display: block;
        }
        #fullscreen-helper {
            display: none;
            font-size: 0.75em;
            color: #aaa;
            text-align: center;
            margin-top: -15px;
        }
        body.is-iphone #fullscreen-helper {
            display: block;
        }
        /* --- FIN DE ESTILOS --- */

        /* --- ESTILOS DEL TUTORIAL INTERACTIVO --- */
        #tutorial-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1001;
            pointer-events: none; /* Permite clics a través del overlay */
        }
        #tutorial-highlight {
            position: absolute;
            border: 3px dashed #FFD700;
            border-radius: 8px;
            box-shadow: 0 0 20px #FFD700;
            transition: all 0.3s ease;
            pointer-events: none; /* FIX: No debe capturar eventos de ratón */
        }
        #tutorial-message-box {
            position: absolute;
            background-color: rgba(0,0,0,0.85);
            color: white;
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #FFD700;
            max-width: 240px;
            font-size: 0.9em;
            line-height: 1.4;
            pointer-events: all; /* La caja de mensaje es interactiva */
            transition: top 0.4s ease, left 0.4s ease; /* Transición suave */
        }
        .clickable {
            pointer-events: all !important;
        }
        /* --- FIN DE ESTILOS DEL TUTORIAL --- */

        /* --- VERSIÓN DEL JUEGO --- */
        #version-display {
            position: absolute;
            bottom: 15px;
            left: 15px;
            font-size: 0.9em;
            color: #888;
        }
        /* --- FIN DE ESTILOS --- */

        /* --- DEV TOOLS --- */
        #dev-tools-button {
            display: none;
            background-color: #ff00ff;
        }
        #dev-tools-button:hover {
            background-color: #c000c0;
        }
        .dev-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        .dev-options .modal-button {
            width: 200px;
        }
        .dev-options .modal-button.active {
            background-color: #00ff87;
            color: #1a1a1a;
        }
        /* --- FIN DEV TOOLS --- */
        
        /* --- ESTILOS DE CONTROL DE VOLUMEN --- */
        #volume-control-container {
            position: relative;
        }
        #volume-slider {
            position: absolute;
            bottom: 120%;
            left: 50%;
            transform: translateX(-50%);
            -webkit-appearance: none;
            appearance: none;
            width: 80px;
            height: 8px;
            background: #555;
            border-radius: 4px;
            outline: none;
            opacity: 0.9;
            transition: opacity .2s;
            writing-mode: bt-lr; /* IE */
            -webkit-appearance: slider-vertical; /* WebKit */
        }
        .hidden {
            display: none;
        }
        /* --- FIN DE ESTILOS --- */


        @media (orientation: portrait) {
            #game-ui-container, #map-selection-screen, #game-over-modal, #victory-modal, #main-menu-screen {
                display: none !important;
            }
            #rotate-screen {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <div id="rotate-screen">
        <p>Por favor, rota tu dispositivo para jugar.</p>
        <p>Juego diseñado para modo horizontal.</p>
    </div>

    <div id="main-menu-screen" class="screen">
        <h1>Tower Defense Progresivo</h1>
        <div class="menu-buttons">
            <button id="play-button" class="menu-button">Jugar</button>
            <button id="difficulty-button" class="menu-button">Dificultad</button>
            <button id="tutorial-button" class="menu-button">Tutorial</button>
            <button id="exit-button" class="menu-button">Salir</button>
        </div>
        <div id="version-display">v2.0.5</div>
    </div>

    <div id="map-selection-screen" class="screen">
        <h1>Selecciona un Mapa</h1>
        <div class="map-selection-buttons">
            <button class="map-button" data-map="classic">El Sendero Clásico</button>
            <button class="map-button" data-map="serpentine">Cañón Serpenteante</button>
            <button class="map-button" data-map="crossroads">Encrucijada Mortal</button>
            <button class="map-button" data-map="direct">Asalto Directo</button>
        </div>
    </div>

    <div id="game-ui-container">
        <div id="top-bar">
            <div class="top-bar-row">
                <div class="ui-group">
                    <span class="stat stat-icon">❤️</span>
                    <div id="base-health-bar-container"><div id="base-health-bar"></div></div>
                    <span id="base-health-stat" class="stat">100/100</span>
                </div>
                <div class="ui-group">
                     <span id="tower-count-stat" class="stat">Torres: 0/25</span>
                </div>
            </div>
            <div class="top-bar-row">
                 <div class="ui-group">
                    <span id="gold-stat" class="stat">  200</span>
                    <span id="diamonds-stat" class="stat">💎 5</span>
                </div>
                <div class="ui-group">
                    <h3 style="margin:0;">Oleada <span id="wave-number">0</span></h3>
                    <button id="wave-button">Iniciar</button>
                </div>
                <div class="ui-group">
                    <div class="button-wrapper">
                        <button id="meteor-button" class="ability-button">Meteorito<span class="gem-cost"></span></button>
                        <div id="meteor-button-flash" class="button-flash"></div>
                    </div>
                    <button id="gold-rush-button" class="ability-button">Fiebre Oro<span class="gem-cost"></span></button>
                    <button id="pause-button" class="control-button">Pausa</button>
                    <button id="speed-1x-button" class="control-button active">1x</button>
                    <button id="speed-2x-button" class="control-button">2x</button>
                    <button id="speed-5x-button" class="control-button">5x</button>
                    <div id="volume-control-container">
                        <button id="volume-button" class="control-button">🔊</button>
                        <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.5" class="hidden">
                    </div>
                </div>
            </div>
        </div>

        <div id="main-content">
            <div id="game-wrapper">
                <div id="screen-flash"></div>
                <div id="gold-rush-effect"></div>
                <canvas id="gameCanvas" width="800" height="520"></canvas>
            </div>

            <div id="side-panel">
                 <div class="button-wrapper">
                    <button id="arsenal-button" class="side-panel-button">Arsenal de Torres</button>
                    <div id="arsenal-button-flash" class="button-flash"></div>
                </div>
                <button id="bestiary-button" class="side-panel-button">Bestiario</button>
                <button id="powers-button" class="side-panel-button">Poderes</button>
                <button id="fullscreen-button" class="side-panel-button">Pantalla Completa</button>
                <button id="dev-tools-button" class="side-panel-button">Dev Tools</button>
                <button id="exit-to-menu-button" class="side-panel-button" style="background-color: #f44336;">Salir al Menú</button>
                <div id="fullscreen-helper">(En iPhone, usa Compartir > Añadir a pantalla de inicio)</div>
                <div id="game-explanation-bar">
                    <p><strong>Objetivo:</strong> ¡Sobrevive a las oleadas! Construye y mejora torres para defender tu base. Gana oro y XP para desbloquear más poder.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- MODALES -->
    <div id="play-options-modal" class="modal">
        <div class="modal-content">
            <h2>Jugar</h2>
            <div class="menu-buttons">
                <button id="continue-button" class="menu-button">Continuar</button>
                <button id="new-game-button" class="menu-button">Nueva Partida</button>
            </div>
            <button class="modal-close-button" style="top: 15px; right: 20px;">&times;</button>
        </div>
    </div>

    <div id="difficulty-modal" class="modal">
        <div class="modal-content">
            <h2>Selecciona la Dificultad</h2>
            <div class="menu-buttons">
                <button class="menu-button difficulty-select-button" data-difficulty="easy">Fácil</button>
                <p style="font-size: 0.8em; color: #ccc;">Enemigos más débiles y lentos. Torres más baratas y más oro.</p>
                <button class="menu-button difficulty-select-button" data-difficulty="normal">Normal</button>
                <p style="font-size: 0.8em; color: #ccc;">La experiencia de juego balanceada.</p>
                <button class="menu-button difficulty-select-button" data-difficulty="hard">Difícil</button>
                <p style="font-size: 0.8em; color: #ccc;">Enemigos más fuertes y rápidos. Torres más caras y menos oro.</p>
            </div>
        </div>
    </div>

    <div id="tutorial-prompt-modal" class="modal">
        <div class="modal-content">
            <h2>¡Bienvenido!</h2>
            <p>Parece que es tu primera vez. ¿Te gustaría ver el tutorial primero?</p>
            <div class="dont-show-again">
                <input type="checkbox" id="hide-tutorial-prompt-checkbox">
                <label for="hide-tutorial-prompt-checkbox">No volver a mostrar</label>
            </div>
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
                <button id="play-tutorial-button" class="modal-button">Jugar Tutorial</button>
                <button id="skip-tutorial-button" class="modal-button">Saltar</button>
            </div>
        </div>
    </div>

    <div id="game-over-modal" class="modal">
        <div class="modal-content game-over-content">
            <h2>Fin del Juego</h2>
            <p>Tu base ha sido destruida.</p>
            <p>Alcanzaste la oleada <span id="final-wave-stat"></span>.</p>
            <button class="modal-button" onclick="window.location.reload()">Jugar de Nuevo</button>
        </div>
    </div>

    <div id="victory-modal" class="modal">
        <div class="modal-content victory-content">
            <h2>¡VICTORIA!</h2>
            <p>¡Has superado el desafío principal al completar la oleada 25!</p>
            <p>¿Te atreves a continuar en el modo infinito?</p>
            <button id="continue-endless-button" class="modal-button">Continuar (Modo Infinito)</button>
        </div>
    </div>

    <div id="arsenal-modal" class="modal">
        <div class="modal-content">
            <button id="close-arsenal-x" class="modal-close-button">&times;</button>
            <h2>Arsenal de Torres</h2>
            <div id="arsenal-cards-container"></div>
            <button id="close-arsenal-button" class="modal-button">Cerrar</button>
        </div>
    </div>

    <div id="bestiary-modal" class="modal">
        <div class="modal-content">
            <button id="close-bestiary-x" class="modal-close-button">&times;</button>
            <h2>Bestiario</h2>
            <div id="bestiary-cards-container"></div>
            <button id="close-bestiary-button" class="modal-button">Cerrar</button>
        </div>
    </div>

    <div id="powers-modal" class="modal">
        <div class="modal-content">
            <button id="close-powers-x" class="modal-close-button">&times;</button>
            <h2>Poderes Especiales</h2>
            <div id="powers-cards-container"></div>
            <button id="close-powers-button" class="modal-button">Cerrar</button>
        </div>
    </div>

    <div id="meteor-unlock-modal" class="modal">
        <div class="modal-content">
            <h2>¡Habilidad Desbloqueada!</h2>
            <p>¡Has alcanzado la oleada 6 y desbloqueado el <strong>Meteorito</strong>!</p>
            <p>Úsalo para infligir daño masivo en un área. ¡Ideal contra jefes y grupos grandes!</p>
            <div class="dont-show-again">
                <input type="checkbox" id="hide-meteor-checkbox">
                <label for="hide-meteor-checkbox">No volver a mostrar</label>
            </div>
            <button id="close-meteor-unlock-button" class="modal-button" style="margin-top: 20px;">Entendido</button>
        </div>
    </div>

    <div id="tower-unlock-modal" class="modal">
        <div class="modal-content">
            <h2>¡Torre Desbloqueada!</h2>
            <p style="font-size: 4em; margin: 10px 0;" class="tower-unlock-emoji"></p>
            <p>¡Desbloqueaste la torre: <strong class="tower-unlock-name"></strong>!</p>
            <p class="tower-unlock-desc"></p>
            <p>¡Revisa el <strong>Arsenal de Torres</strong> para más detalles!</p>
            <button id="close-tower-unlock-button" class="modal-button" style="margin-top: 20px;">Entendido</button>
        </div>
    </div>

    <div id="tower-evolution-modal" class="modal">
        <div class="modal-content">
            <h2>¡Evolución Disponible!</h2>
            <p>Tu torre ha alcanzado su máximo potencial. ¡Elige una especialización!</p>
            <div id="evolution-options-container" style="display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
                <!-- Opciones de evolución se insertarán aquí -->
            </div>
             <p style="font-size: 0.9em; color: #ccc; margin-top: 20px;">Puedes ver los detalles de cada evolución en el <strong>Arsenal de Torres</strong>.</p>
            <button id="close-evolution-button" class="modal-button" style="margin-top: 20px;">Decidiré luego</button>
        </div>
    </div>

    <div id="dev-tools-modal" class="modal">
        <div class="modal-content">
             <button id="close-dev-tools-x" class="modal-close-button">&times;</button>
            <h2>Dev Tools</h2>
            <div class="dev-options">
                <button id="dev-resources" class="modal-button">Recursos Ilimitados</button>
                <button id="dev-health" class="modal-button">Vida Ilimitada</button>
                <button id="dev-cooldowns" class="modal-button">Sin Enfriamientos</button>
                <button id="dev-exit" class="modal-button" style="background-color: #f44336;">Salir Modo Developer</button>
            </div>
        </div>
    </div>

    <!-- Elementos del Tutorial Interactivo -->
    <div id="tutorial-overlay">
        <div id="tutorial-highlight"></div>
        <div id="tutorial-message-box">
            <p id="tutorial-message-text"></p>
            <button id="tutorial-next-step-button" class="modal-button" style="margin-top: 10px; display: none;">Entendido</button>
        </div>
    </div>
    
    <audio id="bgm" loop src="Music/BGM/battleThemeA.mp3"></audio>


    <script>
        // --- CONFIGURACIÓN DEL JUEGO ---
        const TILE_SIZE = 40;
        const cheats = {
            unlimitedResources: false,
            unlimitedHealth: false,
            noCooldowns: false,
        };
        const DIFFICULTY_MODIFIERS = {
            easy: { enemyHealth: 0.75, enemySpeed: 0.9, towerCost: 0.85, startingGold: 1.25 },
            normal: { enemyHealth: 1.0, enemySpeed: 1.0, towerCost: 1.0, startingGold: 1.0 },
            hard: { enemyHealth: 1.25, enemySpeed: 1.1, towerCost: 1.15, startingGold: 0.85 }
        };
        const MAPS = {
            'classic': [ { x: 0, y: 5 }, { x: 3, y: 5 }, { x: 3, y: 2 }, { x: 8, y: 2 }, { x: 8, y: 12 }, { x: 13, y: 12 }, { x: 13, y: 7 }, { x: 20, y: 7 } ],
            'serpentine': [ { x: 0, y: 2 }, { x: 17, y: 2 }, { x: 17, y: 5 }, { x: 2, y: 5 }, { x: 2, y: 8 }, { x: 17, y: 8 }, { x: 17, y: 11 }, { x: 0, y: 11 } ],
            'crossroads': [ { x: 0, y: 7 }, { x: 4, y: 7 }, { x: 4, y: 2 }, { x: 15, y: 2 }, { x: 15, y: 7 }, { x: 10, y: 7 }, { x: 10, y: 12 }, { x: 15, y: 12 }, { x: 15, y: 7 }, { x: 20, y: 7 } ],
            'direct': [ { x: 0, y: 7 }, { x: 10, y: 7 }, { x: 10, y: 2 }, { x: 20, y: 2 } ]
        };
        const AIR_PATHS = {
            'classic': [ { x: 0, y: 5 }, { x: 8, y: 5 }, { x: 8, y: 7 }, { x: 20, y: 7 } ],
            'serpentine': [ { x: 0, y: 2 }, { x: 10, y: 6 }, { x: 0, y: 11 } ],
            'crossroads': [ { x: 0, y: 7 }, { x: 10, y: 2 }, { x: 10, y: 12 }, { x: 20, y: 7 } ],
            'direct': [ { x: 0, y: 7 }, { x: 20, y: 2 } ]
        };
        const TOWER_TYPES = {
            'arrow': { 
                name: 'Flechas', emoji: '🏹', desc: 'Rápida y barata. La única defensa inicial contra enemigos aéreos.', cost: 50, damage: 15, range: 100, fireRate: 60, projectileSpeed: 5, color: '#8BC34A', projectileColor: '#CDDC39', unlockWave: 1, upgrade: { damage: 8, range: 10, fireRate: 5 }, canHitFlying: true,
                evolutions: {
                    level: 8,
                    paths: {
                        pathA: { name: 'Metralleta', emoji: '🎯', desc: 'Dispara ráfagas increíblemente rápidas a corto alcance.', damage: 19, range: 135, fireRate: 5, special: 'gatling' },
                        pathB: { name: 'Francotirador', emoji: '🔭', desc: 'Inflige daño masivo a un enorme alcance, pero muy lentamente. Prioriza enemigos de élite.', damage: 1013, range: 280, fireRate: 222, special: 'sniper' }
                    }
                }
            },
            'cannon': { 
                name: 'Cañón', emoji: '💣', desc: 'Lenta pero poderosa. Su daño en área es ideal contra grupos de enemigos terrestres.', cost: 120, damage: 40, range: 80, fireRate: 120, projectileSpeed: 4, color: '#607D8B', projectileColor: '#212121', unlockWave: 3, splashRadius: 65, upgrade: { damage: 25, range: 5, splashRadius: 8, fireRate: 10 }, canHitFlying: false,
                evolutions: {
                    level: 8,
                    paths: {
                        pathA: { name: 'Bomba Singular', emoji: '🌀', desc: 'No daña, pero atrae a los enemigos cercanos a un solo punto.', damage: 5, fireRate: 180, splashRadius: 120, special: 'pull', projectileColor: '#AB47BC' },
                        pathB: { name: 'Bomba Disforme', emoji: '🌌', desc: 'No daña, pero teletransporta a los enemigos hacia atrás en el camino. Tiene 18 disparos por oleada.', damage: 0, splashRadius: 80, special: 'teleport', shotsPerWave: 18, projectileColor: '#5C6BC0' }
                    }
                }
            },
            'acid': { name: 'Ácido', emoji: '🧪', desc: 'Aplica un veneno que daña con el tiempo. El daño del veneno escala con el daño de la torre.', cost: 100, damage: 12, range: 110, fireRate: 108, projectileSpeed: 5, color: '#7FFF00', projectileColor: '#ADFF2F', unlockWave: 6, acid: { multiplier: 0.08, duration: 180 }, upgrade: { damage: 6, acidMultiplier: 0.04, range: 10, fireRate: 7 }, canHitFlying: true },
            'ice': { name: 'Hielo', emoji: '❄️', desc: 'Aplica una ralentización en un área que se vuelve más potente con el daño. Mejorar el rango aumenta el área de efecto.', cost: 150, damage: 5, range: 120, fireRate: 90, projectileSpeed: 6, color: '#03A9F4', projectileColor: '#B3E5FC', unlockWave: 9, slow: { baseMultiplier: 0.6, damageScale: 0.002, maxSlow: 0.35, duration: 120 }, slowRadius: 15, upgrade: { damage: 5, range: 10, slowRadius: 10, fireRate: 8 }, canHitFlying: false }
        };
        const ENEMY_TYPES = {
            'standard': { name: 'Esbirro', desc: 'Unidad básica terrestre. Débil pero numerosa.', health: 1, speed: 1, value: 1, color: '#E53935', size: 0.8, baseDamage: 10, isFlying: false },
            'fast': { name: 'Corredor', desc: 'Rápido y pequeño. Difícil de acertar para torres lentas.', health: 0.7, speed: 1.8, value: 1.2, color: '#FDD835', size: 0.6, baseDamage: 10, isFlying: false },
            'flying': { name: 'Espectro', desc: 'Ignora el camino y vuela directo a la base. Solo algunas torres pueden atacarlo.', health: 0.8, speed: 1.2, value: 1.5, color: '#E0E0E0', size: 0.7, baseDamage: 15, isFlying: true },
            'healer': { name: 'Sanador', desc: 'Cura a los aliados cercanos. ¡Una prioridad alta!', health: 1.2, speed: 0.8, value: 3, color: '#FF80AB', size: 0.9, baseDamage: 5, isFlying: false },
            'disabler': { name: 'Disruptor', desc: 'Desactiva temporalmente las torres cercanas con un pulso electromagnético.', health: 1.5, speed: 0.9, value: 4, color: '#D500F9', size: 0.9, baseDamage: 5, isFlying: false },
            'boss': { name: 'Jefe', desc: 'Extremadamente resistente y peligroso. ¡Prepárate bien!', health: 15, speed: 0.6, value: 20, color: '#6A1B9A', size: 1.5, baseDamage: 0.55, isFlying: false }
        };
        const ABILITIES = {
            meteor: { cost: 4, cooldown: (60 * 30) * 3, damage: (300 * 3.5) * 2, radius: 160 },
            goldRush: { cost: 2, cooldown: 60 * 45, duration: 60 * 8, multiplier: 2.8 }
        };

        class Game {
            constructor(canvas, mapId, savedData = null, isTutorial = false, difficulty = 'normal') {
                this.canvas = canvas; this.ctx = canvas.getContext('2d');
                this.width = canvas.width; this.height = canvas.height;
                this.mapId = mapId;
                this.isTutorial = isTutorial;
                this.tutorialManager = null;
                this.grid = []; 
                this.path = MAPS[mapId].map(p => ({ x: p.x * TILE_SIZE, y: p.y * TILE_SIZE }));
                this.airPath = AIR_PATHS[mapId].map(p => ({ x: p.x * TILE_SIZE, y: p.y * TILE_SIZE }));
                this.towers = []; this.enemies = []; this.projectiles = []; this.effects = []; 
                this.waveNumber = 0; 
                this.diamonds = 5;
                this.baseHealth = 100; this.maxBaseHealth = 100;
                this.waveInProgress = false;
                this.isPaused = false; this.gameSpeed = 1;
                this.speedBeforePause = 1;
                this.activeAbility = null;
                this.meteorCooldown = 0; this.goldRushCooldown = 0; this.goldRushTimer = 0;
                this.activeMenu = { isOpen: false, type: null, x: 0, y: 0, options: [], target: null };
                this.gameWon = false;
                this.selectedTower = null;
                this.frameCount = 0;
                this.discoveredEnemies = new Set();
                this.showPathArrows = true; // Para el indicador de camino
                this.MAX_TOWERS = 25;
                this.towerCounts = { arrow: 0, cannon: 0, acid: 0, ice: 0 };
                this.unlockedTowers = new Set(['arrow']);

                this.difficulty = difficulty;
                const modifiers = DIFFICULTY_MODIFIERS[this.difficulty];
                this.gold = savedData ? savedData.gold : 200 * modifiers.startingGold;


                this.camera = { x: 0, y: 0, scale: 1 };
                this.mousePos = { x: 0, y: 0 };
                this.scale = 1;

                this.createGridAndPath();

                if (savedData && savedData.towers) {
                    this.loadState(savedData);
                }

                if (this.isTutorial) {
                    this.tutorialManager = new TutorialManager(this);
                }

                this.init();
            }

            init() {
                this.updateUI(); 
                this.gameLoop();
            }
            
            gameLoop() {
                if (!this.isPaused) for (let i = 0; i < this.gameSpeed; i++) this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }

            update() {
                if (this.isTutorial && this.tutorialManager.isPaused) return;

                this.frameCount++;
                const cdMultiplier = this.waveNumber >= 25 ? 0.25 : 1;
                if(this.meteorCooldown > 0) this.meteorCooldown--;
                if(this.goldRushCooldown > 0) this.goldRushCooldown--;
                if(this.goldRushTimer > 0) {
                    this.goldRushTimer--;
                    if (this.goldRushTimer === 0) {
                        document.getElementById('gold-rush-effect').classList.remove('active');
                        document.getElementById('gold-stat').classList.remove('gold-rush-active');
                    }
                }
                this.updateAbilityButtons();

                if (!this.waveInProgress) return;

                this.enemies.forEach(e => e.update(this.enemies, this.towers)); 
                this.towers.forEach(t => t.update(this.enemies));
                this.projectiles.forEach(p => p.update()); this.effects.forEach(e => e.update());

                this.enemies = this.enemies.filter(e => e.active); this.projectiles = this.projectiles.filter(p => p.active); this.effects = this.effects.filter(e => e.active);

                if (this.waveInProgress && this.enemies.length === 0) {
                    this.waveInProgress = false;
                    this.diamonds += this.waveNumber >= 25 ? 3 : 1.2;
                    
                    if (this.isTutorial) {
                        this.tutorialManager.checkCondition('wave_cleared');
                    } else if (this.waveNumber === 25 && !this.gameWon) {
                        this.gameWon = true;
                        this.showVictoryScreen();
                    } else {
                        document.getElementById('wave-button').disabled = false;
                        this.pauseGame();
                    }
                    if (!this.isTutorial) this.saveState();
                    this.updateUI();
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                this.drawPath(); 
                this.drawGrid();

                if (this.showPathArrows) {
                    this.drawPathArrows();
                }
                
                if (this.selectedTower) {
                    this.ctx.beginPath();
                    this.ctx.arc(this.selectedTower.x, this.selectedTower.y, this.selectedTower.typeInfo.range, 0, Math.PI * 2);
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    this.ctx.fill();
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    this.ctx.stroke();
                }

                this.towers.forEach(t => t.draw(this.ctx, this.frameCount)); 
                this.enemies.forEach(e => e.draw(this.ctx, this.frameCount));
                this.projectiles.forEach(p => p.draw(this.ctx)); 
                this.effects.forEach(e => e.draw(this.ctx));
                
                if (this.activeMenu.isOpen) this.drawMenu();
                
                if (this.activeAbility === 'meteor' && this.mousePos) {
                    const rect = this.canvas.getBoundingClientRect();
                    const canvasX = (this.mousePos.x - rect.left) / this.scale;
                    const canvasY = (this.mousePos.y - rect.top) / this.scale;

                    this.ctx.beginPath(); this.ctx.arc(canvasX, canvasY, ABILITIES.meteor.radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = 'rgba(255, 0, 100, 0.3)'; this.ctx.fill();
                }
            }

            startWave() {
                if (this.waveInProgress) return;

                if (this.isTutorial) {
                    if (!this.tutorialManager.checkCondition('wave_started')) {
                        return; 
                    }
                } else {
                    this.resumeGame();
                }
                
                this.waveNumber++;
                this.maxBaseHealth += 10;
                this.baseHealth = Math.min(this.maxBaseHealth, this.baseHealth + 10);

                // Resetear disparos de torres especiales
                this.towers.forEach(t => {
                    if (t.typeInfo.shotsPerWave) {
                        t.shotsLeft = t.typeInfo.shotsPerWave;
                    }
                });

                // Check for tower unlocks
                for (const type in TOWER_TYPES) {
                    const towerInfo = TOWER_TYPES[type];
                    if (this.waveNumber === towerInfo.unlockWave && !this.unlockedTowers.has(type)) {
                        this.unlockedTowers.add(type);
                        this.showTowerUnlockModal(type);
                    }
                }


                if (this.waveNumber === 1) {
                    this.showPathArrows = false;
                }
                
                if (!this.isTutorial && this.waveNumber === 25) this.triggerWave25Alert();
                
                if (!this.isTutorial && this.waveNumber === 6 && !localStorage.getItem('hideMeteorUnlock')) {
                    this.showMeteorUnlockModal();
                }

                this.waveInProgress = true; document.getElementById('wave-button').disabled = true; 
                
                const waveConfig = this.isTutorial ? this.tutorialManager.getWaveConfig() : this.getWaveConfig(this.waveNumber);

                const baseHealth = 50 + this.waveNumber * 15; const baseValue = 10 + this.waveNumber * 2;
                waveConfig.forEach((conf, i) => {
                    this.discoveredEnemies.add(conf.type);
                    const spawnDelay = (conf.type === 'boss' && this.waveNumber >= 25) ? 180 : 60;
                    this.enemies.push(new Enemy(this, -i * spawnDelay, this.path[0].y, baseHealth, baseValue, conf.type, conf.isTutorial));
                });
                this.updateUI();
            }
            
            showMeteorUnlockModal() {
                this.pauseGame();
                document.getElementById('meteor-unlock-modal').style.display = 'flex';
                const flashEl = document.getElementById('meteor-button-flash');
                flashEl.classList.add('flashing');
                setTimeout(() => {
                    flashEl.classList.remove('flashing');
                }, 5000);
            }

            showTowerUnlockModal(type) {
                this.pauseGame();
                const towerInfo = TOWER_TYPES[type];
                const modal = document.getElementById('tower-unlock-modal');
                modal.querySelector('.tower-unlock-emoji').textContent = towerInfo.emoji;
                modal.querySelector('.tower-unlock-name').textContent = towerInfo.name;
                modal.querySelector('.tower-unlock-desc').textContent = towerInfo.desc;
                modal.style.display = 'flex';

                const flashEl = document.getElementById('arsenal-button-flash');
                flashEl.classList.add('flashing');
                setTimeout(() => flashEl.classList.remove('flashing'), 5000);

                const closeButton = modal.querySelector('#close-tower-unlock-button');
                closeButton.onclick = () => {
                    modal.style.display = 'none';
                    if (!this.isTutorial) this.resumeGame();
                };
            }

            showEvolutionModal(tower) {
                this.pauseGame();
                const modal = document.getElementById('tower-evolution-modal');
                const container = document.getElementById('evolution-options-container');
                container.innerHTML = ''; // Limpiar opciones previas

                const evoInfo = tower.typeInfo.evolutions.paths;

                Object.keys(evoInfo).forEach(pathKey => {
                    const path = evoInfo[pathKey];
                    const option = document.createElement('div');
                    option.className = 'info-card'; // Reutilizar estilo
                    option.innerHTML = `
                        <div class="info-card-header">
                            <h4>${path.emoji} ${path.name}</h4>
                        </div>
                        <p>${path.desc}</p>
                        <button class="modal-button evolve-button" data-path="${pathKey}">Evolucionar (💰${tower.upgradeCost})</button>
                    `;
                    container.appendChild(option);
                });
                
                modal.querySelectorAll('.evolve-button').forEach(button => {
                    button.onclick = (e) => {
                        const path = e.target.dataset.path;
                        tower.evolve(path);
                        modal.style.display = 'none';
                        if (!this.isTutorial) this.resumeGame();
                    };
                });

                document.getElementById('close-evolution-button').onclick = () => {
                     modal.style.display = 'none';
                     if (!this.isTutorial) this.resumeGame();
                };

                modal.style.display = 'flex';
                const flashEl = document.getElementById('arsenal-button-flash');
                flashEl.classList.add('flashing');
                setTimeout(() => flashEl.classList.remove('flashing'), 5000);
            }

            getWaveConfig(waveNum) {
                if (waveNum > 25) {
                    let numBosses;
                    if (waveNum <= 27) numBosses = 1;
                    else numBosses = 2 + Math.floor((waveNum - 28) / 3);
                    return Array(numBosses).fill({ type: 'boss' });
                }
                
                let config = [];
                // Jefes solo en múltiplos de 5
                if (waveNum > 0 && waveNum % 5 === 0) {
                    const isTutorialBoss = (waveNum === 5);
                    config.push({ type: 'boss', isTutorial: isTutorialBoss });
                }

                const enemyCount = 5 + waveNum * 2;
                for (let i = 0; i < enemyCount; i++) {
                    let type = 'standard';
                    const rand = Math.random();

                    if (waveNum >= 20 && rand < 0.15) type = 'disabler';
                    else if (waveNum >= 15 && rand < 0.25) type = 'healer';
                    else if (waveNum >= 10 && rand < 0.35) type = 'flying';
                    else if (waveNum >= 2 && rand < 0.45) type = 'fast';
                    
                    config.push({ type });
                }
                return config;
            }
            
            togglePause() { 
                if (this.isTutorial) return;
                if (this.isPaused) {
                    this.resumeGame();
                } else {
                    this.pauseGame();
                }
            }
            pauseGame() { 
                if (!this.isPaused) {
                    this.speedBeforePause = this.gameSpeed;
                }
                this.isPaused = true; 
                document.getElementById('pause-button').textContent = 'Reanudar'; 
            }
            resumeGame() { 
                this.isPaused = false; 
                document.getElementById('pause-button').textContent = 'Pausa'; 
                this.setSpeed(this.speedBeforePause);
            }
            
            setSpeed(speed) { 
                if (this.isTutorial) return;
                this.gameSpeed = speed; 
                this.speedBeforePause = speed;
                document.getElementById('speed-1x-button').classList.toggle('active', speed === 1); 
                document.getElementById('speed-2x-button').classList.toggle('active', speed === 2);
                document.getElementById('speed-5x-button').classList.toggle('active', speed === 5);
            }

            triggerWave25Alert() {
                const flashEl = document.getElementById('screen-flash'); let count = 0;
                const interval = setInterval(() => {
                    flashEl.style.opacity = flashEl.style.opacity === '0.4' ? '0' : '0.4'; count++;
                    if (count >= 6) { clearInterval(interval); flashEl.style.opacity = '0'; }
                }, 250);
            }

            activateMeteor() {
                if (this.activeAbility === 'meteor') {
                    this.activeAbility = null;
                    this.canvas.style.cursor = 'default';
                    return;
                }
                const canAfford = this.diamonds >= ABILITIES.meteor.cost || cheats.unlimitedResources;
                const isReady = this.meteorCooldown <= 0 || cheats.noCooldowns;

                if (canAfford && isReady) {
                    this.activeAbility = 'meteor';
                    this.canvas.style.cursor = 'crosshair';
                    this.closeMenu();
                }
            }
            triggerMeteor(x, y) {
                const baseDamage = ABILITIES.meteor.damage;
                const finalDamage = baseDamage * (1 + (this.waveNumber - 1) * 0.25);

                if (!cheats.unlimitedResources) {
                    this.diamonds -= ABILITIES.meteor.cost; 
                }
                if (!cheats.noCooldowns) {
                    this.meteorCooldown = ABILITIES.meteor.cooldown * (this.waveNumber >= 25 ? 0.25 : 1); 
                }
                this.activeAbility = null;
                this.canvas.style.cursor = 'default';
                this.effects.push(new MeteorEffect(this, x, y, ABILITIES.meteor.radius, finalDamage)); 
                this.updateUI();
            }
            activateGoldRush() {
                const canAfford = this.diamonds >= ABILITIES.goldRush.cost || cheats.unlimitedResources;
                const isReady = this.goldRushCooldown <= 0 || cheats.noCooldowns;

                if (canAfford && isReady) {
                    if (!cheats.unlimitedResources) {
                        this.diamonds -= ABILITIES.goldRush.cost;
                    }
                    if (!cheats.noCooldowns) {
                        this.goldRushCooldown = ABILITIES.goldRush.cooldown * (this.waveNumber >= 25 ? 0.25 : 1);
                    }
                    this.goldRushTimer = ABILITIES.goldRush.duration;
                    document.getElementById('gold-rush-effect').classList.add('active');
                    document.getElementById('gold-stat').classList.add('gold-rush-active');
                    this.updateUI();
                }
            }
            
            createGridAndPath() {
                const cols = this.width / TILE_SIZE;
                const rows = this.height / TILE_SIZE;

                // 1. Inicializar todas las celdas como no construibles
                for (let y = 0; y < rows; y++) {
                    this.grid[y] = [];
                    for (let x = 0; x < cols; x++) {
                        this.grid[y][x] = { buildable: false, x: x, y: y };
                    }
                }

                const buildDistance = 2; // 2 celdas a cada lado del camino

                // 2. Marcar las celdas adyacentes al camino como construibles
                for (let i = 0; i < this.path.length - 1; i++) {
                    let startNode = this.path[i];
                    let endNode = this.path[i + 1];
                    let startX = Math.floor(startNode.x / TILE_SIZE);
                    let startY = Math.floor(startNode.y / TILE_SIZE);
                    let endX = Math.floor(endNode.x / TILE_SIZE);
                    let endY = Math.floor(endNode.y / TILE_SIZE);

                    if (startY === endY) { // Camino horizontal
                        for (let x = Math.min(startX, endX); x <= Math.max(startX, endX); x++) {
                            for (let d = 1; d <= buildDistance; d++) {
                                if (this.grid[startY - d] && this.grid[startY - d][x]) this.grid[startY - d][x].buildable = true;
                                if (this.grid[startY + d] && this.grid[startY + d][x]) this.grid[startY + d][x].buildable = true;
                            }
                        }
                    } else if (startX === endX) { // Camino vertical
                        for (let y = Math.min(startY, endY); y <= Math.max(startY, endY); y++) {
                            for (let d = 1; d <= buildDistance; d++) {
                                if (this.grid[y] && this.grid[y][startX - d]) this.grid[y][startX - d].buildable = true;
                                if (this.grid[y] && this.grid[y][startX + d]) this.grid[y][startX + d].buildable = true;
                            }
                        }
                    }
                }

                // 3. Marcar el camino en sí como no construible (para anular las esquinas)
                for (let i = 0; i < this.path.length - 1; i++) {
                    let s = this.path[i], e = this.path[i+1];
                    let sX = Math.floor(s.x / TILE_SIZE), sY = Math.floor(s.y / TILE_SIZE);
                    let eX = Math.floor(e.x / TILE_SIZE), eY = Math.floor(e.y / TILE_SIZE);
                    for (let x = Math.min(sX, eX); x <= Math.max(sX, eX); x++) {
                        for (let y = Math.min(sY, eY); y <= Math.max(sY, eY); y++) {
                            if (this.grid[y] && this.grid[y][x]) this.grid[y][x].buildable = false;
                        }
                    }
                }
            }

            drawGrid() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                 for (let y = 0; y < this.grid.length; y++) {
                    for (let x = 0; x < this.grid[y].length; x++) {
                        if (this.grid[y][x].buildable) {
                           this.ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        }
                    }
                }
            }
            
            drawPath() {
                this.ctx.fillStyle = '#404040';
                for (let i = 0; i < this.path.length - 1; i++) {
                    let s = this.path[i], e = this.path[i+1];
                    let sX = Math.floor(s.x / TILE_SIZE), sY = Math.floor(s.y / TILE_SIZE);
                    let eX = Math.floor(e.x / TILE_SIZE), eY = Math.floor(e.y / TILE_SIZE);
                    for (let x = Math.min(sX, eX); x <= Math.max(sX, eX); x++) {
                        for (let y = Math.min(sY, eY); y <= Math.max(sY, eY); y++) {
                            this.ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        }
                    }
                }
            }

            drawPathArrows() {
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                const arrowSize = 10;
                const arrowSpacing = 50; // pixels between arrows

                for (let i = 0; i < this.path.length - 1; i++) {
                    const start = this.path[i];
                    const end = this.path[i+1];

                    const dx = end.x - start.x;
                    const dy = end.y - start.y;
                    const segmentLength = Math.hypot(dx, dy);
                    const angle = Math.atan2(dy, dx);

                    // Calculate how many arrows fit and draw them
                    for (let dist = arrowSpacing / 2; dist < segmentLength; dist += arrowSpacing) {
                        const x = start.x + (dx / segmentLength) * dist + TILE_SIZE / 2; // Center on path
                        const y = start.y + (dy / segmentLength) * dist + TILE_SIZE / 2; // Center on path

                        this.ctx.save();
                        this.ctx.translate(x, y);
                        this.ctx.rotate(angle);

                        // Draw triangle
                        this.ctx.beginPath();
                        this.ctx.moveTo(-arrowSize, -arrowSize / 2);
                        this.ctx.lineTo(0, 0);
                        this.ctx.lineTo(-arrowSize, arrowSize / 2);
                        this.ctx.closePath();
                        this.ctx.fill();

                        this.ctx.restore();
                    }
                }
            }
            
            canBuildAt(gX, gY) { return this.grid[gY] && this.grid[gY][gX] && this.grid[gY][gX].buildable; }

            handleCanvasClick(x, y) {
                if (this.isTutorial) {
                    const tutorialHandled = this.tutorialManager.handleInput('canvas_click', { x, y });
                    if (tutorialHandled) {
                        // The tutorial might advance and immediately want us to open the build menu
                        const gX = Math.floor(x / TILE_SIZE);
                        const gY = Math.floor(y / TILE_SIZE);
                        if (this.canBuildAt(gX, gY)) {
                            this.openBuildMenu(gX, gY);
                        }
                        return; 
                    }
                }
                
                const clickX = x;
                const clickY = y;

                if (this.activeAbility === 'meteor') { this.triggerMeteor(clickX, clickY); return; }
                if (this.activeMenu.isOpen) {
                    const clickedOnMenu = this.activeMenu.options.some(option => {
                        const dx = clickX - option.x; const dy = clickY - option.y;
                        if (dx * dx + dy * dy < option.radius * option.radius) {
                            option.action(); this.closeMenu(); return true;
                        }
                        return false;
                    });
                    if (clickedOnMenu) return;
                }
                
                const gX = Math.floor(clickX / TILE_SIZE);
                const gY = Math.floor(clickY / TILE_SIZE);
                const clickedTower = this.towers.find(t => t.gridX === gX && t.gridY === gY);

                if (clickedTower) {
                    if (this.selectedTower === clickedTower) {
                        this.closeMenu();
                    } else {
                        this.selectedTower = clickedTower;
                        this.openUpgradeMenu(clickedTower);
                    }
                } else if (this.canBuildAt(gX, gY)) {
                    if (this.activeMenu.isOpen && this.activeMenu.type === 'build' && this.activeMenu.target.gridX === gX && this.activeMenu.target.gridY === gY) {
                         this.closeMenu();
                    } else {
                        this.closeMenu();
                        this.openBuildMenu(gX, gY);
                    }
                } else {
                    this.closeMenu();
                }
            }
            
            enemyDefeated(enemy) {
                const goldGain = Math.floor(enemy.value * (this.goldRushTimer > 0 ? ABILITIES.goldRush.multiplier : 1) * 0.94);
                this.gold += goldGain;
                const isElite = ['boss', 'healer', 'disabler'].includes(enemy.type);
                this.baseHealth = Math.min(this.maxBaseHealth, this.baseHealth + (isElite ? 6 : 1));
                this.updateUI();
            }
            
            damageBase(amount) {
                if (cheats.unlimitedHealth) return;
                this.baseHealth -= amount; this.updateUI();
                if (this.baseHealth <= 0) this.gameOver();
            }

            gameOver() {
                if (this.isTutorial) {
                    this.tutorialManager.end();
                    return;
                }
                this.isPaused = true; this.waveInProgress = false;
                document.getElementById('final-wave-stat').textContent = this.waveNumber; document.getElementById('game-over-modal').style.display = 'flex';
            }

            showVictoryScreen() {
                this.isPaused = true;
                document.getElementById('victory-modal').style.display = 'flex';
            }
            
            continueEndlessMode() {
                document.getElementById('victory-modal').style.display = 'none';
                document.getElementById('wave-button').disabled = false;
                this.pauseGame();
            }

            updateUI() {
                document.getElementById('gold-stat').textContent = `💰 ${Math.floor(this.gold)}`;
                document.getElementById('diamonds-stat').textContent = `💎 ${Math.floor(this.diamonds)}`;
                document.getElementById('base-health-stat').textContent = `${Math.max(0, Math.ceil(this.baseHealth))}/${this.maxBaseHealth}`;
                document.getElementById('base-health-bar').style.width = `${(this.baseHealth / this.maxBaseHealth) * 100}%`;
                document.getElementById('wave-number').textContent = this.waveNumber;
                document.getElementById('tower-count-stat').textContent = `Torres: ${this.towers.length}/${this.MAX_TOWERS}`;
            }

            updateAbilityButtons() {
                const meteorBtn = document.getElementById('meteor-button'); 
                const goldRushBtn = document.getElementById('gold-rush-button');
                
                meteorBtn.parentElement.style.display = this.waveNumber >= 6 || this.isTutorial ? 'block' : 'none';

                meteorBtn.querySelector('.gem-cost').textContent = `(💎 ${ABILITIES.meteor.cost})`;
                goldRushBtn.querySelector('.gem-cost').textContent = `(💎 ${ABILITIES.goldRush.cost})`;

                if (cheats.noCooldowns) {
                    this.meteorCooldown = 0;
                    this.goldRushCooldown = 0;
                }

                this.updateButtonCooldown(meteorBtn, this.meteorCooldown); 
                this.updateButtonCooldown(goldRushBtn, this.goldRushCooldown);
                meteorBtn.disabled = this.diamonds < ABILITIES.meteor.cost || this.meteorCooldown > 0;
                goldRushBtn.disabled = this.diamonds < ABILITIES.goldRush.cost || this.goldRushCooldown > 0;
            }

            updateButtonCooldown(button, currentCD) {
                let cdText = button.querySelector('.cooldown-text');
                if (currentCD > 0) {
                    if (!cdText) { cdText = document.createElement('span'); cdText.className = 'cooldown-text'; button.appendChild(cdText); }
                    cdText.textContent = Math.ceil(currentCD / 60);
                } else if (cdText) { button.removeChild(cdText); }
            }

            openBuildMenu(gridX, gridY) {
                this.selectedTower = null;
                const menuX = gridX * TILE_SIZE + TILE_SIZE / 2; const menuY = gridY * TILE_SIZE + TILE_SIZE / 2;
                const options = [];
                let angle = -Math.PI / 2;
                const availableTowers = Object.keys(TOWER_TYPES).filter(type => this.unlockedTowers.has(type));
                const angleStep = (Math.PI * 2) / availableTowers.length;
                
                const modifiers = DIFFICULTY_MODIFIERS[this.difficulty];

                for (const type of availableTowers) {
                    const towerInfo = TOWER_TYPES[type];
                    const baseCost = towerInfo.cost * modifiers.towerCost;
                    const currentCost = Math.floor(baseCost * (1.15 ** this.towerCounts[type]));
                    options.push({
                        x: menuX + Math.cos(angle) * 50, y: menuY + Math.sin(angle) * 50, radius: 20,
                        label: towerInfo.name, cost: currentCost, color: towerInfo.color,
                        action: () => this.buildTower(gridX, gridY, type)
                    });
                    angle += angleStep;
                }
                this.activeMenu = { isOpen: true, type: 'build', x: menuX, y: menuY, options, target: {gridX, gridY} };
                if (this.isTutorial) this.tutorialManager.checkCondition('build_menu_opened');
            }

            openUpgradeMenu(tower) {
                const menuX = tower.x; const menuY = tower.y;
                
                if (tower.upgradeCount >= tower.MAX_UPGRADES && !tower.isEvolved && tower.typeInfo.evolutions) {
                    this.showEvolutionModal(tower);
                    return;
                }

                const upgradeOption = {
                    x: menuX, y: menuY - 50, radius: 20, label: 'Mejorar',
                    cost: tower.upgradeCost,
                    color: tower.upgradeCount >= tower.MAX_UPGRADES ? '#555' : '#FFC107', // Grey out if maxed
                    action: () => {
                        if (tower.upgradeCount < tower.MAX_UPGRADES) {
                            this.upgradeTower(tower);
                        }
                    }
                };

                const options = [
                    upgradeOption,
                    { x: menuX, y: menuY + 50, radius: 20, label: 'Vender', cost: Math.floor(tower.totalInvestedGold * 0.7), color: '#4CAF50', action: () => this.sellTower(tower) }
                ];
                this.activeMenu = { isOpen: true, type: 'upgrade', x: menuX, y: menuY, options, target: tower };
                if (this.isTutorial) this.tutorialManager.checkCondition('upgrade_menu_opened');
            }
            
            openEvolveMenu(tower) {
                const menuX = tower.x; const menuY = tower.y;
                const evoPaths = tower.typeInfo.evolutions.paths;
                const options = [
                    { x: menuX - 45, y: menuY - 45, radius: 20, label: evoPaths.pathA.name, cost: tower.upgradeCost, color: '#AD1457', action: () => tower.evolve('pathA') },
                    { x: menuX + 45, y: menuY - 45, radius: 20, label: evoPaths.pathB.name, cost: tower.upgradeCost, color: '#1565C0', action: () => tower.evolve('pathB') },
                    { x: menuX, y: menuY + 50, radius: 20, label: 'Vender', cost: Math.floor(tower.totalInvestedGold * 0.7), color: '#4CAF50', action: () => this.sellTower(tower) }
                ];
                this.activeMenu = { isOpen: true, type: 'evolve', x: menuX, y: menuY, options, target: tower };
            }

            closeMenu() { 
                this.activeMenu.isOpen = false; 
                this.activeMenu.type = null;
                this.activeMenu.target = null;
                this.selectedTower = null;
                this.canvas.style.cursor = 'default';
            }

            drawMenu() {
                this.ctx.font = 'bold 12px Segoe UI'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle';
                this.activeMenu.options.forEach(opt => {
                    this.ctx.beginPath(); this.ctx.arc(opt.x, opt.y, opt.radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = opt.color; this.ctx.globalAlpha = 0.8; this.ctx.fill(); this.ctx.globalAlpha = 1;
                    this.ctx.strokeStyle = 'white'; this.ctx.stroke();
                    this.ctx.fillStyle = 'white';
                    this.ctx.fillText(opt.label, opt.x, opt.y - 8);

                    if (opt.label === 'Mejorar' && this.activeMenu.target.upgradeCount >= this.activeMenu.target.MAX_UPGRADES) {
                        this.ctx.font = 'bold 14px Segoe UI';
                        this.ctx.fillText('MAX', opt.x, opt.y + 8);
                        this.ctx.font = 'bold 12px Segoe UI';
                    } else {
                        this.ctx.fillText(`💰 ${opt.cost}`, opt.x, opt.y + 8);
                    }
                });
            }

            buildTower(gridX, gridY, type) {
                if (this.towers.length >= this.MAX_TOWERS) {
                    return;
                }
                const modifiers = DIFFICULTY_MODIFIERS[this.difficulty];
                const towerInfo = TOWER_TYPES[type];
                const baseCost = towerInfo.cost * modifiers.towerCost;
                const currentCost = Math.floor(baseCost * (1.15 ** this.towerCounts[type]));

                if (this.gold >= currentCost || cheats.unlimitedResources) {
                    if (!cheats.unlimitedResources) {
                        this.gold -= currentCost; 
                    }
                    this.towers.push(new Tower(this, gridX, gridY, type));
                    this.towerCounts[type]++;
                    this.grid[gridY][gridX].buildable = false; 
                    this.updateUI();
                    if (this.isTutorial) this.tutorialManager.checkCondition('tower_built', { type: type });
                }
            }

            upgradeTower(tower) {
                if ((this.gold >= tower.upgradeCost || cheats.unlimitedResources) && tower.upgradeCount < tower.MAX_UPGRADES) { 
                    if (!cheats.unlimitedResources) {
                        this.gold -= tower.upgradeCost;
                    } 
                    tower.upgrade(); 
                    this.updateUI(); 
                }
            }

            sellTower(tower) {
                this.gold += Math.floor(tower.totalInvestedGold * 0.7);
                this.grid[tower.gridY][tower.gridX].buildable = true;
                this.towerCounts[tower.typeKey]--;
                this.towers = this.towers.filter(t => t !== tower); 
                this.updateUI();
            }

            // --- Funciones de Guardado y Carga ---
            saveState() {
                const simplifiedTowers = this.towers.map(t => ({
                    gridX: t.gridX,
                    gridY: t.gridY,
                    typeKey: t.typeKey,
                    upgradeCount: t.upgradeCount,
                    totalInvestedGold: t.totalInvestedGold,
                    isEvolved: t.isEvolved,
                    typeInfo: t.typeInfo,
                    upgradeCost: t.upgradeCost
                }));

                const state = {
                    mapId: this.mapId,
                    waveNumber: this.waveNumber,
                    gold: this.gold,
                    diamonds: this.diamonds,
                    baseHealth: this.baseHealth,
                    maxBaseHealth: this.maxBaseHealth,
                    discoveredEnemies: Array.from(this.discoveredEnemies),
                    towerCounts: this.towerCounts,
                    unlockedTowers: Array.from(this.unlockedTowers),
                    difficulty: this.difficulty,
                    towers: simplifiedTowers
                };
                localStorage.setItem('towerDefenseProgress', JSON.stringify(state));
            }

            loadState(savedData) {
                this.mapId = savedData.mapId;
                this.waveNumber = savedData.waveNumber;
                this.gold = savedData.gold;
                this.diamonds = savedData.diamonds;
                this.baseHealth = savedData.baseHealth;
                this.maxBaseHealth = savedData.maxBaseHealth;
                this.discoveredEnemies = new Set(savedData.discoveredEnemies);
                this.towerCounts = savedData.towerCounts || { arrow: 0, cannon: 0, acid: 0, ice: 0 };
                this.difficulty = savedData.difficulty || 'normal';

                if (savedData.unlockedTowers) {
                    this.unlockedTowers = new Set(savedData.unlockedTowers);
                } else {
                    this.unlockedTowers = new Set(['arrow']);
                    for (const type in TOWER_TYPES) {
                        if (this.waveNumber >= TOWER_TYPES[type].unlockWave) {
                            this.unlockedTowers.add(type);
                        }
                    }
                }

                this.towers = savedData.towers.map(tData => {
                    const tower = new Tower(this, tData.gridX, tData.gridY, tData.typeKey);

                    tower.upgradeCount = tData.upgradeCount;
                    tower.totalInvestedGold = tData.totalInvestedGold;

                    if (tData.isEvolved) {
                        tower.isEvolved = tData.isEvolved;
                        tower.typeInfo = tData.typeInfo;
                        tower.upgradeCost = tData.upgradeCost;
                    } else {
                        for(let i = 0; i < tower.upgradeCount; i++) {
                            tower.applyUpgradeStats();
                            tower.upgradeCost = Math.floor(tower.upgradeCost * 1.7);
                        }
                    }
                    
                    this.grid[tData.gridY][tData.gridX].buildable = false;
                    return tower;
                });
            }
        }

        class Enemy {
            constructor(game, x, y, baseHealth, baseValue, type, isTutorialBoss = false) {
                this.game = game; this.x = x; this.y = y; this.type = type;
                const typeData = ENEMY_TYPES[type];
                const modifiers = DIFFICULTY_MODIFIERS[game.difficulty];

                this.isFlying = typeData.isFlying;
                this.speed = typeData.speed * (1 + game.waveNumber * 0.05) * modifiers.enemySpeed;
                
                let healthMultiplier = 1 + (game.waveNumber * 0.075);
                
                if (game.waveNumber <= 5) {
                    healthMultiplier *= 0.7;
                    this.speed *= 0.85;
                }

                this.maxHealth = Math.floor(baseHealth * typeData.health * healthMultiplier * modifiers.enemyHealth); 
                this.health = this.maxHealth;
                this.value = Math.floor(baseValue * typeData.value);
                let damageToDeal = typeData.baseDamage;

                if (isTutorialBoss) {
                    this.health *= 0.5; // 50% vida
                    this.maxHealth *= 0.5;
                    this.value *= 3; // Triple de oro
                    damageToDeal = 20; // Daño fijo bajo
                }

                this.baseDamage = damageToDeal;
                this.width = TILE_SIZE * typeData.size; this.height = TILE_SIZE * typeData.size;
                this.color = typeData.color;
                this.pathIndex = 0; this.active = true; this.damagingTowers = new Set();
                this.effects = new Map();
                if (type === 'healer' || type === 'disabler') {
                    this.abilityCooldown = 0;
                }
            }
            update(allEnemies, allTowers) {
                if (!this.active) return;
                
                let currentSpeedMultiplier = 1;
                const effectsToRemove = [];

                for (const [type, effect] of this.effects.entries()) {
                    effect.duration--;
                    if (type === 'acid') {
                        this.takeDamage(effect.damagePerTick, null);
                    }
                    if (type === 'slow') {
                        currentSpeedMultiplier = Math.min(currentSpeedMultiplier, effect.multiplier);
                    }
                    if (effect.duration <= 0) {
                        effectsToRemove.push(type);
                    }
                }
                effectsToRemove.forEach(type => this.effects.delete(type));

                if (this.type === 'healer') {
                    this.abilityCooldown--;
                    if (this.abilityCooldown <= 0) {
                        const typeData = ENEMY_TYPES.healer;
                        this.game.effects.push(new Effect(this.game, this.x, this.y, typeData.healRadius, 'rgba(255, 128, 171, 0.3)', 15));
                        allEnemies.forEach(e => {
                            if (e !== this && e.active) {
                                const dist = Math.hypot(this.x - e.x, this.y - e.y);
                                if (dist < typeData.healRadius) {
                                    e.health = Math.min(e.maxHealth, e.health + (e.maxHealth * typeData.healAmount));
                                }
                            }
                        });
                        this.abilityCooldown = typeData.healRate;
                    }
                }

                if (this.type === 'disabler') {
                    this.abilityCooldown--;
                    if (this.abilityCooldown <= 0) {
                        const typeData = ENEMY_TYPES.disabler;
                        this.game.effects.push(new Effect(this.game, this.x, this.y, typeData.disableRadius, 'rgba(213, 0, 249, 0.3)', 15));
                        allTowers.forEach(t => {
                            const dist = Math.hypot(this.x - t.x, this.y - t.y);
                            if (dist < typeData.disableRadius) {
                                t.disabledTimer = typeData.disableDuration;
                            }
                        });
                        this.abilityCooldown = typeData.disableRate;
                    }
                }

                const currentPath = this.isFlying ? this.game.airPath : this.game.path;
                const targetPoint = currentPath[this.pathIndex]; 
                if (!targetPoint) return;

                const dx = targetPoint.x - this.x, dy = targetPoint.y + TILE_SIZE / 2 - this.y; const dist = Math.sqrt(dx * dx + dy * dy);
                const currentSpeed = this.speed * currentSpeedMultiplier;
                if (dist < currentSpeed) {
                    this.pathIndex++;
                    if (this.pathIndex >= currentPath.length) {
                        this.active = false;
                        let finalDamage = this.baseDamage;
                        if (finalDamage < 1) finalDamage = Math.floor(this.game.maxBaseHealth * finalDamage);
                        this.game.damageBase(finalDamage); return;
                    }
                } else { this.x += (dx / dist) * currentSpeed; this.y += (dy / dist) * currentSpeed; }
            }
            draw(ctx, frameCount) {
                if (this.isFlying) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(this.x, this.y + this.height / 2 + 5, this.width / 2, this.width / 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.fillStyle = this.color; 
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                
                if (this.effects.size > 0) {
                    const firstEffectType = this.effects.keys().next().value;
                    let flashColor = '';
                    if (firstEffectType === 'acid') flashColor = 'rgba(127, 255, 0, 0.7)';
                    if (firstEffectType === 'slow') flashColor = 'rgba(100, 181, 246, 0.7)';
                    
                    if (flashColor && frameCount % 20 < 10) {
                        ctx.fillStyle = flashColor;
                        ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                    }
                }

                const hbW = this.width, hbH = 5; ctx.fillStyle = '#333'; ctx.fillRect(this.x - hbW / 2, this.y - this.height / 2 - 10, hbW, hbH);
                ctx.fillStyle = '#76FF03'; ctx.fillRect(this.x - hbW / 2, this.y - this.height / 2 - 10, hbW * (this.health / this.maxHealth), hbH);
            }
            takeDamage(amount, tower) {
                this.health -= amount; if (tower) this.damagingTowers.add(tower);
                if (this.health <= 0 && this.active) {
                    this.active = false; 
                    this.game.enemyDefeated(this);
                }
            }
            applyEffect(type, effectData) {
                this.effects.set(type, { ...effectData });
            }
             teleport(indicesBack) {
                this.pathIndex = Math.max(0, this.pathIndex - indicesBack);
                const newPos = this.game.path[this.pathIndex];
                if (newPos) {
                    this.x = newPos.x;
                    this.y = newPos.y;
                }
            }
        }

        class Tower {
            constructor(game, gridX, gridY, type) {
                this.game = game; this.x = gridX * TILE_SIZE + TILE_SIZE / 2; this.y = gridY * TILE_SIZE + TILE_SIZE / 2;
                this.gridX = gridX; this.gridY = gridY; this.typeKey = type;
                this.typeInfo = JSON.parse(JSON.stringify(TOWER_TYPES[type]));
                this.fireCooldown = 0;
                this.upgradeCount = 0;
                this.MAX_UPGRADES = 8;
                this.isEvolved = false;
                
                const modifiers = DIFFICULTY_MODIFIERS[this.game.difficulty];
                const baseCost = this.typeInfo.cost * modifiers.towerCost;

                this.totalInvestedGold = baseCost;
                this.upgradeCost = Math.floor(baseCost * 0.6);
                this.disabledTimer = 0;
                this.shotsLeft = 0;
            }
            update(enemies) {
                if (this.disabledTimer > 0) {
                    this.disabledTimer--;
                    return;
                }
                this.fireCooldown--;
                if (this.fireCooldown <= 0) { 
                    if (this.typeInfo.shotsPerWave && this.shotsLeft <= 0) {
                        return;
                    }
                    const target = this.findTarget(enemies); 
                    if (target) { 
                        this.shoot(target); 
                        this.fireCooldown = this.typeInfo.fireRate; 
                    } 
                }
            }
            draw(ctx, frameCount) {
                const coreRadius = TILE_SIZE / 2 - 2;

                ctx.fillStyle = '#555'; 
                ctx.beginPath(); 
                ctx.arc(this.x, this.y, coreRadius, 0, Math.PI * 2); 
                ctx.fill();

                ctx.font = `${TILE_SIZE * 0.8}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.typeInfo.emoji, this.x, this.y);

                if (this.disabledTimer > 0) {
                    ctx.fillStyle = 'rgba(50, 50, 50, 0.7)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, coreRadius, 0, Math.PI * 2);
                    ctx.fill();
                    if (frameCount % 4 < 2) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.lineWidth = 1;
                        for (let i = 0; i < 5; i++) {
                            ctx.beginPath();
                            ctx.moveTo(this.x - coreRadius + Math.random() * coreRadius * 2, this.y - coreRadius + Math.random() * coreRadius * 2);
                            ctx.lineTo(this.x - coreRadius + Math.random() * coreRadius * 2, this.y - coreRadius + Math.random() * coreRadius * 2);
                            ctx.stroke();
                        }
                    }
                }

                const pipRadius = 2.5;
                const pipOrbitRadius = TILE_SIZE / 2 - 4;
                for (let i = 0; i < this.upgradeCount; i++) {
                    const angle = (i * (Math.PI / 4)) - (Math.PI / 2) - (Math.PI / 8);
                    ctx.fillStyle = '#FFC107';
                    ctx.beginPath();
                    ctx.arc(this.x + pipOrbitRadius * Math.cos(angle), this.y + pipOrbitRadius * Math.sin(angle), pipRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                if (this.isEvolved && this.typeInfo.shotsPerWave) {
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 10px Segoe UI';
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(this.shotsLeft, this.x + TILE_SIZE / 2, this.y + TILE_SIZE / 2);
                }
            }
            findTarget(enemies) {
                let target = null;

                if (this.typeInfo.special === 'sniper') {
                    const eliteEnemies = enemies.filter(e => ['boss', 'healer', 'disabler'].includes(e.type));
                    if (eliteEnemies.length > 0) {
                        enemies = eliteEnemies;
                    }
                }
                
                let minDistance = Infinity;
                for (const e of enemies) {
                    if (e.isFlying && !this.typeInfo.canHitFlying) continue;
                    const dist = Math.hypot(e.x - this.x, e.y - this.y);
                    if (dist < this.typeInfo.range && dist < minDistance) {
                        minDistance = dist;
                        target = e;
                    }
                }
                return target;
            }
            shoot(target) { 
                const p = new Projectile(this.game, this.x, this.y, target, this, this.typeKey, this.typeInfo.special); 
                this.game.projectiles.push(p); 
                if (this.typeInfo.shotsPerWave) {
                    this.shotsLeft--;
                }
            }
            
            applyUpgradeStats() {
                const uInfo = TOWER_TYPES[this.typeKey].upgrade;
                if(uInfo.damage) this.typeInfo.damage += uInfo.damage;
                if(uInfo.range) this.typeInfo.range += uInfo.range;
                if(uInfo.fireRate) this.typeInfo.fireRate = Math.max(10, this.typeInfo.fireRate - uInfo.fireRate);
                if(uInfo.splashRadius && this.typeInfo.splashRadius) this.typeInfo.splashRadius += uInfo.splashRadius;
                if(uInfo.acidMultiplier && this.typeInfo.acid) this.typeInfo.acid.multiplier += uInfo.acidMultiplier;
                if(uInfo.slowRadius && this.typeInfo.slowRadius) this.typeInfo.slowRadius += uInfo.slowRadius;
            }

            upgrade() {
                this.totalInvestedGold += this.upgradeCost;
                this.upgradeCount++;
                this.applyUpgradeStats();
                this.upgradeCost = Math.floor(this.upgradeCost * 1.7);
            }

            evolve(pathKey) {
                if (this.isEvolved || !this.typeInfo.evolutions) return;
                
                const evolutionData = this.typeInfo.evolutions.paths[pathKey];
                
                if (this.game.gold >= this.upgradeCost || cheats.unlimitedResources) {
                    if (!cheats.unlimitedResources) {
                        this.game.gold -= this.upgradeCost;
                    }
                    this.totalInvestedGold += this.upgradeCost;

                    // Merge evolution stats
                    Object.assign(this.typeInfo, evolutionData);

                    if (this.typeInfo.special === 'sniper') {
                        this.typeInfo.damage *= (1 + this.game.waveNumber * 0.1);
                    }

                    if (this.typeInfo.shotsPerWave) {
                        this.shotsLeft = this.typeInfo.shotsPerWave;
                    }

                    this.isEvolved = true;
                    this.game.closeMenu();
                }
            }
        }

        class Projectile {
            constructor(game, x, y, target, tower, typeKey, special = null) {
                this.game = game; this.x = x; this.y = y; this.tower = tower; this.typeKey = typeKey;
                this.speed = tower.typeInfo.projectileSpeed; this.damage = tower.typeInfo.damage; this.color = tower.typeInfo.projectileColor; this.active = true;
                this.special = special;
                
                this.targetX = target.x;
                this.targetY = target.y;
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                this.velocityX = (dx / dist) * this.speed;
                this.velocityY = (dy / dist) * this.speed;
                this.rotation = Math.atan2(dy, dx);
                this.isGroundTarget = ['cannon', 'ice', 'acid', 'pull', 'teleport'].includes(this.special) || ['cannon', 'ice', 'acid'].includes(this.typeKey);

                if (this.typeKey === 'acid') {
                    this.particles = [];
                }
            }
            update() {
                if (!this.active) return;

                this.x += this.velocityX;
                this.y += this.velocityY;

                if (this.x < 0 || this.x > this.game.width || this.y < 0 || this.y > this.game.height) {
                    this.active = false;
                    return;
                }

                if (this.typeKey === 'acid') {
                    this.game.effects.push(new Particle(this.game, this.x, this.y, this.color));
                }

                if (this.isGroundTarget) {
                    const distToTarget = Math.hypot(this.x - this.targetX, this.y - this.targetY);
                    if (distToTarget < this.speed) {
                        this.active = false;
                        this.onHitGround(this.targetX, this.targetY);
                    }
                } else {
                    for (const enemy of this.game.enemies) {
                        if (!enemy.active) continue;
                        if (enemy.isFlying && !this.tower.typeInfo.canHitFlying) continue;

                        const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                        if (dist < enemy.width / 2) {
                            this.active = false;
                            this.onHit(enemy);
                            return;
                        }
                    }
                }
            }
            
            onHit(enemy) { // Para proyectiles de impacto directo
                enemy.takeDamage(this.damage, this.tower);
            }

            onHitGround(impactX, impactY) { // Para proyectiles de área
                const tInfo = this.tower.typeInfo;

                if (tInfo.special === 'pull') {
                    this.game.effects.push(new SingularityEffect(this.game, impactX, impactY, tInfo.splashRadius));
                } else if (tInfo.special === 'teleport') {
                    this.game.enemies.forEach(e => {
                        if (!e.active || e.isFlying) return;
                        const d = Math.hypot(e.x - impactX, e.y - impactY);
                        if (d <= tInfo.splashRadius) {
                            e.teleport(3);
                        }
                    });
                }

                if (this.typeKey === 'cannon' && !tInfo.special) {
                    this.game.effects.push(new Effect(this.game, impactX, impactY, tInfo.splashRadius, 'rgba(100, 100, 100, 0.5)', 15));
                    this.game.enemies.forEach(e => {
                        if (!e.active || e.isFlying) return;
                        const dX = e.x - impactX, dY = e.y - impactY; const sDist = Math.sqrt(dX*dX + dY*dY);
                        if (sDist <= tInfo.splashRadius) e.takeDamage(this.damage, this.tower);
                    });
                } else if (this.typeKey === 'ice') { 
                    const slowPower = Math.max(tInfo.slow.maxSlow, tInfo.slow.baseMultiplier - (this.damage * tInfo.slow.damageScale));
                    this.game.effects.push(new Effect(this.game, impactX, impactY, tInfo.slowRadius, 'rgba(3, 169, 244, 0.3)', 20));
                    this.game.enemies.forEach(e => {
                        if (!e.active || e.isFlying) return;
                        const dX = e.x - impactX, dY = e.y - impactY; const sDist = Math.sqrt(dX*dX + dY*dY);
                        if (sDist <= tInfo.slowRadius) {
                            e.applyEffect('slow', { multiplier: slowPower, duration: tInfo.slow.duration });
                        }
                    });
                } else if (this.typeKey === 'acid') {
                    this.game.effects.push(new AcidPuddle(this.game, impactX, impactY, this.damage, tInfo.acid));
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = this.color;

                switch(this.special) {
                    case 'sniper':
                        ctx.fillRect(-10, -1.5, 20, 3);
                        break;
                    case 'gatling':
                        ctx.beginPath();
                        ctx.arc(0, 0, 3, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'pull':
                        ctx.globalAlpha = 0.5 + 0.5 * Math.sin(this.game.frameCount * 0.2);
                        ctx.beginPath();
                        ctx.arc(0, 0, 7, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'teleport':
                        ctx.beginPath();
                        ctx.arc(0, 0, 7, 0, Math.PI * 2);
                        ctx.fill();
                        for(let i = 0; i < 3; i++) {
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(Math.random() * 10 - 5, Math.random() * 10 - 5);
                            ctx.lineTo(Math.random() * 10 - 5, Math.random() * 10 - 5);
                            ctx.stroke();
                        }
                        break;
                    default:
                        switch(this.typeKey) {
                            case 'ice':
                                ctx.beginPath();
                                ctx.moveTo(0, -6);
                                ctx.lineTo(6, 0);
                                ctx.lineTo(0, 6);
                                ctx.lineTo(-6, 0);
                                ctx.closePath();
                                ctx.fill();
                                break;
                            case 'cannon':
                                ctx.beginPath();
                                ctx.arc(0, 0, 7, 0, Math.PI * 2);
                                ctx.fill();
                                break;
                            default: // Arrow, Acid
                                ctx.beginPath();
                                ctx.arc(0, 0, 5, 0, Math.PI * 2);
                                ctx.fill();
                        }
                }
                ctx.restore();
            }
        }

        class Effect {
            constructor(game, x, y, radius, color, life) {
                this.game = game; this.x = x; this.y = y; this.maxRadius = radius; this.color = color;
                this.life = life; this.maxLife = life; this.active = true;
            }
            update() { this.life--; if (this.life <= 0) this.active = false; }
            draw(ctx) {
                const r = this.maxRadius * (1 - (this.life / this.maxLife));
                ctx.globalAlpha = this.life / this.maxLife; ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
                ctx.strokeStyle = this.color; ctx.lineWidth = 3; ctx.stroke(); ctx.globalAlpha = 1.0; ctx.lineWidth = 1;
            }
        }

        // <-- CAMBIO: Nueva clase para el charco de ácido
        class AcidPuddle extends Effect {
            constructor(game, x, y, damage, acidData) {
                super(game, x, y, TILE_SIZE * 0.8, 'rgba(127, 255, 0, 0.4)', 144); // 2.4 segundos
                this.damage = damage;
                this.acidData = acidData;
                this.affectedEnemies = new Set();
            }
            update() {
                super.update();
                this.game.enemies.forEach(e => {
                    if (e.active && !e.isFlying && !this.affectedEnemies.has(e)) {
                        const dist = Math.hypot(this.x - e.x, this.y - e.y);
                        if (dist < this.maxRadius) {
                            const acidDps = this.damage * this.acidData.multiplier;
                            e.applyEffect('acid', { damagePerTick: acidDps, duration: this.acidData.duration });
                            this.affectedEnemies.add(e);
                        }
                    }
                });
            }
            draw(ctx) {
                ctx.globalAlpha = (this.life / this.maxLife) * 0.5;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.maxRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        // <-- CAMBIO: Nueva clase para las partículas
        class Particle extends Effect {
            constructor(game, x, y, color) {
                super(game, x, y, 0, color, 20);
                this.size = Math.random() * 2 + 1;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life / this.maxLife;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class SingularityEffect extends Effect {
            constructor(game, x, y, radius) {
                super(game, x, y, radius, 'rgba(150, 50, 255, 0.7)', 60); // Lasts 1 second
                this.pullStrength = 2.5;
            }
            update() {
                super.update();
                this.game.enemies.forEach(e => {
                    if (e.active && !e.isFlying) {
                        const dist = Math.hypot(e.x - this.x, e.y - this.y);
                        if (dist < this.maxRadius) {
                            const angle = Math.atan2(this.y - e.y, this.x - e.x);
                            e.x += Math.cos(angle) * this.pullStrength;
                            e.y += Math.sin(angle) * this.pullStrength;
                        }
                    }
                });
            }
            draw(ctx) {
                const r = this.maxRadius * (this.life / this.maxLife);
                ctx.globalAlpha = (this.life / this.maxLife) * 0.5;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class MeteorEffect extends Effect {
            constructor(game, x, y, radius, damage) {
                super(game, x, y, radius, 'rgba(255, 100, 0, 0.7)', 45);
                this.damage = damage; this.fallDuration = 30; this.hasImpacted = false;
            }
            update() {
                this.life--; if (this.life <= 0) this.active = false;
                if (this.life <= (this.maxLife - this.fallDuration) && !this.hasImpacted) { this.impact(); this.hasImpacted = true; }
            }
            draw(ctx) {
                if (this.life > (this.maxLife - this.fallDuration)) {
                    const fallProgress = (this.maxLife - this.life) / this.fallDuration;
                    const meteorY = this.y * fallProgress - 50 * (1-fallProgress);
                    ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.arc(this.x, meteorY, 15, 0, Math.PI * 2); ctx.fill();
                } else {
                    const explosionLife = this.maxLife - this.fallDuration;
                    const r = this.maxRadius * (1 - ((this.life) / explosionLife));
                    ctx.globalAlpha = this.life / explosionLife; ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
                    ctx.fillStyle = this.color; ctx.fill(); ctx.globalAlpha = 1.0;
                }
            }
            impact() {
                this.game.enemies.forEach(e => {
                    if (!e.active) return;
                    const dX = e.x - this.x, dY = e.y - this.y; const dist = Math.sqrt(dX*dX + dY*dY);
                    if (dist <= this.maxRadius) e.takeDamage(this.damage, null);
                });
            }
        }

        // --- CLASE DEL TUTORIAL INTERACTIVO ---
        class TutorialManager {
            constructor(game) {
                this.game = game;
                this.currentStep = 0;
                this.isPaused = false;
                this.waitingFor = null;

                // Elementos del DOM
                this.overlay = document.getElementById('tutorial-overlay');
                this.highlight = document.getElementById('tutorial-highlight');
                this.messageBox = document.getElementById('tutorial-message-box');
                this.messageText = document.getElementById('tutorial-message-text');
                this.nextButton = document.getElementById('tutorial-next-step-button');

                this.steps = [
                    { 
                        text: "¡Bienvenido al tutorial! Tu objetivo es defender la base (al final del camino) de los enemigos que vienen por aquí.",
                        highlightTarget: () => this.game.canvas,
                        waitFor: { type: 'button_click' }
                    },
                    {
                        text: "Para defenderte, necesitas construir torres. Haz clic en esta casilla vacía para empezar.",
                        highlightTarget: () => {
                            const rect = this.game.canvas.getBoundingClientRect();
                            return { 
                                left: rect.left + (5 * TILE_SIZE * this.game.scale), 
                                top: rect.top + (3 * TILE_SIZE * this.game.scale), 
                                width: TILE_SIZE * this.game.scale, 
                                height: TILE_SIZE * this.game.scale 
                            };
                        },
                        waitFor: { type: 'canvas_click', condition: (data) => {
                            const gridX = Math.floor(data.x / TILE_SIZE);
                            const gridY = Math.floor(data.y / TILE_SIZE);
                            return gridX === 5 && gridY === 3;
                        }}
                    },
                    {
                        text: "¡Excelente! Ahora construye una Torre de Flechas. Es la única disponible al principio.",
                        waitFor: { type: 'tower_built', condition: (data) => data.type === 'arrow' }
                    },
                    {
                        text: "¡Bien hecho! Ahora tienes tu primera defensa. Las torres atacan automáticamente. Presiona 'Iniciar' para comenzar la primera oleada.",
                        highlightTarget: () => document.getElementById('wave-button'),
                        waitFor: { type: 'wave_started' }
                    },
                    {
                        text: "¡Mira cómo tu torre defiende la base! Cuando la oleada termine, podrás construir más.",
                        waitFor: { type: 'wave_cleared' }
                    },
                    {
                        text: "¡Felicidades! Has completado el tutorial. Ahora estás listo para jugar. ¡Buena suerte!",
                        highlightTarget: () => this.game.canvas,
                        waitFor: { type: 'button_click' }
                    }
                ];
            }

            start() {
                this.overlay.style.display = 'block';
                this.currentStep = -1;
                this.nextStep();
            }

            nextStep() {
                this.currentStep++;
                if (this.currentStep >= this.steps.length) {
                    this.end();
                    return;
                }
                this.runStep(this.currentStep);
            }

            runStep(index) {
                const step = this.steps[index];
                this.isPaused = (step.waitFor.type !== 'wave_cleared'); // Pause unless waiting for wave to clear
                this.game.isPaused = this.isPaused;
                this.waitingFor = step.waitFor;
                this.showMessage(step.text);

                if (step.highlightTarget) {
                    this.highlightElement(step.highlightTarget());
                } else {
                    this.highlight.style.display = 'none';
                }

                if (step.waitFor.type === 'button_click' && !step.waitFor.element) {
                    this.nextButton.style.display = 'block';
                    this.nextButton.onclick = () => {
                        this.nextButton.style.display = 'none';
                        this.nextStep();
                    };
                } else {
                     this.nextButton.style.display = 'none';
                }
            }
            
            highlightElement(target) {
                if (!target) {
                    this.highlight.style.display = 'none';
                    return;
                }
                
                let rect;
                if (target instanceof HTMLElement) {
                    rect = target.getBoundingClientRect();
                } else {
                    rect = target; // Es un objeto con left, top, width, height
                }

                this.highlight.style.display = 'block';
                this.highlight.style.left = `${rect.left - 5}px`;
                this.highlight.style.top = `${rect.top - 5}px`;
                this.highlight.style.width = `${rect.width + 10}px`;
                this.highlight.style.height = `${rect.height + 10}px`;

                // --- POSICIONAMIENTO INTELIGENTE DE LA CAJA DE MENSAJE ---
                const canvasRect = this.game.canvas.getBoundingClientRect();
                const msgBox = this.messageBox;
                const msgBoxRect = msgBox.getBoundingClientRect(); // Get its dimensions
                const margin = 15; // Margin from edges

                // Center of the highlighted target
                const targetCenterX = rect.left + rect.width / 2;
                const targetCenterY = rect.top + rect.height / 2;

                // Default position: bottom right of the canvas
                let newLeft = canvasRect.right - msgBoxRect.width - margin;
                let newTop = canvasRect.bottom - msgBoxRect.height - margin;

                // If the target is in the bottom-right quadrant, move the box to the top-left
                if (targetCenterX > canvasRect.left + canvasRect.width / 2 && targetCenterY > canvasRect.top + canvasRect.height / 2) {
                    newLeft = canvasRect.left + margin;
                    newTop = canvasRect.top + margin;
                } 
                // If the target is in the bottom-left, move box to top-right
                else if (targetCenterX <= canvasRect.left + canvasRect.width / 2 && targetCenterY > canvasRect.top + canvasRect.height / 2) {
                    newLeft = canvasRect.right - msgBoxRect.width - margin;
                    newTop = canvasRect.top + margin;
                }
                // If the target is in the top-right, move box to bottom-left
                else if (targetCenterX > canvasRect.left + canvasRect.width / 2 && targetCenterY <= canvasRect.top + canvasRect.height / 2) {
                    newLeft = canvasRect.left + margin;
                    newTop = canvasRect.bottom - msgBoxRect.height - margin;
                }
                // If the target is in the top-left, move box to bottom-right (the default)

                // Clamp values to ensure it's always inside the canvas
                newLeft = Math.max(canvasRect.left, Math.min(newLeft, canvasRect.right - msgBoxRect.width));
                newTop = Math.max(canvasRect.top, Math.min(newTop, canvasRect.bottom - msgBoxRect.height));

                msgBox.style.left = `${newLeft}px`;
                msgBox.style.top = `${newTop}px`;
            }

            showMessage(text) {
                this.messageText.innerHTML = text;
            }

            isWaitingForInput() {
                return !!this.waitingFor;
            }

            handleInput(inputType, data) {
                if (!this.waitingFor || this.waitingFor.type !== inputType) return false;
                
                if (this.waitingFor.condition) {
                    if (this.waitingFor.condition(data)) {
                        this.nextStep();
                        return true;
                    }
                }
                return false;
            }

            checkCondition(conditionType, data) {
                 if (!this.waitingFor || this.waitingFor.type !== conditionType) return false;
                 if (this.waitingFor.condition) {
                       if(this.waitingFor.condition(data)) {
                           this.nextStep();
                           return true;
                       }
                 } else {
                       this.nextStep();
                       return true;
                 }
                 return false;
            }

            getWaveConfig() {
                return [{ type: 'standard' }, { type: 'standard' }];
            }

            end() {
                this.overlay.style.display = 'none';
                // Se eliminó el alert para evitar problemas de compatibilidad y bloqueo
                window.location.reload();
            }
        }
        
        // --- LÓGICA DE LA INTERFAZ Y EL MENÚ ---
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            let game;
            let selectedDifficulty = 'normal';

            // --- DEV TOOLS ---
            let secretCodeSequence = [];
            const targetSequence = ['gold-rush-button', 'pause-button', 'wave-button'];
            let isDeveloperMode = false;
            

            // Elementos de la interfaz
            const mainMenuScreen = document.getElementById('main-menu-screen');
            const mapSelectionScreen = document.getElementById('map-selection-screen');
            const gameUiContainer = document.getElementById('game-ui-container');
            const tutorialPromptModal = document.getElementById('tutorial-prompt-modal');
            const playOptionsModal = document.getElementById('play-options-modal');
            const arsenalModal = document.getElementById('arsenal-modal');
            const bestiaryModal = document.getElementById('bestiary-modal');
            const powersModal = document.getElementById('powers-modal');
            const meteorUnlockModal = document.getElementById('meteor-unlock-modal');
            const devToolsButton = document.getElementById('dev-tools-button');
            const devToolsModal = document.getElementById('dev-tools-modal');
            const difficultyModal = document.getElementById('difficulty-modal');
            const difficultyButton = document.getElementById('difficulty-button');


            // Botones del menú principal
            const playButton = document.getElementById('play-button');
            const tutorialButton = document.getElementById('tutorial-button');
            const exitButton = document.getElementById('exit-button');
            const continueButton = document.getElementById('continue-button');
            const newGameButton = document.getElementById('new-game-button');

            function setupGameListeners() {
                // --- SECRET CODE LISTENER ---
                const secretButtons = ['gold-rush-button', 'pause-button', 'wave-button'];
                secretButtons.forEach(id => {
                    document.getElementById(id).addEventListener('click', () => {
                        if (isDeveloperMode) return;
                        secretCodeSequence.push(id);
                        if (secretCodeSequence.length > targetSequence.length) {
                            secretCodeSequence.shift();
                        }
                        if (JSON.stringify(secretCodeSequence) === JSON.stringify(targetSequence)) {
                            isDeveloperMode = true;
                            devToolsButton.style.display = 'block';
                            secretCodeSequence = [];
                        }
                    });
                });

                document.getElementById('wave-button').onclick = () => game.startWave();
                document.getElementById('pause-button').onclick = () => game.togglePause();
                document.getElementById('speed-1x-button').onclick = () => game.setSpeed(1);
                document.getElementById('speed-2x-button').onclick = () => game.setSpeed(2);
                document.getElementById('speed-5x-button').onclick = () => game.setSpeed(5);
                document.getElementById('meteor-button').onclick = () => game.activateMeteor();
                document.getElementById('gold-rush-button').onclick = () => game.activateGoldRush();
                document.getElementById('continue-endless-button').onclick = () => game.continueEndlessMode();
                document.getElementById('fullscreen-button').onclick = toggleFullScreen;
                document.getElementById('exit-to-menu-button').onclick = () => {
                    stopMusic();
                    window.location.reload();
                };
                
                document.getElementById('arsenal-button').onclick = () => {
                    game.pauseGame();
                    updateArsenalModal();
                    arsenalModal.style.display = 'flex';
                    resizeHandler();
                };
                document.getElementById('close-arsenal-button').onclick = () => {
                    arsenalModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };
                document.getElementById('close-arsenal-x').onclick = () => {
                    arsenalModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };

                document.getElementById('bestiary-button').onclick = () => {
                    game.pauseGame();
                    updateBestiaryModal();
                    bestiaryModal.style.display = 'flex';
                    resizeHandler();
                };
                document.getElementById('close-bestiary-button').onclick = () => {
                    bestiaryModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };
                document.getElementById('close-bestiary-x').onclick = () => {
                    bestiaryModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };
                
                document.getElementById('powers-button').onclick = () => {
                    game.pauseGame();
                    updatePowersModal();
                    powersModal.style.display = 'flex';
                    resizeHandler();
                };
                document.getElementById('close-powers-button').onclick = () => {
                    powersModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };
                document.getElementById('close-powers-x').onclick = () => {
                    powersModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };

                const closeMeteorUnlock = () => {
                    if (document.getElementById('hide-meteor-checkbox').checked) {
                        localStorage.setItem('hideMeteorUnlock', 'true');
                    }
                    meteorUnlockModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                };
                document.getElementById('close-meteor-unlock-button').onclick = closeMeteorUnlock;

                canvas.addEventListener('mousemove', (e) => {
                    if(game) {
                        game.mousePos = { x: e.clientX, y: e.clientY };
                    }
                });

                canvas.addEventListener('click', (e) => {
                    if(game) {
                        const { x, y } = getGameCoordinates(e.clientX, e.clientY);
                        game.handleCanvasClick(x, y);
                    }
                });
                
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault(); 
                    if (e.changedTouches.length === 1 && game) {
                        const touch = e.changedTouches[0];
                        const { x, y } = getGameCoordinates(touch.clientX, touch.clientY);
                        game.handleCanvasClick(x, y);
                    }
                });

                window.onkeydown = (event) => {
                    if (event.key === 'Escape' && game) { 
                        game.closeMenu(); 
                        game.activeAbility = null; 
                    }
                };

                // --- DEV TOOLS LISTENERS ---
                devToolsButton.addEventListener('click', () => {
                    devToolsModal.style.display = 'flex';
                    game.pauseGame();
                });

                document.getElementById('close-dev-tools-x').addEventListener('click', () => {
                    devToolsModal.style.display = 'none';
                    if (game && !game.isTutorial) game.resumeGame();
                });

                document.getElementById('dev-resources').addEventListener('click', (e) => {
                    cheats.unlimitedResources = !cheats.unlimitedResources;
                    e.target.classList.toggle('active', cheats.unlimitedResources);
                    if (cheats.unlimitedResources) {
                        game.gold = 999999;
                        game.diamonds = 9999;
                        game.updateUI();
                    }
                });
                document.getElementById('dev-health').addEventListener('click', (e) => {
                    cheats.unlimitedHealth = !cheats.unlimitedHealth;
                    e.target.classList.toggle('active', cheats.unlimitedHealth);
                });
                document.getElementById('dev-cooldowns').addEventListener('click', (e) => {
                    cheats.noCooldowns = !cheats.noCooldowns;
                    e.target.classList.toggle('active', cheats.noCooldowns);
                });
                document.getElementById('dev-exit').addEventListener('click', () => {
                    isDeveloperMode = false;
                    Object.keys(cheats).forEach(k => cheats[k] = false);
                    document.querySelectorAll('.dev-options .modal-button').forEach(b => b.classList.remove('active'));
                    devToolsButton.style.display = 'none';
                    devToolsModal.style.display = 'none';
                    game.resumeGame();
                });
            }

            function launchGame(mapId, savedData = null) {
                mapSelectionScreen.style.display = 'none';
                playOptionsModal.style.display = 'none';
                mainMenuScreen.style.display = 'none';
                gameUiContainer.style.display = 'flex';
                
                const difficulty = savedData && savedData.difficulty ? savedData.difficulty : selectedDifficulty;

                game = new Game(canvas, mapId, savedData, false, difficulty);
                generateImages();
                setupGameListeners();
                playMusic();
                
                setTimeout(resizeHandler, 0);
            }

            function launchTutorial() {
                mainMenuScreen.style.display = 'none';
                gameUiContainer.style.display = 'flex';
                game = new Game(canvas, 'classic', null, true);
                generateImages();
                setupGameListeners();
                playMusic();
                
                setTimeout(() => {
                    resizeHandler();
                    game.tutorialManager.start();
                }, 0);
            }


            // --- Event Listeners del Menú Principal ---
            playButton.addEventListener('click', () => {
                const savedGame = localStorage.getItem('towerDefenseProgress');
                if (savedGame) {
                    playOptionsModal.style.display = 'flex';
                } else {
                     if (!localStorage.getItem('hideTutorialPrompt')) {
                        tutorialPromptModal.style.display = 'flex';
                    } else {
                        mainMenuScreen.style.display = 'none';
                        difficultyModal.style.display = 'flex';
                        resizeHandler();
                    }
                }
            });

            difficultyButton.addEventListener('click', () => {
                mainMenuScreen.style.display = 'none';
                difficultyModal.style.display = 'flex';
                resizeHandler();
            });

            document.querySelectorAll('.difficulty-select-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    selectedDifficulty = e.target.dataset.difficulty;
                    difficultyModal.style.display = 'none';
                    mapSelectionScreen.style.display = 'flex';
                    resizeHandler();
                });
            });

            continueButton.addEventListener('click', () => {
                 const savedGameData = JSON.parse(localStorage.getItem('towerDefenseProgress'));
                 if (savedGameData) {
                    launchGame(savedGameData.mapId, savedGameData);
                 }
            });
            
            newGameButton.addEventListener('click', () => {
                localStorage.removeItem('towerDefenseProgress');
                playOptionsModal.style.display = 'none';
                mainMenuScreen.style.display = 'none';
                difficultyModal.style.display = 'flex';
                resizeHandler();
            });

            playOptionsModal.querySelector('.modal-close-button').addEventListener('click', () => {
                playOptionsModal.style.display = 'none';
            });


            tutorialButton.addEventListener('click', launchTutorial);
            
            exitButton.addEventListener('click', () => {
                window.close();
            });

            // --- Event Listeners del Modal de Pregunta del Tutorial ---
            document.getElementById('play-tutorial-button').addEventListener('click', () => {
                if (document.getElementById('hide-tutorial-prompt-checkbox').checked) {
                    localStorage.setItem('hideTutorialPrompt', 'true');
                }
                tutorialPromptModal.style.display = 'none';
                launchTutorial();
            });

            document.getElementById('skip-tutorial-button').addEventListener('click', () => {
                if (document.getElementById('hide-tutorial-prompt-checkbox').checked) {
                    localStorage.setItem('hideTutorialPrompt', 'true');
                }
                tutorialPromptModal.style.display = 'none';
                mainMenuScreen.style.display = 'none';
                difficultyModal.style.display = 'flex';
                resizeHandler();
            });

            // --- Lógica de Escalado General ---
            function resizeHandler() {
                // Escalar el juego si está visible
                if (window.getComputedStyle(gameUiContainer).display !== 'none' && game) {
                    const nativeWidth = 800 + 240 + 4;
                    const nativeHeight = 520 + document.getElementById('top-bar').offsetHeight;
                    game.scale = Math.min(window.innerWidth / nativeWidth, window.innerHeight / nativeHeight);
                    gameUiContainer.style.transform = `scale(${game.scale})`;
                    if (game.isTutorial && game.tutorialManager.currentStep < game.tutorialManager.steps.length) {
                        game.tutorialManager.highlightElement(game.tutorialManager.steps[game.tutorialManager.currentStep].highlightTarget());
                    }
                }

                // Escalar el menú o la pantalla de mapas si están visibles
                document.querySelectorAll('.screen').forEach(screen => {
                    if (window.getComputedStyle(screen).display !== 'none') {
                        const scale = Math.min(window.innerWidth / screen.offsetWidth, window.innerHeight / screen.offsetHeight);
                        screen.style.transform = `scale(${scale})`;
                    }
                });

                // Escalar modales abiertos
                [arsenalModal, bestiaryModal, playOptionsModal, tutorialPromptModal, powersModal, devToolsModal, difficultyModal].forEach(modal => {
                    const modalContent = modal.querySelector('.modal-content');
                    if(window.getComputedStyle(modal).display !== 'none'){
                        const modalScale = Math.min( (window.innerWidth / modalContent.offsetWidth) * 0.8, (window.innerHeight / modalContent.offsetHeight) * 0.8, 1);
                        modalContent.style.transform = `scale(${modalScale})`;
                    }
                });
            }

            window.addEventListener('resize', resizeHandler);
            
            // Llamada inicial para escalar el menú principal
            resizeHandler();


            function getGameCoordinates(clientX, clientY) {
                if (!game) return {x: 0, y: 0};
                const rect = canvas.getBoundingClientRect();
                const xOnScaledCanvas = clientX - rect.left;
                const yOnScaledCanvas = clientY - rect.top;
                const xOnNativeCanvas = xOnScaledCanvas / game.scale;
                const yOnNativeCanvas = yOnScaledCanvas / game.scale;
                
                return { x: xOnNativeCanvas, y: yOnNativeCanvas };
            }

            const TOWER_IMAGES = {};
            const ENEMY_IMAGES = {};

            function generateImages() {
                for (const type in TOWER_TYPES) {
                    const info = TOWER_TYPES[type];
                    const tempCanvas = document.createElement('canvas'); tempCanvas.width = 50; tempCanvas.height = 50;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.fillStyle = '#555'; tempCtx.beginPath(); tempCtx.arc(25, 25, 23, 0, Math.PI * 2); tempCtx.fill();
                    tempCtx.font = '35px sans-serif';
                    tempCtx.textAlign = 'center';
                    tempCtx.textBaseline = 'middle';
                    tempCtx.fillText(info.emoji, 25, 25);
                    TOWER_IMAGES[type] = tempCanvas.toDataURL();
                }
                for (const type in ENEMY_TYPES) {
                    const info = ENEMY_TYPES[type];
                    const tempCanvas = document.createElement('canvas'); tempCanvas.width = 50; tempCanvas.height = 50;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.fillStyle = info.color;
                    tempCtx.fillRect(25 - (TILE_SIZE * info.size / 2), 25 - (TILE_SIZE * info.size / 2), TILE_SIZE * info.size, TILE_SIZE * info.size);
                    ENEMY_IMAGES[type] = tempCanvas.toDataURL();
                }
            }

            function updateArsenalModal() {
                const container = document.getElementById('arsenal-cards-container');
                container.innerHTML = ''; 

                for (const type in TOWER_TYPES) {
                    const towerInfo = TOWER_TYPES[type];
                    const card = document.createElement('div');
                    card.className = 'info-card';

                    if (game && game.unlockedTowers.has(type)) {
                        const saleValue = Math.floor(towerInfo.cost * 0.7);
                        let html = `
                            <div class="info-card-header">
                                <img class="visual" src="${TOWER_IMAGES[type]}" alt="${towerInfo.name}">
                                <h4>${towerInfo.name}</h4>
                            </div>
                            <p>${towerInfo.desc}</p>
                            <p class="costs">Costo Base: ${towerInfo.cost} | Venta: ${saleValue}</p>
                        `;

                        if (towerInfo.evolutions) {
                            html += `<hr style="border-color: #555; margin: 10px 0;"><h5>Evoluciones (Nivel 8):</h5>`;
                            for (const pathKey in towerInfo.evolutions.paths) {
                                const evo = towerInfo.evolutions.paths[pathKey];
                                html += `<p><strong>${evo.emoji} ${evo.name}:</strong> ${evo.desc}</p>`;
                            }
                        }
                        card.innerHTML = html;

                    } else {
                        card.classList.add('locked');
                        card.innerHTML = `<span>?</span>`;
                    }
                    container.appendChild(card);
                }
            }
            
            function updateBestiaryModal() {
                const container = document.getElementById('bestiary-cards-container');
                container.innerHTML = '';

                for (const type in ENEMY_TYPES) {
                    const enemyInfo = ENEMY_TYPES[type];
                    const card = document.createElement('div');
                    card.className = 'info-card';

                    if (game && game.discoveredEnemies.has(type)) {
                        card.innerHTML = `
                            <div class="info-card-header">
                                <img class="visual" src="${ENEMY_IMAGES[type]}" alt="${enemyInfo.name}">
                                <h4>${enemyInfo.name}</h4>
                            </div>
                            <p>${enemyInfo.desc}</p>
                        `;
                    } else {
                        card.classList.add('locked');
                        card.innerHTML = `<span>?</span>`;
                    }
                    container.appendChild(card);
                }
            }
            
            function updatePowersModal() {
                const container = document.getElementById('powers-cards-container');
                container.innerHTML = '';
                for (const key in ABILITIES) {
                    const ability = ABILITIES[key];
                    const name = key === 'meteor' ? 'Meteorito' : 'Fiebre de Oro';
                    const desc = key === 'meteor' ? 'Invoca un meteorito del cielo que inflige daño masivo en un área. Ideal para eliminar grupos grandes o jefes.' : 'Duplica temporalmente todo el oro ganado al derrotar enemigos. ¡Úsalo antes de una oleada grande para maximizar tus ganancias!';
                    
                    const card = document.createElement('div');
                    card.className = 'info-card';
                    card.innerHTML = `
                        <h4>${name}</h4>
                        <p>${desc}</p>
                        <p class="costs">Costo: ${ability.cost} 💎</p>
                    `;
                    container.appendChild(card);
                }
            }

            function toggleFullScreen() {
                const elem = document.documentElement;
                if (!document.fullscreenElement) {
                    if (elem.requestFullscreen) {
                        elem.requestFullscreen();
                    } else if (elem.webkitRequestFullscreen) { /* Safari */
                        elem.webkitRequestFullscreen();
                    }
                } else {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
            }

            function isTouchDevice() {
                return (('ontouchstart' in window) || (navigator.maxTouchPoints > 0));
            }

            function isIphone() {
                return /iPhone|iPad|iPod/i.test(navigator.userAgent);
            }


            if (isTouchDevice()) {
                document.body.classList.add('is-touch');
            }
            if (isIphone()) {
                document.body.classList.add('is-iphone');
            }

            // --- Lógica de Música y Volumen ---
            const bgm = document.getElementById('bgm');
            const volumeButton = document.getElementById('volume-button');
            const volumeSlider = document.getElementById('volume-slider');
            let isMuted = false;

            function initMusic() {
                const savedVolume = localStorage.getItem('td_volume');
                const savedMute = localStorage.getItem('td_muted') === 'true';

                const volume = savedVolume !== null ? parseFloat(savedVolume) : 0.5;
                isMuted = savedMute;

                bgm.volume = volume;
                volumeSlider.value = volume;
                
                if (isMuted) {
                    bgm.muted = true;
                    volumeButton.textContent = '🔇';
                } else {
                    updateVolumeIcon(volume);
                }

                volumeButton.addEventListener('click', () => {
                    isMuted = !isMuted;
                    bgm.muted = isMuted;
                    localStorage.setItem('td_muted', isMuted);
                    updateVolumeIcon(bgm.volume);
                    volumeSlider.classList.toggle('hidden');
                });

                volumeSlider.addEventListener('input', (e) => {
                    const newVolume = parseFloat(e.target.value);
                    bgm.volume = newVolume;
                    isMuted = newVolume === 0;
                    bgm.muted = isMuted;
                    localStorage.setItem('td_volume', newVolume);
                    localStorage.setItem('td_muted', isMuted);
                    updateVolumeIcon(newVolume);
                });
            }

            function updateVolumeIcon(volume) {
                if (isMuted || volume === 0) {
                    volumeButton.textContent = '🔇';
                } else if (volume < 0.5) {
                    volumeButton.textContent = '🔉';
                } else {
                    volumeButton.textContent = '🔊';
                }
            }

            async function playMusic() {
                try {
                    await Tone.start();
                    await bgm.play();
                } catch(e) {
                    console.warn("La reproducción de audio fue bloqueada por el navegador.");
                }
            }

            function stopMusic() {
                bgm.pause();
                bgm.currentTime = 0;
            }

            initMusic();


            document.querySelectorAll('.map-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const mapId = e.target.dataset.map;
                    launchGame(mapId, null);
                });
            });
        });
    </script>
</body>
</html>
